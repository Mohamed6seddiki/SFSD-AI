[
  {
    "file": "1) Généralités 1.pdf",
    "page": 1,
    "text": "Democratic and Popular Republic of Algeria\nMinistry of Higher Education and Scientific Research \nEcole supérieure en sciences et technologies de \nl’informatique et du numérique \nGeneral Information on Files \nPresented by : Dr. Daoudi Meroua \nAcademic year: 2024/2025"
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 2,
    "text": "Plan \n2\n2024/2025\n2ème année CP\n Basic Concepts\n File Usage Characteristics\n File Typology\n Fundamental Operations on Files\n Memories\n Physical Files and Logical Files\n Physical Record and Logical \nRecord\n Blocking Factor and Its \nImportance\n Conclusion"
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 3,
    "text": "Introduction \n3\n2024/2025\n2ème année CP\n A file is a collection of data stored in secondary memory; this data \ncan be processed by programs. Programs are also stored in the form \nof files. ."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 4,
    "text": "Introduction \n4\n2024/2025\n2ème année CP\nProgram Files: These are files that contain the instructions of a \nprogram. A program file consists of:\nSource File: This file has the extension corresponding to the \nlanguage used in the program, such as .c, .java, .pas, etc.\nExecutable File: These are files that can be executed, typically with \nextensions like .exe, .drv, or .vbx."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 5,
    "text": "Introduction \n5\n2024/2025\n2ème année CP\nData Files: These are files that group the data that a program may \nuse and/or the results it produces. Data files are dynamic, meaning \nthat data can be modified, deleted (erased), added (inserted), or \nsimply viewed.\nExample:\nThe file student.txt, which contains a set of characters created by a \nprogram or a text editor. The contents of the file can be modified \n(insertion, deletion, modification) or consulted."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 6,
    "text": "Introduction \n6\n2024/2025\n2ème année CP\nThe files of interest here are structured data files (such as those for \npeople, works, products, etc.) created by the user for the \nmanagement of a specific application."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 7,
    "text": "Basic Concepts\n7\n2024/2025\n2ème année CP\nThe information processed by the computer is represented in binary, \nthe only form that can be understood by the machine. Thus, any \ninformation is converted into a sequence of bits (0 or 1). This \ninformation is organized into:\nCharacters\nFields\nRecords\nFiles"
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 8,
    "text": "Basic Concepts\n8\n2024/2025\n2ème année CP\nCharacter\nA character is a grouping of bits used to represent an alphanumeric \ncharacter (0, 1, 2, … a, b, c, …) or a special character (&, !, §, …) in \nany encoding.\nA character is the smallest technologically significant grouping of \nbits."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 9,
    "text": "Basic Concepts\n9\n2024/2025\n2ème année CP\nField\nA field refers to a grouping of successive characters that represents \ninformation accessible by a process within a program. To distinguish \nbetween different fields, identifiers are assigned to them.\nExample:\nvar nombre1, nombre2, somme: integer;\nA field can be further decomposed into other fields.\nExample:\nThe field \"date\" can be decomposed into three fields: day, month, year."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 10,
    "text": "Basic Concepts\n10\n2024/2025\n2ème année CP\nRecord\nWhen there are fields that contain information related to a single \nsubject, we refer to it as a record.\nExample:\nNumber: 001 Name: Ait Ahmed First Name: Fateh Address: Oran\nA record is a collection of information contained in fields that \nrelate to the same subject."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 11,
    "text": "Basic Concepts\n11\n2024/2025\n2ème année CP\nNote:\nIt is observed that the fields of two different records can be \nidentical, which may lead to ambiguity. To avoid this situation, there \nmust be information that has a unique value for each student: in \nour example, the student number allows us to distinguish between \nstudents. This information constitutes what we call a key or \nidentifier."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 12,
    "text": "Basic Concepts\n12\n2024/2025\n2ème année CP\nRegardless of the physical medium used to store it, a file is a set of \ninformation of the same nature that describes individuals or objects \n(concrete or abstract) possessing common characteristics.\nExample:\nThe Students file groups the information (Name, First Name, etc.) \nconcerning the students of a given educational institution."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 13,
    "text": "14\n2024/2025\n2ème année CP\nFile Usage Characteristics \nA file is created to be used for the management of any application, \nto perform calculations, etc. Depending on the importance of the \ndata it contains, it undergoes varying levels of manipulations that \ndetermine the file's usage characteristics, namely:\nThe activity of a file\nThe volume of a file\nThe growth of a file"
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 14,
    "text": "15\n2024/2025\n2ème année CP\nThe activity of a file characterizes all the manipulations performed \non the file. It is defined by the following characteristics: \nRate of access \nRate of update \nStability of the file \nFile Usage Characteristics"
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 15,
    "text": "16\n2024/2025\n2ème année CP\nFile Usage Characteristics \nRate of Access: This refers to the ratio between the number of \nrecords accessed (or modified) and the total number of records in \nthe file over a certain period. \nRA= number of records accessed (or modified)/ total number of \nrecords\nRate of Update: This is relative to a given period. It expresses the \nrelative number of new records that are inserted into the file."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 16,
    "text": "17\n2024/2025\n2ème année CP\nFile Usage Characteristics \n File stability: It refers to a given period. A file is considered stable \nduring a period if the number of records created is approximately \nequal to the number of records deleted"
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 17,
    "text": "18\n2024/2025\n2ème année CP\nFile Usage Characteristics \nThe volume or size of a file:\nIt refers to the number of characters contained in the file. This is a \nvery important characteristic for the future use of the file (physical \nimplementation, estimation of file manipulation time).\nFile growth:\nIt refers to the number of records created in relation to the number of \nrecords deleted. It is considered negative when the number of records \ndeleted exceeds the number of records created."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 18,
    "text": "19\n2024/2025\n2ème année CP\nFile Usage Characteristics \nSeveral types of files can be distinguished according to:\nThe nature of the information they contain.\nTheir lifespan.\nThe type of storage medium used.\nThe organization of the information"
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 19,
    "text": "20\n2024/2025\n2ème année CP\nFile Usage Characteristics \nTypes of files based on the nature of the information:\nA file can contain two types of information: data or programs. \nDepending on the case, we refer to a data file or a program file.\nExample:\nThe files students and modules are data files.\nThe file calculation is a program file used to calculate students' \naverage grades."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 20,
    "text": "21\n2024/2025\n2ème année CP\nFile Usage Characteristics \nTypes of Files Based on Their Lifespan\nPermanent Files:\nDefinition: These files contain crucial, long-term data used by an \napplication.\nExample: In student management, the \"student record\" file is a \npermanent file, as its contents are not frequently updated but \nremain critical for long-term reference."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 21,
    "text": "22\n2024/2025\n2ème année CP\nFile Usage Characteristics \nTypes of Files Based on Their Lifespan\nMovement Files :\nDefinition: Temporary files used to update permanent files. They \nhave a short lifespan and are deleted after their purpose is \nfulfilled.\nExample: A file containing newly registered students each \nsemester. Once their details are added to the permanent student \nfile, this movement file is no longer needed."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 22,
    "text": "23\n2024/2025\n2ème année CP\nFile Usage Characteristics \nTypes of Files Based on Their Lifespan\nManeuver Files \nDefinition: These files are used when there is insufficient memory to \nhandle large datasets. They exist only as long as the associated \nprocess runs.\nExample: If a school system processes many students' exam scores, a \nmaneuver file may temporarily hold the data of those students who \nare due for makeup exams."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 23,
    "text": "24\n2024/2025\n2ème année CP\nFile Usage Characteristics \nTypes of Files Based on Their Lifespan\nIntermediate Files:\nDefinition: These files store the results of a process temporarily. They \ncan be used in later stages of the same process or by other processes.\nExample: A file storing semester-end results, which might later be \nused to assign students to internships based on their performance."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 24,
    "text": "25\n2024/2025\n2ème année CP\nFile Usage Characteristics \nTypes of Files Based on Their Lifespan\nArchive and Historical Files:\nDefinition: These files keep track of past operations or data. The \ndifference between archive and historical files usually lies in the \nfrequency of their updates.\nExample: At the end of every semester, the results are stored in a \nhistorical file, which is periodically updated. An archive file might \nstore older data that is no longer modified but kept for record-\nkeeping purposes."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 25,
    "text": "27\n2024/2025\n2ème année CP\nFile Usage Characteristics \nTypes of files based on the storage medium:\nSome file characteristics are closely related to the type of storage \nmedium, particularly the method of data access.\nExample:\nFor files stored on magnetic tape, only sequential access is possible.\nOn a magnetic disk, data access can be either sequential or direct."
  },
  {
    "file": "1) Généralités 1.pdf",
    "page": 26,
    "text": "27\n2024/2025\n2ème année CP\nFile Usage Characteristics \nTypes of files based on file organization:\nThe organization adopted for a file is one of its most important \ncharacteristics, as it defines how to access the information it contains.\nExample:\nThere are mainly three types of file organization:\nSequential organization\nIndexed organization\nRandom organization\nTree based organisation"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 1,
    "text": "Democratic and Popular Republic of Algeria\nMinistry of Higher Education and Scientific Research \nEcole supérieure en sciences et technologies de \nl’informatique et du numérique \nGeneral Information on Files \nPresented by : Dr. Daoudi Meroua \nAcademic year: 2024/2025"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 2,
    "text": "Basic File Operations \n1\n2024/2025\n2ème année CP\nFunctional Processing:\na. Creation: Creating a file involves:\n●Creating its structure, that is, defining its various fields as well as the \nlength of its records.\n●Entering the file's records and storing them on a magnetic (or \noptical) medium."
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 3,
    "text": "Basic File Operations\n2\n2024/2025\n2ème année CP\nExample:\nTo create the Students file, its structure and the size of its records are \ndefined as follows:\nThen, we enter the information related to each student and save the \nfile on the disk under the name: Students. \nField name Field length \nStudent number 6 Character \nStudent fisrt name 10 Character \nStudent last name 10 Character \nDate of birth 8 Character \nStudent address 20 Character"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 4,
    "text": "3\n2024/2025\n2ème année CP\nDeletion \nDeleting a file means canceling its storage, which involves erasing all \nthe records that make it up, as well as its structure. There are two \ntypes of deletion: logical deletion and physical deletion.\nLogical Deletion: Logical deletion consists of marking the file in such a \nway that it becomes transparent; in reality, it still exists on the storage \nmedium.\nPhysical Deletion: Physical deletion permanently removes the file. The \nspace previously occupied by the file will be reclaimed.\nBasic File Operations"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 5,
    "text": "4\n2024/2025\n2ème année CP\nUnion : Several source files give rise to a new file.\nBasic File Operations"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 6,
    "text": "5\n2024/2025\n2ème année CP\nBasic File Operations\nSplitting\nThis is the reverse operation of the union. A source file gives rise \nto several destination files."
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 7,
    "text": "6\n2024/2025\n2ème année CP\nBasic File Operations\nSorting\nThe primary operation to perform on files is undoubtedly the \nsearch operation. To optimize the time for this search (to allow the \nuser to access information as quickly as possible), it would be \nbeneficial to store the information in a well-considered order. This \norganization operation is called sorting.\nSorting a file involves arranging its records in either ascending or \ndescending order based on the value of one or more attributes \nknown as sorting keys."
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 8,
    "text": "7\n2024/2025\n2ème année CP\nMerging\nMerging involves combining the records of two or more files into a \nsingle file.\nCondition: The files to be merged must have the same structure.\nConsequence: The resulting file will have the same structure as the files \nthat contributed to its creation.\nBasic File Operations"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 9,
    "text": "9\n2024/2025\n2ème année CP\nUpdating encompasses the following three operations:\n●Creating new records\n●Deleting existing records\n●Modifying the content of a record\nBasic File Operations"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 10,
    "text": "10\n2024/2025\n2ème année CP\nService Operations\nGenerally, three processes are distinguished:\n●Copying\n●Temporary storage\n●Creating auxiliary files\nBasic File Operations"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 11,
    "text": "11\n2024/2025\n2ème année CP\nCopying\nCopying a file means duplicating its content onto a storage medium.\nTemporary Storage\nThis process involves temporarily storing the results of a processing \noperation in intermediate files for later use. Their immediate use is \ndelayed for one reason or another.\nCreating Auxiliary Files\nThe creation of auxiliary files is related to understanding the \ncharacteristics of the equipment used and the constraints of the \nsystem to effectively utilize computing resources.\nBasic File Operations"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 12,
    "text": "12\n2024/2025\n2ème année CP\nA text file consists of a set of characters organized into lines, each \ncapable of containing up to 255 characters, which end with a newline \ncharacter. It can be opened by any text editor.\nA binary file can contain all kinds of data in the form of a sequence of \nbytes, including text data. The bytes in a binary file are interpreted \nonly by dedicated software; they are read and written as-is. A binary \nfile can be structured (e.g., a database file) or unstructured.\nText File and Binary File"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 13,
    "text": "12\n2024/2025\n2ème année CP\nFile: Internal Level\n Regardless of the storage medium, a file = a set of physical blocks in a \nstorage medium \nA file = a set of physical blocks in MS"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 14,
    "text": "14\n2024/2025\n2ème année CP\nA logical file corresponds to the user's view of the storage of their \ndata. More precisely, the logical file is:\n●On one hand, a standard data type defined in programming \nlanguages, upon which a number of specific operations can be \nperformed.\n●On the other hand, a set of records or items.\nPhysical File and Logical File"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 15,
    "text": "15\n2024/2025\n2ème année CP\nA physical file corresponds to the entity allocated on permanent \nstorage and physically contains the records defined in the logical file. \nThe records that make up the logical file must be written into the \nsectors that comprise the blocks of the disk, thus forming the physical \nfile corresponding to the logical file.\nThe physical file is therefore composed of a set of physical blocks that \nmust be allocated to the file.\nPhysical File and Logical File"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 16,
    "text": "16\n2024/2025\n2ème année CP\nA logical record: The records of a logical file are referred to as logical \nrecords or items. The size of a record is measured in bytes or \ncharacters. There are two modes of dividing data into records:\n●Fixed-length records\n●Variable-length records\nExemple : \nStruct etudiant { \n char nom [20]\n char prénom [20]\n int num-inscription \n }\nPhysical Record vs. Logical Record"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 17,
    "text": "17\n2024/2025\n2ème année CP\nA physical record: The records of a physical file are referred to as \nphysical records.\nThe physical record represents the amount of information exchanged \nbetween main memory and the storage unit. A physical record or \nblock is the smallest unit of data that can be read or written in a single \noperation. The physical record contains one or more records and \npossibly some control and organizational information.\nPhysical Record vs. Logical Record"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 18,
    "text": "18\n2024/2025\n2ème année CP\n The number of logical records contained in a physical record corresponds to the \nblocking factor. Blocking a certain number of logical records into physical records \nprimarily allows for a time gain during the execution of I/O operations. .\nThe Blocking Factor"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 19,
    "text": "Memories \n19\n2024/2025\n2ème année CP\nThere are several types of storage media for manipulating and storing \nfiles, classified by:\n●Access speed\n●Cost of storing information\n●Reliability\nExamples: processor registers, cache memory, main memory, a buffer \n(between main memory and storage), secondary memory, and \narchival memory."
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 20,
    "text": "Memories\n21\n2024/2025\n2ème année CP\nMain Memory Secondary Memory \nSpeed \n Tens or hundreds of \nnanoseconds \nA few milliseconds \nCapacity Limited Large Capacity \nCost \n High \n low \nVolatility volatile Non volatile"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 21,
    "text": "HDD\n22\n2024/2025\n2ème année CP\nLes Disques Durs (HDD)\nArm"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 22,
    "text": "HDD\n23\n2024/2025\n2ème année CP\n511\nDisk Structure\n➢The disk is made up of a set of platters.\n➢Each platter consists of a set of tracks and sectors.\n➢The intersection of a track and a sector is called a block.\n➢Block Address = Sector Number + Track Number\n➢The address of a byte within the block represents its offset.\n➢Reference of a byte on the disk = Track Number + Sector \nNumber + Offset"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 23,
    "text": "HDD\n24\n2024/2025\n2ème année CP\nReading a Block from the Disk\na) You must know the address of the block on the disk.\nb) Position the read head on the correct track.\nc) Wait for the correct block to come under the read head.\nd) Transfer the block to main memory.\nTime required for b) + c) + d): 8 to 9 milliseconds\nTime for d): approximately 0.1 milliseconds\n→ It is advantageous to read several contiguous blocks in \nsuccession."
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 24,
    "text": "HDD\n25\n2024/2025\n2ème année CP\nBuffering\nBuffering involves reserving a section of main memory that can hold \nmultiple blocks at the same time (the buffer cache).\nPrefetching\nPrefetching, which consists of reading several consecutive blocks \nwhen a request is made for a specific block, is often used in \ncombination with buffering to increase the chances of finding the \nrequested blocks already present in main memory during any future \naccesses."
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 25,
    "text": "26\n2024/2025\n2ème année CP\nSSD\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nSolid State Drive SSD\nVolatile memory \nController"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 26,
    "text": "27\n2024/2025\n2ème année CP\nSSD\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nThe memory of the SSD is divided into groups (or blocks of pages, \nwith a fixed capacity, e.g., 256KB), and each group is composed of a \ncertain number of pages (e.g., page size = 4KB).\n .\nThere are 3 possible operations:\nRead a page: very fast (20 microseconds)\nWrite a page, provided it is in an erased state: fast (100 to 200 \nmicroseconds)\nErase all pages of a block: slow (a few milliseconds)"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 27,
    "text": "28\n2024/2025\n2ème année CP\nMC/MS\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nRegardless of the type of disk (HDD or SSD), the interface remains the same:\nThe unit of transfer = a physical block (1+ sectors for HDD or 1 page for SSD)"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 28,
    "text": "29\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nAbstract Machine\nWhen declaring a file, the type of blocks, buffers, and the characteristics to \nbe used (header) will be defined. \nEx :\nTypeBloc = struct\n tab : tableau[b] of TypeEnreg\n NB : entier\nFin\nF : FICHIER of TypeBloc BUFFER buf1, buf2 ENTETE ( entier )"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 29,
    "text": "30\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nF : FICHIER of TypeBloc BUFFER buf1, buf2 ENTETE ( entier )\nIn this declaration, it is stated that:\n➢F is a file composed of blocks with the structure TypeBloc.\n➢buf1 and buf2 are two variables (in main memory) of type TypeBloc \n(they will be used as buffers to access the blocks of F).\n➢The characteristics of F are summarized in a single integer (for \nexample, it can be used to store the number of blocks in F).\n➢Buffer variables can also be declared independently of F (in separate \ndeclarations).\nbuf3 : TypeBloc ;\nAbstract Machine"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 30,
    "text": "31\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nThe operations of the model are:\nOUVRIR( F , nomfichier , mode ) \nOpen or Create a File\nmode = 'A' means open an existing file for reading/writing. The \ncharacteristics will be read into main memory upon opening.\nmode = 'N' means create a new file for reading/writing. The \ncharacteristics will be allocated in main memory during creation.\nFERMER( F ) Close the file. The characteristics will be saved in \nsecondary memory. \nAbstract Machine"
  },
  {
    "file": "2) Généralités 2.pdf",
    "page": 31,
    "text": "30\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nLireDir( F , i , buf ) Read block number i of F into the variable buf. \nEcrireDir( F , i , buf ) Write buf into block number i of F. \nENTETE( F , i ) Return the value of characteristic number i. \nAFF_ENTETE( F , i , v ) Assign v to characteristic number i.\nALLOC_BLOC( F ) Return the number of a new block allocated to F. \nAbstract Machine"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 1,
    "text": "Democratic and Popular Republic of Algeria\nMinistry of Higher Education and Scientific Research \nEcole supérieure en sciences et technologies de \nl’informatique et du numérique \nSequential structures : Part 1 \nPresented by : Dr. Daoudi Meroua \nAcademic year: 2024/2025"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 2,
    "text": "2\n2024/2025\n2ème année CP\nFile structures \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nFile structures are the combination of:\n➢The organization of data within files\n➢The methods of file access\nThe goal is to define and design data structures and associated algorithms to \norganize the blocks of a file on storage media (SM) and to implement certain \naccess operations for data manipulation within the file."
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 3,
    "text": "3\n2024/2025\n2ème année CP\nFile modeling \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 4,
    "text": "4\n2024/2025\n2ème année CP\nPerformance of file structures \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n• Number of physical Input/Output operations performed: the algorithmic \ncomplexity is directly related to the number of Input/Output operations.\n• Another performance criterion concerns memory space usage:\n• Memory overhead: Size of the data structures used / Size of the data stored ⇒\n≥ 100% (the smaller the ratio, the more efficient it is)\n• Loading factor: Number of data inserted / Number of available slots In ]0%, ⇒\n100%] (the larger the ratio, the better)"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 5,
    "text": "5\n2024/2025\n2ème année CP\nOrganization methods \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nThe organization of files refers to how data is stored within a file. File \norganization is crucial as it determines access methods, efficiency, flexibility, \nand the types of storage devices to be used. There are four methods of file \norganization on a storage medium, which include:\n➔ Sequential organization\n➔ Indexed organization\n➔ Hierarchical organization (tree methods)\n➔ Random organization (hashing methods)"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 6,
    "text": "6\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nGlobal organization of blocks \nTwo types of block \norganization \nContiguous \norganization \nLinked \norganization \nThe file is viewed \nas an array of \nblocks. \nThe file is \nviewed as a \nlinked list of \nblocks."
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 7,
    "text": "7\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nGlobal organization of blocks \nIn the figure below, we have two files viewed as arrays (E and F) and one file \nviewed as a list (G). The blocks F1, F2, … F7 are contiguous, as are the blocks \nE1, E2, E3, and E4. However, the blocks G1, G2, … G6 are not contiguous; they \nare linked together, forming a list of blocks"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 8,
    "text": "8\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nInternal organization of blocks \nA block contains records. \nFixed length Variable length"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 9,
    "text": "9\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nInternal organization of blocks \nFixed-length records \nEach block can then contain an array of records of the same type \nType Tbloc = structure // Structure of a file \nblock\ntab : tableau[1..b] de Tenreg; \nNB : entier;\nfin;\nType Tenreg = structure // Structure of a \nfile record \nmatricule : chaine(10);\nnom : chaine(20);\nage : entier;\n...\nfin;"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 10,
    "text": "10\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nInternal organization of blocks \nVariable-length records \nEach record is viewed as a string of characters (of variable length). \n➔It has one or more fields with variable sizes, \n➔the number of fields varies from one record to another.\nTo separate the fields within the record, we can either use a special \ncharacter ('#') that cannot be used as a valid value or prefix the beginning \nof the fields with their size (over a fixed number of positions)."
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 11,
    "text": "11\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nInternal organization of blocks \nVariable-length records \n In the example below, we use 3 positions to indicate the size of the fields \n...|0|2|7|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|0|1|7|b|b|b|b|b|b|b|b|b|b|b|b|b|b|0|\n3|7|c|c|c|.......|c|c|.....\n<-------------------------------------------------> <--------------------------------> <---------------->\nA field with 27 characters and a field with 17 characters... In the case of \nvariable-length records, the block cannot be defined as an array of records, \nbecause the elements of an array must always be of the same size."
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 12,
    "text": "12\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nInternal organization of blocks \nVariable-length records \nType Tbloc = structure\n tab : tableau[1..b'] de caractères; // Character array for records \n suiv : entier; // Number of the next block in the list \nFin;\nNote: Even though the records are of variable lengths, the size of the \nblocks remains fixed."
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 13,
    "text": "13\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nInternal organization of blocks \nOverlapping \nTo minimize wasted space in blocks (in the case of variable format only), one \ncan opt for an organization with overlapping between two or more blocks: \nwhen inserting a new record into a block that is not yet full and where the \nremaining empty space is not sufficient to fully contain that record, it will be \nsplit into two parts. The first part will occupy all the empty space of the block \nin question, while the remaining part (the second part) will be inserted into a \nnewly allocated block for the file. This is referred to as the record being 'split \nacross two blocks."
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 14,
    "text": "14\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nSimple file structures \nTaxonomy of simple file structures \nNotation:\nT : For a file viewed as an array (tableau), use L: for a file viewed as a list \nO: for ordered file, Ō: for unordered file. \nF: for fixed record format, V: for variable record format. \nC: with overlapping records between blocks, :Ć without overlapping. ( C \nchevauchement)"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 15,
    "text": "15\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nSimple file structures \nTaxonomy of simple file structures"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 16,
    "text": "16\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nSimple file structures \nExamples :\n T O VC method :\n• Represents the organization of a file viewed as an array (T), unordered (O), with variable-length \nrecords (V) and allowing overlaps between blocks (C). \n• The search is sequential, insertion occurs at the end of the file, and deletion is logical. \nLOF method:\n• File viewed as a list, ordered with fixed-length records. \n• The search is sequential,\n• The insertion causes intra-block shifts (to maintain the order of the records), and deletion can be \neither logical or physical."
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 17,
    "text": "17\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n TŌF Example : Initial loading \nTypeBloc = struct \n tab : tableau[b] de TypeEnreg\n NB : entier\nFin\nF : FICHIER de TypeBloc BUFFER buf ENTETE ( entier , entier ) /* nb_bloc , \nnb_enreg */\ne : TypeEnreg ;\ni, j, k, n : entier ;\nDebut\nOUVRIR ( F , « fichier.dat », ’N’ ) // un nouveau fichier\nLire(n) ; i ← 1 ; j ← 1 // le remplir avec n enreg"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 18,
    "text": "18\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n TŌF Example : Initial loading \nPour k = 1,n\nLire(e) // récupérer un enreg de l’entrée standard\nSI ( j ≤ b*0.7 )\n buf.tab[ j ] ← e ; j++ // et le mettre dans le buffer buf\nSINON // s’il n’y a pas de place dans buf,\n buf.NB ← j-1 ;\n ECRIREDIR( F , i , buf ) ; // le sauvegarder en MS et\n buf.tab[1] ← e ;\n i++ ; \n j ← 2 // remplir un nouveau\nFSI\nFP\nbuf.NB ← j-1\nECRIREDIR( F , i , buf) // écriture du dernier bloc\nAFF_ENTETE( F , 1 , i ) ; AFF_ENTETE( F , 2 , n ) ; // m-a-j les caractéristiques\nFERMER( F ) // et fermer le fichier\nFin"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 19,
    "text": "19\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTo modify the content of a block, you need to: \n1- Load the content of the block into memory (in a buffer). ⇒ LireDir( F , i , \nbuf )\n TŌF Example : Initial loading"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 20,
    "text": "20\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n2- Make the modifications in the buffer (in MC) ⇒ buf.tab[ ] ← … ; buf.NB ← \n...\n TŌF Example : Initial loading"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 21,
    "text": "21\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n3- Write the modified content of the buffer back into the block in MS ⇒\nEcrireDir( F , i , buf )\n TŌF Example : Initial loading"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 22,
    "text": "22\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n TŌF Example : Initial loading \n ⇒ Insert the record e4 into block number i of F. \nOUVRIR( F , « ... » , ‘A’ )\n…\nLIREDIR( F , i , buf ) // 1. Read the content of block i into memory. \nSI ( buf.NB < Capacité_max )\n buf.NB++ //2. Update the buffer in MC \n buf.tab[ buf.NB ] ← e4 // the field NB and the array tab \nECRIREDIR( F , i , buf ) //3. Write the content of the buffer into block i in MS\nSINON\n écrire(« Cannot insert into block i : it is already full »)\nFSI\n...\nFERMER( F )"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 23,
    "text": "23\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nPhysical deletion of a record by overwriting it with the last one (Using 2 \nbuffers, buf1 and buf2 in MC).\nTo physically delete the record with key c, you need to:\nLocate the number (i) of the block containing the record c for example, by ⇒\nsearching for c.\n TŌF Example : Physical deletion"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 24,
    "text": "24\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nRetrieve the number (N) of the last block in file F N ← Entete(F,1)⇒\nRead blocks i and N into MC lireDir(F, i, buf1); EcrireDir(F, N, buf2)⇒\n TŌF Example : Physical deletion"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 25,
    "text": "25\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nOverwrite c with c' in memory by moving c' from buf2 to buf1. ⇒\n TŌF Example : Physical deletion"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 26,
    "text": "26\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nWrite the contents of buf1 and buf2 to MC EcrireDir(F, i, buf1); EcrireDir(F, ⇒\nN, buf2). \n TŌF Example : Physical deletion"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 27,
    "text": "27\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n TŌF Example : Physical deletion \nCost in the worst case"
  },
  {
    "file": "3) Sequentiel structure1.pdf",
    "page": 28,
    "text": "28\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nCost in the best case \n ( i == N and block N contains only one record.)\n- Read block i (or N) into MC ⇒ LireDir( F , N , buf1) ;\n- SI (buf1.NB == 1) Aff_Entete( F , 1 , Entete( F , 1 ) - 1 ) SINON …. FSI\nCost= 1 Physical read \n TŌF Example : Physical deletion"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 1,
    "text": "Democratic and Popular Republic of Algeria\nMinistry of Higher Education and Scientific Research \nEcole supérieure en sciences et technologies de \nl’informatique et du numérique \nSequential structures : Part 2 \nPresented by : Dr. Daoudi Meroua \nAcademic year: 2024/2025"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 2,
    "text": "2\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nSequential structures \nThe TOF Method:\nIt represents the organization of a file viewed as a table (T), ordered (O), with \nfixed-size records (F).\nThe search for a record is performed using binary search (fast).\nInsertion may cause intra- and inter-block shifts (costly).\nDeletion can be done through reverse shifts (physically costly) or simply by using a \nboolean indicator (logical deletion, much faster).\nThe initial load operation consists of constructing an ordered file with n initial \nrecords, leaving some empty space in each block. This helps minimize the shifts \nthat future insertions might cause.\nPeriodic reorganization is recommended"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 3,
    "text": "3\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTOF : Search Module \nFile Declaration: \nConst b = 30; // Maximum Block Capacity (in number of records) \ntype\nTenreg = structure /\n efface : booleen; // Boolean for Logical Deletion \n cle : typeqlq; // Field Used as Search Key \n champ2 : typeqlq; \n champ3 : typeqlq; \n ...\nFin;\nTbloc = structure \n tab : tableau[1..b] de Tenreg; \n NB : entier; // nombre d'enreg dans tab ( <= b)\nFin;\nVar F : Fichier de Tbloc Buffer buf Entete (entier, entier);"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 4,
    "text": "4\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTOF : Search Module \nInput: The key (c) to search for and the external file name (nomfich).\nOutput: The boolean Trouv, the block number (i) containing the key, and the \ndisplacement (j). \nRech( c:typeqlq; nomfich:chaine; var Trouv:bool; var i,j:entier )\nvar\nbi, bs, inf, sup : entier;\ntrouv, stop : booleen; \nDEBUT\nOuvrir( F, nomfich, 'A' );\nbs ← entete( F,1 ); // la borne sup (le num du dernier bloc de F)\nbi ← 1; // la borne inf (le num du premier bloc de F)\nTrouv ← faux; stop ← faux; j ← 1;"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 5,
    "text": "5\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTQ ( bi ≤ bs et Non Trouv et Non stop ) // External Search \n i ← (bi + bs) div 2; // le bloc du milieu entre bi et bs\n LireDir( F, i, buf );\n SI ( c ≥ buf.tab[1].cle et c ≤ buf.tab[buf.NB].cle )\n // Binary Search Within the Block (in the variable buf) \n inf ← 1; sup ← buf.NB;\n TQ (inf ≤ sup et Non Trouv) // Internal Search \n j ← (inf + sup) div 2;\n SI (c = buf.tab[j].cle) \n Trouv ← vrai\n SINON\n SI (c < buf.tab[j].cle)\n sup ← j-1\n SINON \n inf ← j+1\n FSI\n FSI\nFTQ\nTOF : Search Module"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 6,
    "text": "6\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nSI ( inf > sup )\n j ← inf FSI // fin de la recherche interne. // j : The Position Where c Should Be \nLocated in buf.tab \n stop ← vrai\nSINON // non ( c ≥ buf.tab[1].cle et c ≤ buf.tab[buf.NB].cle )\n SI ( c < buf.tab[1].cle )\n bs ← i-1\n SINON // donc c > buf.tab[buf.NB].cle\n bi ← i+1\nFSI\nFSI\nFTQ\nSI ( bi > bs ) \ni ← bi ; j ← 1\nFSI // \nEnd of External Search\n// i : Block Number Where c Should Be Located \nfermer( F )\nFIN\nTOF : Search Module"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 7,
    "text": "7\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nInserer( e:Tenreg; nomfich:chaine )\nvar\ntrouv : booleen;\ni,j,k : entier;\ne,x : Tenreg;\nDEBUT\n// We start by searching for the key e.cle using the previous module to locate the \nposition (i,j) where e should be inserted in the file. \nRech( e.cle, nomfich, trouv, i, j );\nSI ( Non trouv ) // e must be inserted in block i at position j. \n Ouvrir( F,nomfich, 'A'); // en décalant les enreg j, j+1, j+2, ... vers le bas\n continu ← vrai;\nTOF : insertion Module"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 8,
    "text": "8\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTQ ( continu et i ≤ entete(F,1) )\n LireDir( F, i, buf ); \n// Before making the shifts, save the last record in a variable x...\n x ← buf.tab[buf.NB];\n// Shift within buf...\n k ← buf.NB;\n TQ k > j\n buf.tab[k] ← buf.tab[k-1];\n k ← k-1\n FTQ\n// Insert e at position j in buf... \nbuf.tab[j] ← e;\nTOF : insertion Module"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 9,
    "text": "9\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nIf buf is not full, place x at position NB+1 and stop... \nSI ( buf.NB < b )\n buf.NB ← buf.NB+1;\n buf.tab[buf.NB] ← x;\n EcrireDir( F, i, buf );\n continu ← faux;\nSINON // If buf is full, x must be inserted in block i+1 at position 1...\n EcrireDir( F, i, buf );\n i ← i+1;\n j ← 1;\n e ← x; // This will be done in the next iteration. (the insertion of e)\n FSI // not ( buf.NB < b )\nFTQ\nTOF : insertion Module"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 10,
    "text": "10\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n// If we exceed the end of the file, we add a new block containing a single record \ne. \nSI i > entete( F, 1 )\n buf.tab[1] ← e;\n buf.NB ← 1;\n EcrireDir( F, i, buf ); // It is enough to write a new block at this location. \n Aff-entete( F, 1, i ); // We save the number of the last block in header 1. \nFSI\nAff-entete( F, 2 , entete(F,2)+1 ); // We increment the insertion counter. \nFermer( F );\nFSI\nFIN\nTOF : insertion Module"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 11,
    "text": "11\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTOF : deletion Module \nSuppression( c:typeqlq; nomfich:chaine )\nvar\ntrouv : booleen;\ni,j : entier;\nDEBUT\n// We start by searching for the key c to locate the position (i,j) of the record to be \ndeleted.\nRech( c, nomfich, trouv, i, j );\n// Then we logically delete the record \nSI ( trouv )\n Ouvrir( F,nomfich, 'A’);\n LireDir( F, i, buf ); \n buf.tab[j].efface ← VRAI;\n EcrireDir( F, i, buf );\n Fermer( F )\nFSI\nFIN"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 12,
    "text": "12\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nMerge of Two TOF \nFusion (nom1,nom2, nom3: chaine)\nvar\nF1 : Fichier de Tbloc Buffer buf1 Entete( entier, entier);\nF2 : Fichier de Tbloc Buffer buf2 Entete( entier, entier);\nF3 : Fichier de Tbloc Buffer buf3 Entete( entier, entier);\ni1, i2, i3 : entier;\nj1, j2, j3 : entier;\ncontinu : booleen;\ne, e1, e2 : Tenreg;\nbuf : Tbloc;\ni, j, indic : entier;"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 13,
    "text": "13\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nDebut\nouvrir(F1, nom1, 'A' );\nouvrir(F2, nom2, 'A' );\nouvrir(F3, nom3, 'N' );\ni1←1; i2←1; i3 ←1; // The block numbers of F1, F2, and F3. \nj1←1; j2←1; j3 ←1; // The record numbers in buf1, buf2, and buf3.\nLireDir(F1, 1, buf1) ;\nLireDir(F2, 1, buf2) ;\ncontinu ← vrai ;\nMerge of Two TOF"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 14,
    "text": "14\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTQ ( continu ) // While not end of file in F1 and F2 do... \nSI ( j1 ≤ buf1.NB et j2 ≤ buf2.NB ) // Choose the smallest record from buf1 and buf2.\n e1←buf1.tab[j1];\n e2 ← buf2.tab[j2] ;\nSI ( e1.cle ≤ e2.cle )\n e ← e1; j1← j1 + 1;\nSINON\n e ← e2; j2← j2 + 1;\nFSI // and place it in buf3. \nSI ( j3 ≤ b )\n buf3.tab[j3] ← e; j3 ← j3 + 1\nSINON\n buf3.NB ← j3 – 1;\n EcrireDir(F3, i3, buf3 );\n i3 ← i3 + 1;\n buf3.tab[1] ← e;\n J3 ← 2;\nFSI\nMerge of Two TOF"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 15,
    "text": "15\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nMerge of Two TOF \nSINON // not ( j1 ≤ buf1.NB et j2 ≤ buf2.NB )\n // If all the records of one of the blocks (buf1 or buf2) have been processed, move \non to the next one. \nSI ( j1 > buf1.NB )\nSI ( i1 < entete(F1, 1) )\n i1 ← i1 + 1;\n LireDir( F1, i1, buf1 ) ;\n j1 ← 1\nSINON // ( so i1 ≥ entete(F1, 1) )\n continu ← faux ;\n i ← i2; //For the continuation of the TQ.\n j ← j2;\n N ← entete(F2,1) ;\n buf ← buf2 ;\n Indic ← 2\nFSI // ( i1 < entete(F1, 1) )"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 16,
    "text": "16\n2024/2022\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nMerge of Two TOF \nSINON // ( j2 > buf2.NB )\nSI ( i2 < entete(F2, 1) )\n i2 ← i2 + 1;\n LireDir( F2, i2, buf2 );\n j2 ← 1\nSINON // ( i2 ≥ entete(F2, 1) )\n continu ← faux;\n i ← i1; // For the continuation of the TQ.\n j ← j1;\n N ← entete(F1,1);\n buf ← buf1;\n Indic ← 1;\nFSI // ( i2 < entete(F2, 1) )\nFSI // ( j1 > buf1.NB )\nFSI // ( j1 ≤ buf1.NB et j2 ≤ buf2.NB )\nFTQ"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 17,
    "text": "17\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nMerge of Two TOF \n// continue to copy the records of a single file(i,j,buf) in F3\ncontinu ← vrai;\nTQ ( continu ) // while not end of file F1 or F2 do\n SI ( j ≤ buf.NB )\n SI ( j3 ≤ b )\n buf3.tab[j3] ← buf.tab[j]; j3 ← j3 + 1\n SINON\n buf3.NB ← j3 – 1;\n EcrireDir(F3, i3, buf3 );\n i3 ← i3 + 1;\n buf3.tab[1] ← buf.tab[j];\n J3 ← 2;\n FSI ; // ( j3 ≤ b )\n j ← j + 1"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 18,
    "text": "18\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nMerge of Two TOF \nSINON // not ( j ≤ buf.NB )\nSI ( i ≤ N )\n i ← i + 1;\n SI ( Indic = 1 )\n LireDir( F1, i, buf )\n SINON\n LireDir( F2, i, buf )\n FSI ;\n j ← 1\nSINON\n continu ← faux\nFSI\nFSI // ( j ≤ buf.NB )\nFTQ ;"
  },
  {
    "file": "4) Sequetiel structure 2.pdf",
    "page": 19,
    "text": "19\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nMerge of Two TOF \n// The last buffer (buf3) has not yet been written to disk...\nbuf3.NB ← j3 – 1 ;\nEcrireDir( F3 , i3, buf3 ) ;\nAff-entete( F3, 1, i3) ; // blocks number of F3\nAff-entete( F3, 2, entete(F1,1) + entete(F2,1) ) ; // records number of \nF3\nFermer( F1 ) ;\nFermer( F2 ) ;\nFermer( F3 ) ;\nFin"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 1,
    "text": "Democratic and Popular Republic of Algeria\nMinistry of Higher Education and Scientific Research \nEcole supérieure en sciences et technologies de \nl’informatique et du numérique \nIndexed sequential structures \nPresented by : Dr. Daoudi Meroua \nAcademic year: 2024/2025"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 2,
    "text": "2\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nFiles with Indexes \n➔Searching for a record in a sequential file structure is generally \ncostly\n → sequential search \n→ binary search in a (very) large file\n➔Indexing is a data structure technique that allows efficient \nretrieval of file records based on certain attributes on which the \nindexing has been performed."
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 3,
    "text": "3\n2024/2025\n2ème année CP\nFiles with Indexes \nThe attribute (or group of attributes) used to search for records is called a \"search \nkey.\"\nFor example, in a meteorological measurements file:\nFile of meteorological measurements\n< city, date, temperature >\nSearch examples:\n→ Find the record(s) where city = 'DJELFA'\nResult:\n‘DJELFA’, ‘2015-06-23’, 21\n‘DJELFA’, ‘2013-10-04’, 15\n‘DJELFA’, ‘2015-06-22’, 20\n‘DJELFA’, ‘2020-07-16’, 29\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 4,
    "text": "4\n2024/2025\n2ème année CP\nFiles with Indexes \nAn index is an ordered table in main memory (MC), containing, \namong other things, pairs: < key, address > \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n Key adr\n Data file"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 5,
    "text": "5\n2024/2025\n2ème année CP\nFiles with Indexes \nExample: Search for the record with the attribute value A1 = 54\n→ Perform a binary search for 54 in the index table in main memory (MC): \nresult adr = <4,2>\n→ LireDir(F, 4, buf) and retrieve the record buf.tab[2] \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 6,
    "text": "6\n2024/2025\n2ème année CP\nFiles with Indexes \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nIndex table (MC) Data file (MS) Index file (MS)"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 7,
    "text": "7\n2024/2025\n2ème année CP\nFiles with Indexes \nThe key can have unique values or not (multiple values).\nExample of an index on a key attribute with multiple values\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nKey adr"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 8,
    "text": "8\n2024/2025\n2ème année CP\nFiles with Indexes \nDifferent representations of index tables with multiple values: \n1) One entry per key value. \n2) Multiple entries per key value. \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n Key adr\n Key adr \n Key adr\n Key adr"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 9,
    "text": "9\n2024/2025\n2ème année CP\nFiles with Indexes \nThe data file can be ordered by the \nkey or not.\nIf the data file is ordered (by the \nkey attribute)\n ⇒ Non-dense index (Clustered \nIndex) does not contain all the \nvalues of the key attribute.\nIn this example, each entry in the \nindex table contains the largest key \nof a group of two consecutive \nblocks.\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 10,
    "text": "10\n2024/2025\n2ème année CP\nFiles with Indexes \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nThe data file can be ordered \nby the key or not.\n2) If the data file is not \nordered (by the key \nattribute)\n ⇒ Dense index (Non-\nClustered Index)\ncontains all the values of \nthe key attribute."
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 11,
    "text": "11\n2024/2025\n2ème année CP\nFiles with Indexes : basic operations \nRecord Search\nSearch in the index in main memory (MC), then access the data file.\n●Exact query (key = value) → binary search for the exact value.\n●Interval query (key [a, b]) → binary search for ‘a’ + sequential search ∈\nfor the following values up to ‘b’.\nInsertion / Deletion of Records\nInsertions/deletions of records in the data file and, if necessary, update the \nindex in MC.\nCase of Ordered File:\nMore efficient interval query.\nDeletion is more costly.\n \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 12,
    "text": "12\n2024/2025\n2ème année CP\nFiles with Indexes : : basic operations \nExample: Insertion in T~OF with a dense index and unique key values. \nType Tbloc = Struct\n tab : tableau[ b ] de typeEnreg\n NB : entier \nFin\nVar F : FICHIER de Tbloc BUFFER buf ENTETE ( entier )\nIndex : tableau [ MaxIndex ] de Tcouple\nNbE : entier // number of elements in the index table (== number of records in \nthe file F) \nIns( e:TypeEnreg )\nRech( e.cle , trouv , k ) // Search (binary) in the index table \nSI ( Non trouv )\n // Insertion at the end of the data file ... \n OUVRIR( F, « donnees.dat » , ‘A’ )\n i ← Entete( F , 1 ) \n LireDir( F , i , buf )\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTcouple = Struct\n cle : typeqlq ; \n numBlc , depl : entier\n Fin"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 13,
    "text": "13\n2024/2025\n2ème année CP\nFiles with Indexes \n SI ( buf.NB < b ) buf.NB++ ; j ← buf.NB ; buf.tab[ j ] ← e\n EcrireDir( F , i , buf )\n SINON\n i++ ; j ← 1 ; \n buf.NB ← 1 ; \n buf.tab[ j ] ← e\n Aff_entete( F, 1, i ) ; EcrireDir( F , i , buf )\n FSI\n FERMER( F )\n // Insertion in the index table ... \n NbE++ ; m ← NbE\n TQ ( m > k ) \n Index[ m ] ← Index[ m-1 ] ; \n m– \n FTQ\n Index[ k ] ← < e.c , i , j > // clé, numBlc, depl\n FSI\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 14,
    "text": "14\n2024/2025\n2ème année CP\nFiles with Indexes \nSame example but with non-unique key values. \nType Tcouple = Struct \n cle : typeqlq ; \n tete : ptr(maillon) \nFin\nVar Index : tableau [ MaxIndex ] de Tcouple\nIns( e:TypeEnreg )\n// Insertion at the end of the data file ... \nOUVRIR( F, « donnees.dat » , ‘A’ )\ni ← Entete( F , 1 ) \nLireDir( F , i , buf )\nSI ( buf.NB < b ) buf.NB++ ; j ← buf.NB ; buf.tab[ j ] ← e\nEcrireDir( F , i , buf )\nSINON\ni++ ; j ← 1 ; buf.NB ← 1 ; buf.tab[ j ] ← e\nAff_entete( F, 1, i ) ; EcrireDir( F , i , buf )\nFSI\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nmaillon = struct\n val : struct (numblc , depl : \nentier) ;\n adr : ptr(maillon)\n Fin"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 15,
    "text": "15\n2024/2025\n2ème année CP\nFiles with Indexes \nFERMER( F )\n// Insertion in the index table ... \nRech( e.cle , trouv , k )\nSI ( trouv ) // Add a link <i, j> to the list index[k].head \n Allouer( p ) ; \n Affval( p , < i , j > ) ; \n Affadr( p , Index[ k ].tete ) ;\n Index[ k ].tete = p\nSINON // Insert a new entry <key, <i, j>> in the index at position k. \n NbE++ ;\n m ← NbE ; \n Allouer(p) ;\n Affval(p, < i , j >) ;\n Affadr(p,nil)\nTQ ( m > k ) Index[ m ] ← Index[ m-1 ] ; m-- FTQ\nIndex[ k ] ← < e.c , p > // key = e.c, head = p \nFSI\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 16,
    "text": "16\n2024/2025\n2ème année CP\nFiles with Indexes \nManagement of an Overflow Area\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nNon-Dense Index Table \nPrimary Area Data File \nOverflow Area Data File"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 17,
    "text": "17\n2020/2021\n2ème année CP\nFiles with Indexes \nExample: Index for LOF File\n(no inter-block offsets and no overflow area)\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 18,
    "text": "18\n2020/2021\n2ème année CP\nFiles with Indexes \nExemple :LOF File / Insertion\nThe insertion of c5 causes \nthe overflow of block i:\nAdd a new block → i’\nSplit the content of i into two \nhalves\nUpdate the index by \ninserting a new entry for \nblock i’\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 19,
    "text": "19\n2020/2021\n2ème année CP\nFiles with Indexes \nIndex in Main Memory in the form of BST\nType Tnoeud = struct\n cle : typeqlq\n numBlc , depl : entier\n fg , fd : ptr(Tnoeud)\nFin\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 20,
    "text": "20\n2024/2025\n2ème année CP\nFiles with Indexes : Large Index\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nIndex in central \nmemory in the \nform of an \nordered file with \ncontiguous \nblocks \nfile in main \nmemory (MC)"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 21,
    "text": "21\n2020/2021\n2ème année CP\nFiles with Indexes : Large Index\nIndex \nMultiniveaux\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 22,
    "text": "22\n2020/2021\n2ème année CP\nFiles with Indexes : Multi-Key Query\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 23,
    "text": "23\n2024/2025\n2ème année CP\nFiles with Indexes : Multi-Key Query\n \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 24,
    "text": "24\n2024/2025\n2ème année CP\nFiles with Indexes : Multi-Key Query\nFind all records where the value of X = vx AND the value of Y = vy AND \n…” with X, Y, ... as ‘secondary keys’ (For each secondary key, there is a \ncorresponding secondary index):\n●Using the secondary index X, find the list Lx of primary keys associated \nwith the value vx.\n●(Repeat the same action for each secondary key mentioned in the \nquery…)\n●Perform the intersection of the primary key lists Lx, Ly, ... to find the \nprimary keys associated with each secondary key value mentioned in \nthe query.\n●Use the primary index to retrieve the records from the data file (by first \nsorting the sequence of block numbers before performing the physical \ntransfers).\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 25,
    "text": "25\n2024/2024\n2ème année CP\nFiles with Indexes : Multi-Key Query\nIf we are searching for all records \nwhere A2 = ‘eee’ and A3 = 870, the \nmulti-key query algorithm will \nproceed as follows:\na. Search for ‘eee’ in the index \nIndA2 → result: LA2 = [32, 65, 70]\nb. Search for 870 in the index IndA3 \n→ result: LA3 = [32]\nc. Intersection of LA2 and LA3 → \nresult: Final L: [32]\nd. Search for 32 in IndA1 → result: \nblock number <2>\ne. ReadDir(F, 2, buf) and retrieve \nthe record “<32, bbb, 870, …>”\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 26,
    "text": "26\n2024/2025\n2ème année CP\nFiles with Indexes : Multi-Key Query\nInsertion of a record < c, vx, vy, ... >\n●Search for c in the primary index → ip: the index where this key should be \ninserted (binary search).\n●Insert the record into the data file → adr: the address where the record has \nbeen inserted.\n●Insert in the primary index, at position ip, the entry < c, adr > if it is a dense \nindex, or update the entry at index ip if it is a non-dense index.\n●Search for the value vx in the secondary index X.\n●If vx exists, add c to the list pointed to by vx.\n●If vx does not exist, insert vx in the secondary index X.\n●→ In this case, the new entry vx will point to a list formed by a single primary \nkey (c).\n●Repeat step 4) for each remaining secondary key (vy, ...).\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 27,
    "text": "27\n2024/2025\n2ème année CP\nFiles with Indexes : Multi-Key Query\nDeletion of a record < c, vx, vy, ... >\n●To logically delete a record with primary key c, it is sufficient to set a \ndeletion bit (or character) in the data file or in the primary index table for \nthe entry c.\n●To physically delete a record with primary key c, you must first physically \nremove the record from the data file, and then update the primary index \ntable either by deleting the entry related to c (in the case of a dense \nindex) or by modifying the key and/or address of the representative of the \ngroup to which the deleted record belongs (in the case of a non-dense \nindex).\nIn both types of deletion (logical or physical), it is not necessary to update \nthe secondary indexes.\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 28,
    "text": "28\n2024/2025\n2ème année CP\nFiles with Indexes : Index Bitmap \nIndex Bitmap\nA bitmap index on an attribute A (formed by m different values: v1, v2, … vm) \nconsists of m binary strings, each with N bits (IndA_v1, IndA_v2, ... \nIndA_vm):\nEach string IndA_vj is associated with the value vj of attribute A.\n●If (IndA_vj[k] = 1), then in record number k, attribute A equals vj.\n●If (IndA_vj[k] = 0), then in record number k, attribute A is different from vj.\nExamples:\nA = v2 in record number 2 and record number i of the data file.\nA = v1 in records number 1, 5, 6, 8, … N-2 and N-1.\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nRecord number\nThe bit string associated with v1 \nThe bit string associated with v2\nThe bit string associated with vm"
  },
  {
    "file": "5) indexed structures.pdf",
    "page": 29,
    "text": "28\n2024/2025\n2ème année CP\nBitmap indexes can be useful for attributes with low cardinality (e.g., < 20 \ndistinct values).\nThe different bit strings can be loaded into main memory (MC) independently \nof each other.\nThey are primarily used for multi-key queries on attributes with low cardinality.\nExample: “Find records where A = v2 and B = w4. \nFiles with Indexes : Index Bitmap \nThe result of the query is given by the binary operation: (IndA_v2 AND \nIndB_w4)\n→ Records number 7 and number i. \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nCardinality of A = 3\nCardinality of w = 4"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 1,
    "text": "Democratic and Popular Republic of Algeria\nMinistry of Higher Education and Scientific Research\nEcole supérieure en sciences et technologies de \nl’informatique et du numérique \nm-ary trees \nPresented by : Dr. Daoudi Meroua \nAcademic year: 2024/2025"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 2,
    "text": "2\n2024/2025\n2ème année CP\nm-ary trees \nDefinitions\nAn m-ary search tree of order NNN is a tree where each node \ncan contain at most:\nN−1 ordered values (val1,val2,…,valN−1)\nN children (Child1,Child2,…,ChildN)\nFor a given node:\nThe degree represents the current number of children.\nThe number of current values is always equal to degree−1 \nMinimum degree: 2, and maximum degree: N.\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 3,
    "text": "3\n2024/2025\n2ème année CP\nm-ary trees \nProperties\na) All values in the subtree Child1 are <val1\nb) All values in the subtree Childj are >valj−1 and <valj (for \nj [2,degree−1])∈\nc) All values in the subtree Childdegree are >valdegree−1\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 4,
    "text": "4\n2024/2025\n2ème année CP\nm-ary trees \nExample of a 5-ary Search Tree\nThe root node: i\nThe internal nodes: i, a, h, \nd, e, n\nThe leaf nodes: b, g, c, k, j, \nf, m\nThe depth (or height) of the \ntree = 4 (the level of the \nfarthest leaf)\ndegree(a) = 5, degree(b) = \n5, degree(c) = 3, degree(d) \n= 5, degree(e) = 5, \ndegree(f) = 3, degree(g) = \n3, … etc \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTop-Down Property: All internal nodes are fully filled at 100% \n(optionally verified)"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 5,
    "text": "5\n2024/2025\n2ème année CP\nm-ary trees \nTbloc = structure\n Val : tableau[N-1] de typeqlq; // enregistrements \n ou (cles-adr)\nFils : tableau[N] d'entier; // numeros de blocs\ndegre : entier; // nb d'elt dans le tableau Fils\nFin;\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 6,
    "text": "6\n2024/2025\n2ème année CP\nUses of m-ary trees \n1- As an index in MS to a data file\nType Tval = struct (key, address) \n2- As a data file organized in a tree\nType Tval = Tenreg \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 7,
    "text": "7\n2024/2025\n2ème année CP\nSearch Mechanism\nThe search for a value C starts at \nthe root node P and continues \nalong a branch:\n●If C exists in P, then the search \nends successfully.\n●If C does not exist in P, then:\n• Let k be the position in P \nwhere C should be located (to \nmaintain the values in order).\n• If Filsk is different from -1 (nil), \nthen P ← Filsk; go to step 1.\n• Otherwise, the search ends \nwith failure.\nExample:\nRech(47) → traversal of the branch: i, h, d (stops successfully: P = d and k = 2)\nRech(15) → traversal of the branch: i, a, g (stops with failure: P = g and k = 3) \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 8,
    "text": "8\n2024/2025\n2ème année CP\nInsertion Mechanism \nTo insert a new value V into an m-ary search tree, proceed as follows:\n1. Search for V to verify that it does not already exist and to locate the last \nvisited node P. The search also returns the index k where the value V \nshould be placed to maintain the order of values in P.\n2. IF P is not full:\n Insert V into P, shifting values as needed to keep the array of values \nordered.\nELSE:\n Allocate a new block Q containing a single value V and two child pointers \nset to -1.\n Connect Q as the k-th child of P (which must currently be -1).\nEND IF.\nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 9,
    "text": "9\n2024/2025\n2ème année CP\nInsertion Mechanism \nExample: inserting the value 64\nIf the last node visited during the search is not full ... \nThen insert the new value into the last visited node (with internal shifts within the \nblock). \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 10,
    "text": "10\n2024/2025\n2ème année CP\nInsertion Mechanism \nExample: inserting the value 61\nIf the last node visited during the search is already 100% full ...\nThen allocate a new block containing the new value and connect it to the \ntree. \nPr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 11,
    "text": "10\n2020/2021\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nDeletion Mechanism\nLogical Deletion:\nAdding a logical deletion flag for each value.\nIn this example, the values... 16, 50, 55, 57, 70, 82, 88 et 90 have been\n logically deleted."
  },
  {
    "file": "6) M-trees.pdf",
    "page": 12,
    "text": "12\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nDeletion Mechanism\nPhysical Deletion:\n1. Search for the node containing the value v p⇒\n2. IF p is a leaf\n• Delete v by shifting values; if p becomes empty, free p and update its \nparent.\nEND IF\n Stop.\n3. ELSE // so p is an internal node\n3.1 Search for the next or previous in-order value value: v' and node: ⇒\np'.\n3.2 Replace v with v' in p.\n3.3 Set v ← v' and p ← p'; go to step 2."
  },
  {
    "file": "6) M-trees.pdf",
    "page": 13,
    "text": "13\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nPhysical Deletion: Example of deleting the value 40\nDeletion Mechanism\n1. Search for the value 40 (a,2) // a is an internal node\n2. In-order successor of 40 is 42 (d,1), and replace 40 with 42 in a // d is also an internal \nnode…\n3. In-order successor of 42 is 47 (h,1), and replace 42 with 47 in d // h is a leaf node...\n4. Delete 47 by shifting in h."
  },
  {
    "file": "6) M-trees.pdf",
    "page": 14,
    "text": "14\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nIn-order successor \nCase 1:\nJ=buf.degre-1 and fils.degre=-1"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 15,
    "text": "15\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nIn-order successor \nCase 2:\nJ<buf.degre-1 and filsj+1=-1\nCas 3:\nfilsj+1 <> -1"
  },
  {
    "file": "6) M-trees.pdf",
    "page": 16,
    "text": "16\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nIn-order traversal \nThe in-order traversal of an m-ary search tree allows visiting all the values in the tree in \nascending order. \n In-order( r:entier ) // input r: the number of the root block of the tree \nvar buf : Tbloc ; k:entier \nIf ( r <> -1 ) \n LireDir( F , r , buf ) \n for (k = 1 , buf.degre - 1 ) \n In-order( buf.Fils[k] ) \n visiter( Val[k] )\n endfor\n \nIn-order( buf.Fils[ buf.degre ] ) \nendIf"
  },
  {
    "file": "7) B-trees.pdf",
    "page": 1,
    "text": "Democratic and Popular Republic of Algeria\nMinistry of Higher Education and Scientific Research\nEcole supérieure en sciences et technologies de \nl’informatique et du numérique \nB-trees \nPresented by : Dr. Daoudi Meroua \nAcademic year: 2024/2025"
  },
  {
    "file": "7) B-trees.pdf",
    "page": 2,
    "text": "2\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees \nB-treesIt is one of the most efficient access methods known to date for large and \nhighly dynamic files.\nFiles of the completely balanced m-ary search tree type:\n• Same block structures and same declarations.\n• Same search mechanisms \nProperties :\nA B-tree of order N is an m-ary search tree of order N that satisfies the \nfollowing properties:\na) All nodes (except the root) must be filled to at least 50% of their capacity \n(minimum degree = N/2⌊ ⌋ ).\nb) The root node can contain a minimum of only one value and two \nchildren.\nc) All leaves are at the same level.\nd) In an internal node, all children (Child1, Child2, ... Childdegree) are \ndifferent from -1, and in a leaf node, all children (Child1, Child2, ... \nChilddegree) are -1."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 3,
    "text": "3\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees \nExample of a B-tree of Order 5\nThe maximum capacity of a node is: 4 values (and 5 children).\nExcept for the root, the minimum capacity of a node is: 2 values (and thus 3 \nchildren)."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 4,
    "text": "4\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : insertion \nInserting a New Value x:\n1. Search for x:\n• If x already exists, go to Step 4 (End).\n• Otherwise, let P be the last visited node (a leaf), and proceed to Step 2.\n2. if (P is not full):\n• Insert x into P (using internal shifts as needed).\n• Go to Step 4 (End).\n3.If P is full, split P into two nodes:\n• Allocate a new node Q.⇒\n• P: Will contain the first half of the values.\n• Q: Will contain the second half of the values.\n• Let m be the middle value separating the two halves.\n //Now insert m into the parent of P:\n• Set x ← m, P ← parent(P).\n• If (P == nil), allocate a new root node for P.\n• Go to Step 2.\n• End."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 5,
    "text": "5\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : insertion \nInserting the value 10:\nThe search for 10 leads to the leaf node g (position = 1 in g).\nSince g is not full, the insertion is done using internal shifts."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 6,
    "text": "6\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : insertion \nInsertion of x at position 2 (and its right child fd) using internal \nshifts in a full node.\nAfter internal shifting (values and children).\nAfter inserting x (and its right child fd) and updating the degree."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 7,
    "text": "7\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : insertion \nResult of inserting the value 90:\nThe search for 90 leads to the leaf node e (position = 4 in e).\nSince e is already full, the node will be split:\nA new node (j) is allocated.\nThe ordered sequence is formed: 71, 76, 80, 90, 97.\nThe sequence is split into: [71, 76], [80], [90, 97].\nWith the middle value (80) inserted into the parent node h."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 8,
    "text": "8\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : insertion \nInsertion of x = 25 (and its right child fd), through splitting, in a full node P:"
  },
  {
    "file": "7) B-trees.pdf",
    "page": 9,
    "text": "9\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : insertion \nInsertion of x = 25 (and its right child fd), through splitting, in a full node P:\nAllocation of a new block: Q."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 10,
    "text": "10\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : insertion \nInsertion of x = 25 (and its right child fd), through splitting, in a full node P:\nSplitting the sequence between:P (first half) and Q (second half)\n[20,25,30,40,50]\n P Q"
  },
  {
    "file": "7) B-trees.pdf",
    "page": 11,
    "text": "11\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nDeletion of c (Del(c)):\n1. Search(c) → (i, j) with stacking of the visited nodes.\n2. If i is an internal node:\n• Replace c with its in-order successor c’ (which must be in a leaf).\n• Let (i, j) be the address of c’.\n3. Delete the value at position j (and its right child) by internal shifts in i.\n4. If i becomes underfilled (underflow):\nIf one of i’s siblings is more than 50% full (contains more than the minimum):\n➢Redistribute with this sibling.\nOtherwise: // The siblings are therefore filled to the minimum.\n➢Fusion:\n• Merge i with one of its siblings.\n• Remove the middle value from the parent:\n• (Unstack <i, j ...>; go to Step 3)."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 12,
    "text": "12\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nExample 1: Deletion of 40\n1. The search for 40 ends at (i, 1)."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 13,
    "text": "13\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nExample 1: Deletion of 40\n2. Since it is an internal node, 40 in (i, 1) is replaced by its in-order successor, \n42 → (d, 1)."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 14,
    "text": "14\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nExample 1: Deletion of 40\n3. 42, i.e., (d, 1), is deleted using internal shifts.\nEnd of the deletion of 40."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 15,
    "text": "15\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nExample 2: Deletion of 57\n1. The search for 57 ends at (f, 1)."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 16,
    "text": "16\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nExample 2: Deletion of 57\n2. Since f is a leaf node, 57 is deleted using internal shifts.\n4. The node f becomes underfilled (in a state of underflow).\nIts left sibling (d) is filled to its minimum capacity (50%).\nIts right sibling (e) is filled to more than 50%."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 17,
    "text": "17\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\n→ Right-to-left redistribution between f and e (via h)."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 18,
    "text": "18\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nExample 1: Deletion of 57\n→ End deletion of 57"
  },
  {
    "file": "7) B-trees.pdf",
    "page": 19,
    "text": "19\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nExample 3: Deletion of 24\n1. The search for 24 ends at (a, 2)."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 20,
    "text": "20\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nExample 3: Deletion of 24\n2. a is an internal node, so 24 is replaced by the next in-order successor: 27 (c, 1).\n3. 27 is deleted using internal shifts in c."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 21,
    "text": "21\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nExample 3: Deletion of 24\n4. c becomes underfilled (underflow):\nIts only sibling (g) is filled to its minimum capacity.\n→ Merge c and g into g (with the value 27 being moved down from the parent \nnode a)."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 22,
    "text": "22\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\n→ Delete 27 in a and release the node c (as it is now empty)."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 23,
    "text": "23\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\na becomes underfilled. Its only sibling (h) is at 50%.\n→ Merge a and h into a (with the value 42 being moved down from the parent node i)."
  },
  {
    "file": "7) B-trees.pdf",
    "page": 24,
    "text": "24\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : Deletion\nExemple 3 : Suppression de 2\nRelease of node i and h:"
  },
  {
    "file": "7) B-trees.pdf",
    "page": 25,
    "text": "25\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nB-trees : variations \n \nThere are several variations of the basic method \n1) B+-tree\n2) Prefixed B+-tree\n3) B*-tree\nSee the review article:\nGoetz Graefe, Modern B-Tree Techniques\nFoundations and Trends in Databases, Vol. 3, No. 4 (2010) 203–402\nhttp://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.219.7269&rep=re\np1&type=pdf"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 1,
    "text": "Democratic and Popular Republic of Algeria\nMinistry of Higher Education and Scientific Research\nEcole supérieure en sciences et technologies de \nl’informatique et du numérique \nHashing methods \nPresented by : Dr. Daoudi Meroua \nAcademic year: 2024/2025"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 2,
    "text": "2\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nIntroduction\nProblem: Storing data in an arbitrary order in an array \n➢Maintaining an ordered array:\nIn this case, inserting a new data item requires shifting elements to \npreserve the order.\n➢Not maintaining an ordered array:\nHere, inserting a new data item is fast because it is simply appended to \nthe end."
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 3,
    "text": "3\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nHashing \nA third solution:\n●Assign each key xxx a position y in the array, calculated using a hash \nfunction h such that y=h(x)\n●This is referred to as a scattered storage table or the Hashing \ntechnique.\n●In this type of storage, whether for inserting or searching for data, the \nprocess is always fast (O(1))"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 4,
    "text": "4\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nHashing \nStorage by Address\n Calculation \nh(x)\nThe function h must return \nvalues between 0and N−1\nData to \nbe stored\n• Store data (x) in a table (T) using a function (h) for quick \nlocalization (address calculation).\n• We try to store x in the cell at index h(x) (primary address).\n• If the cell is already occupied (collision), we insert x at \nanother location (secondary address) determined by a given \nalgorithm (collision resolution method).\n• h(x4)=h(x7)=2 x4 and x7 are synonyms. The primary \naddress of x4 and x7 is 2.\n• X7 is inserted in overflow.The secondary address of x7 is \nN−1"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 5,
    "text": "5\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTerminology\n The function hhh is called a hash function.\n The primary address h(x)h(x)h(x) of a data item is the result \nreturned by the hash function.\n Synonyms are data items that have the same primary \naddress.\n Example:\n x1 and x2 are synonyms if h(x1)=h(x2). It is also said that x1 \nand x2 are in collision.\n Overflow occurs when a data item is not at its primary \naddress. It is also said to be stored at a secondary address.\n The secondary address is determined by a given method. \nThis is referred to as a collision resolution method."
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 6,
    "text": "6\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nHashing \nCombine: a hash function with a collision resolution \nmethod. \n A good property of a hash function:\nminimizes collisions while minimizing the range of the space ⇒\naddressable. \n A collision resolution method allows for managing (searching, \ninserting, and deleting) data that caused collisions. Examples \ninclude Linear Probing, External Chaining, Double Hashing, etc."
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 7,
    "text": "7\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nHashing function\n• The goal is to find a hash function hhh such that 0≤h(x)<N \nthat minimizes the number of collisions:\n• The ideal case is to find a bijective hash function, which \nmeans a function that assigns a unique position in the \narray for each data item to be inserted.\n• The worst-case scenario is when all data is hashed to the \nsame address.\n• An acceptable solution is one in which some data share \nthe same address (the hash function is not injective)."
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 8,
    "text": "8\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nHashing function\nThere are several hash functions, with the most commonly used being:\n●The Division Hash Function: Uses the modulo operation to determine \nthe index, typically h(x)=xmod N, where N is the size of the table.\n●The Squaring Method: Involves squaring the key and extracting a \nportion of the result to use as the hash value. This method helps in \ndistributing the hash values more uniformly.\n●The Radix Transformation Method: Converts the key into a different \nbase (radix) and uses a portion of the transformed value to determine \nthe index in the hash table."
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 9,
    "text": "12\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nIn conclusion, there is no universal hash function.\nHowever, a good hash function should be:\n• Fast to compute\n• Distribute elements uniformly\nIt therefore depends on:\n• The machine\n• The elements\nBut no function can completely avoid collisions, which will \nneed to be handled.\nHashing function"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 10,
    "text": "13\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nTo resolve collisions, two strategies are available:\n Direct methods (hashing by calculating the location):\n➢ Linear Probing\n➢ Double Hashing\n● Indirect methods or hashing by chaining:\n➢ Separate Chaining\n➢ Internal Chaining\nCollision Resolution Methods"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 11,
    "text": "14\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n1. If a collision occurs at the position h(x), we try the preceding \npositions: h(x)−1,h(x)−2,…,0,N−1,N−2,… until we find an empty \nslot.\n2. Finding an empty slot indicates that the data does not exist in \nthe table.\n3. A free slot must be sacrificed in the hash table to ensure that the \nprobing sequence is finite. \nCollision Resolution Methods : Linear Probing"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 12,
    "text": "15\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nCollision Resolution Methods : Linear Probing"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 13,
    "text": "16\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nCollision Resolution Methods : Linear Probing\nEssai linéaire:"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 14,
    "text": "17\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nCollision Resolution Methods : Linear Probing\nEssai linéaire:"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 15,
    "text": "18\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nCollision Resolution Methods : Linear Probing\nEssai linéaire:"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 16,
    "text": "19\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nCollision Resolution Methods : Linear Probing\nEssai linéaire:"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 17,
    "text": "20\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nCollision Resolution Methods : Linear Probing\nThe search for k such that h(k)=2 stops with \na failure at the empty slot at index 6 → the \ntest sequence is: 2, 1, 0, 9, 8, 7.\nIf we were to insert k, the data would be \nplaced at index 6 (if it is not the last empty \nslot).\nThe table is considered full when the \nnumber of inserted elements equals N−1 \nleading to the sacrifice of one empty slot. \nEssai linéaire:"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 18,
    "text": "21\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nLinear Probing : search\n• The search for a data item proceeds as follows:\n• Calculate the primary address of x(let i=h(x))\n• If the slot i in the hash table contains the data x, the search is \nsuccessful.\n• Otherwise, search for x in the preceding slots: i−1,i−2,…,0,N−1,N−2,\n…until an empty slot is found.\n• If the search stops at an empty slot, it means that x does not exist in \nthe hash table."
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 19,
    "text": "22\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nLinear Probing : Insertion\n \nThe insertion of a value x proceeds as follows:\nCalculate the primary address of xxx (let i=h(x)i = h(x)i=h(x)).\nIf the slot iii is empty, insert xxx into iii and mark the slot as \noccupied.\nOtherwise, traverse the preceding slots until an empty slot is \nfound (let jjj).\nInsert xxx into the slot jjj and mark it as occupied."
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 20,
    "text": "23\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nLinear Probing : deletion\nThe physical deletion of the data x creates \nan empty slot.\nThis new empty slot can make other slots \ninaccessible.\nFor example, if we want to delete b by \nclearing slot 1, we also lose access to the \ndata f (where h(f)=2 ) because it is no \nlonger accessible.\nTests must be performed before clearing a \nslot to ensure that other data is not lost."
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 21,
    "text": "24\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nLinear Probing : deletion"
  },
  {
    "file": "8) hachage 1.pdf",
    "page": 22,
    "text": "25\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nLinear Probing : deletion\nThe principle of deleting the data xxx is as follows:\nSearch for the address i of x.\nTraverse all the slots preceding i (let j) until an empty slot is found.\nFor each slot j, verify that its data remains accessible if slot i is \ncleared.\nIf all preceding slots remain accessible after clearing i, then clear i \nand stop.\nIf not, move the data from slot j to slot i and attempt to clear its \noriginal slot by testing the remaining slots that have not been \ntested. The same principle is applied for slot i."
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 1,
    "text": "Democratic and Popular Republic of Algeria\nMinistry of Higher Education and Scientific Research \nEcole supérieure en sciences et technologies de \nl’informatique et du numérique \nHashing methods \nPresented by : Dr. Daoudi Meroua \nAcademic year: 2024/2025"
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 2,
    "text": "5\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nUse of hash tables \n1. Use a hash table as an index, in MC, to speed up access to data files."
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 3,
    "text": "6\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nUse of hash tables \n2. Use an index in MS, managed by a hashing method."
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 4,
    "text": "7\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\n3. Manage the data file using a hashing method. \nFichier de données\nen MS\nUse of hash tables"
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 5,
    "text": "4\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nFile with hashing \nThe primary address of \nthe record with key x is \nthe block number h(x). \nIf the block is full, one of \nthe collision resolution \nmethods is used. \nThe capacity of a block \nis b records \nUse of hash tables"
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 6,
    "text": "8\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nCollision resolution methods \n- Linear Probing \n Sequence of probes: blocks numbered h(x) , h(x)-1 , h(x)-2 , … 0 , N-1 , … \n< non_full_block >\n- External Chaining \nSequence of probes: block number h(x) and those in its overflow list that are \nlocated outside the range addressable by the hash function h."
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 7,
    "text": "9\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nLinear Probing \nThere must always be at \nleast one non-full block. \nThe sequence of probes \nmay eventually be circular. \nThe insertion is made in the \nfirst non-full block found in \nthe sequence of probes. \nLogical or Physical Deletion"
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 8,
    "text": "10\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nThe characteristics: \n1- N : the number of blocks forming the file \n2- nbIns : the number of data entries inserted \nRech( entrée : x sorties : trouv, i, j )\ni ← h(x) ; trouv ← faux ; stop ← faux ; N ← Entete( F, 1 )\nTQ ( Non trouv && Non stop )\n LireDir( F, i, buf )\n j ← 1 // Internal search within block i \n TQ ( j ≤ buf.NB && Non trouv )\n SI ( x = buf.tab[ j ].cle ) trouv ← vrai SINON j ← j+1 FSI\n FTQ\n SI ( buf.NB < b ) // If there is an empty slot (non-full block) \n stop ← vrai // Then end of the probe sequence \n SINON i ← i - 1 ; SI ( i < 0 ) i ← N-1 FSI // Otherwise, continue the \nprobes \n FSI\nFTQ\nLinear Probing : Search algorithm"
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 9,
    "text": "11\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nThe characteristics: \n1- N : the number of blocks forming the file \n2- nbIns : the number of data entries inserted \nIns( entrée : e )\nN ← Entete( F, 1 ) ; nbIns ← Entete( F, 2 )\n SI ( nbIns = N * b – 1 ) Insertion impossible // No available space \n SINON\n Rech( e.clé , trouv , i , j )\n SI ( Non trouv )\n buf.NB++ \n buf.tab[ buf.NB ] ← e \n EcrireDir( F, i, buf )\n Aff_Entete( F , 2 , nbIns+1 )\n FSI\n FSI\nLinear Probing : insertion"
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 10,
    "text": "12\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nExternal Chaining"
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 11,
    "text": "12\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nExternal Chaining"
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 12,
    "text": "13\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nExternal Chaining : Search algorithm\nWe assume that F contains the main area (the blocks between 0 and N-1) and the \noverflow area (the blocks from number N to the end of the file) \nThe characteristics:\nN: the number of blocks forming the main area\nM: the total number of blocks in F (main area + overflow area)\nnbIns: the number of data entries inserted\nRech( entrée : x sorties : trouv, i, j )\ni ← h(x) ; trouv ← faux ; stop ← faux ; LireDir( F, i, buf )\nTQ ( Non trouv && Non stop )\n j ← 1 // Internal search within block i \n TQ ( j ≤ buf.NB && Non trouv )\n SI ( x = buf.tab[ j ].cle ) trouv ← vrai SINON j++ FSI\n FTQ\n SI ( Non trouv )\n SI ( buf.lien <> -1 ) i ← buf.lien ; LireDir( F, i, buf ) SINON stop ← vrai FSI\n FSI\nFTQ"
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 13,
    "text": "14\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nExternal Chaining : insertion algorithm\nIns( entrée : e , nomFich : chaîne )\nOuvrir( F , nomFich , ‘A’ )\nRech( e.clé, trouv, i, j )\nSI ( Non trouv )\n// If there is space in the last visited block, insert e there \n SI ( buf.NB < b )\n buf .NB++ ; buf.tab[ buf.NB ] ← e ; EcrireDir( F, i, buf )\n SINON\n// If the last block is already full, allocate a new overflow block\" \n nouvBloc ← Entete( F , 2 ) + 1\n buf.lien ← nouvBloc // Chain the new block with the previous one (i) \n EcrireDir( F, i, buf )\n buf .NB ← 1 ; buf.tab[ 1 ] ← e // Insert e into the new block \n buf.lien ← -1\n EcrireDir( F, nouvBloc, buf )\n Aff_Entete( F , 2 , Entete( F , 2 ) + 1 ) // The total number of blocks \n FSI\n Aff_Entete( F , 3 , Entete( F , 3 ) + 1 ) // The number of insertions \nFSI Fermer( F )"
  },
  {
    "file": "9) hachage 2.pdf",
    "page": 14,
    "text": "14\n2024/2025\n2ème année CP Pr Hidouci W.K. (http://hidouci.esi.dz) / SFSD / ESI\nInternal Chaining \n N+1\nM\nN-1\nZone primaire \nZone secondaire ou \nde débordement"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 1,
    "text": "Polycopié de Cours\nStructures de Fichiers\n- Structures de Données Externes -\n(SFSD / 2CP)\nHIDOUCI Walid-Khaled & KERMI Adel\nESI - 2024"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 2,
    "text": "Plan\n1) Généralités 2\n2) Les structures séquentielles 19\n3) Les méthodes d’index 30\n4) Les méthodes à base d’arbres de recherche 42\n5) Les méthodes de Hachage 57\n6) Les opérations de haut niveau 64"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 3,
    "text": "Introduction\nL’objectif du cours est l’étude des méthodes d’accès aux fichiers (struct ures et algorithmes\nassociés : recherche, insertion, suppression, …). Cela concerne principalement :\n• Les performances des solutions algorithmiques manipulant des structures de fi chiers\n(manipulation efficace de données volumineuses et massives).\n• L’analyse de la complexité pour ce type particulier d’algorithmes.\nA l'issue de ce cours, les étudiants seront capables de :\n• Développer des solutions algorithmiques efficaces qui manipulent les structures de fichiers.\n• Analyser la complexité temporelle et spatiale des différentes mé thodes de structuration de\nfichiers.\n• Répondre aux nouvelles problématiques liées aux données massives.\n• Comprendre les éléments de base utilisés dans les systèmes de stoc kage modernes et dans\nl'optimisation/traitement des requêtes.\nLes notions traitées dans ce cours perm"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 3,
    "text": "ments de base utilisés dans les systèmes de stoc kage modernes et dans\nl'optimisation/traitement des requêtes.\nLes notions traitées dans ce cours permettent d’aborder sans difficultés , les futures enseignements\ndans les domaines des bases et ingénierie de données, ainsi que dans l a programmation avancée et\nles systèmes d’exploitation modernes.\nNous nous intéressons à l’étude des algorithmes de base sur les grands ens embles de données en\nmémoire externe. C’est un aspect fondamental dans la formation de base d’un ingénieur d’état en\ninformatique de haut niveau.\n \nLes structures de fichiers permettent de représenter des ensembles de données (souvent très\nvolumineux) à l’aide de structures de données internes et externes. Leurs ma nipulations induit des\ntransferts de données entre mémoire centrale et mémoire externe (secondaire).\nL’optimisation du nombre de transferts est le principal obj"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 3,
    "text": "s induit des\ntransferts de données entre mémoire centrale et mémoire externe (secondaire).\nL’optimisation du nombre de transferts est le principal objectif permettant l’amélioration des\nperformances pour ce type d’applications.\nLe langage C sera utilisé pour la mise en pratique des notions abordées dans ce cours. La maîtrise\nde ce langage en particulier, constitue la meilleure voie pour une com préhension saine et précise du\nfonctionnement et des détails internes des systèmes informatiques en général.\nHidouci W.K. & Kermi A. / Introduction / Cours : Structures de fichiers (SFSD) / ESI – 2024 1"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 4,
    "text": "Structures de Fichiers\nChapitre 1  Généralités\nDans ce chapitre nous allons présenter les notions générales relatives aux structures de fichiers. Les\nprincipaux points abordés sont\n- Les mémoires\n- Les fichiers\n- Les opérations de base sur les fichiers\n1) Les différents types de mémoires \nIl existe plusieurs types de mémoires dans un ordinateur. Chaque type de mémoi re est caractérisé\npar la vitesse d’accès, la taille, la nature de l’accès permis (lecture, écriture, effacement, ...), le coût\net la volatilité (pertes d’information en cas de crash système ou redémarrage).\nIl y a des mémoires très rapides, très coûteuse et en très petites quantités : les registres du\nprocesseur. Leur utilisation est automatisée à travers le module de génération de code du\ncompilateur utilisé.\nIl y a des mémoires très lentes, peu coûteuses et en très grandes quantités : par exemple les volumes\nde bandes magn"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 4,
    "text": "n de code du\ncompilateur utilisé.\nIl y a des mémoires très lentes, peu coûteuses et en très grandes quantités : par exemple les volumes\nde bandes magnétiques. De nos jours on ne les utilise principalement que pour l’archivage des\ndonnées et programmes à travers des commandes particulières du système d’exploitation.\nEntre ces deux extrêmes on trouve (dans l’ordre croissant des vitesses d’accès et décroissant du coût\nà l’unité) les types de mémoires suivants :\n- Les mémoires cache entre le processeur et la mémoire centrale (en lecture/écriture et volatile\ngérées principalement par le hardware). Leurs tailles sont supérieures aux registres et inférieures à\nla mémoire centrale.\n- La M \némoire C entrale (MC) ou mémoire principale (en lecture/écriture et volatile) contenant le s\nprogrammes et les données en cours de traitement . La taille est supérieure à celle des mémoires\ncaches et inférieur"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 4,
    "text": "iture et volatile) contenant le s\nprogrammes et les données en cours de traitement . La taille est supérieure à celle des mémoires\ncaches et inférieure à celle de la mémoire secondaire.\n- La M \némoire S econdaire ( MS), souvent constituée de dispositifs de mémoires externes à accès\ndirect : les disques magnétiques , les flash disques, les disques SS D, … (en lecture/écriture et non\nvolatile). La MS est utilisée principalement pour le stockage persistent des programmes et/ou\ndonnées et aussi pour la virtualisation de la MC (comme par exemple le paging dans les systèmes\nd’exploitation). Sa taille est souvent supérieure à celle de la MC mais l’accès est beaucoup plus lent\naussi. Souvent une petite partie de la MC est réservée par le système d’exploitation pour être gérée\ncomme mémoire cache de la MS (par exemple le buffer pool).\n- Les autres mémoires externes ou auxiliaires utilisées princi"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 4,
    "text": "exploitation pour être gérée\ncomme mémoire cache de la MS (par exemple le buffer pool).\n- Les autres mémoires externes ou auxiliaires utilisées principale ment pour l’archivage de données\net de programmes sont constituées de dispositifs de mémorisation lents e t peu coûteux. Souvent\noffrant la possibilité de gestion multi-volumes pour rendre leur capacité de stockage théoriquement\nillimitée. Nous retrouvons dans cette catégorie les disques optiques (en lecture seule ou en\nlecture/écriture limitée et non volatiles) et les bandes magnétiques à accès séquentielle (en\nlecture/écriture et non volatile). \nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 2"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 5,
    "text": "En programmation de structures de fichiers , nous nous intéressons principalement à la mémoire\ncentrale ( MC) et à la mémoire secondaire ( MS). Toutes les variables d’un programme en cours\nd’exécution sont allouées en MC et le contenu des fichiers manipulés se trouve en MS. D’après le\nparagraphe précédent, nous retiendrons ce qui suit :\n- La MC est volatile (son contenu est perdu en cas de crash système ou redémarrage)\n- La MS n’est pas volatile (elle est supposée résister aux crash et redémarrages)\n- L’accès à la MC est beaucoup plus rapide que celui à la MS. Par exemple avec les technologies\nactuelles, l’accès à une unité d’information en MC est presque 10000 à 100000 fois plus rapide\n que\ncelui d’un disque magnétique et aussi 1000 fois plus rapide que celui d’un disque SSD. \n1.1) Structure des disques magnétiques\nUn des types de MS les plus utilisés de nos jours reste le disque magnét"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 5,
    "text": "lus rapide que celui d’un disque SSD. \n1.1) Structure des disques magnétiques\nUn des types de MS les plus utilisés de nos jours reste le disque magnétique (ou encore disque dur :\nDD ou HDD pour Hard Disk Drive).\nUn HDD est un ensemble de plateaux en forme de disques superposés. Chacun d'eux est formé de\ndeux faces magnétiques ( surfaces) et tournent en continu avec une certaine vitesse de rotation.\nChaque piste est découpée en secteurs de même taille. Le secteur représente l'unité de transfert\nentre la MS et la MC. C'est la plus petite quantité d'information pouvant être lue ou écrit e sur le\ndisque.\n Disque = ensemble de plateaux tournant avec une vitesse de rotation déterminée\n Plateau = ensemble de pistes concentriques numérotées 0, 1, 2, ... sur chaque face\n Cylindre = ensemble de pistes ayant un même diamètre sur les différents plateaux\n Piste = ensemble de secteurs de même taille\n "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 5,
    "text": ", ... sur chaque face\n Cylindre = ensemble de pistes ayant un même diamètre sur les différents plateaux\n Piste = ensemble de secteurs de même taille\n \nLe bras du disque contient les têtes de lecture/écriture (une pour chaque face d'un plateau). Il se\ndéplace latéralement de cylindre en cylindre pour positionner les têtes de lecture/écriture sur les\nbonnes pistes.\nPour lire ou écrire un secteur donné, le contrôleur déplace d'abord le bras vers le bon cylindre,\nensuite attend que le bon secteur passe sous la tête de lecture/écriture concernée avant de transférer\nles données.\nAvec la technologie actuelle, le temps nécessaire à cette opérat ion (temps d'accès = temps du\ndéplacement du bras + le temps d'attente de passage du secteur cherché sous la tête de\nlecture/écriture, incluant le transfert de données MC↔MS) est au voisinage de quelques\nmillisecondes en moyenne. Si on le compare au temps"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 5,
    "text": " la tête de\nlecture/écriture, incluant le transfert de données MC↔MS) est au voisinage de quelques\nmillisecondes en moyenne. Si on le compare au temps d'accès à l a mémoire centrale (quelques\ndizaines ou centaines de nanosecondes), la différence est énorme (le tem ps d'accès au disque est\nplus lent que celui de la MC de plusieurs ordres de grandeurs). Le temps de déplacement du bras\n(temps de translation) est plus grand que le temps de rotation. Des le ctures ne nécessitant pas de\ndéplacement de bras (donc sur le même cylindre) coûtent aux environs de quelques ms en moyenne.\nParmi les méthodes utilisées (dans les systèmes d’exploitation) pour diminuer l'effet de cette grande\ndifférence dans le temps d'accès entre la MC et la MS, on trouve le buffering. Il s'agit de réserver\nune zone en mémoire centrale ( MC) pouvant contenir plusieurs blocs en même temps (le buffer-\ncache). Lors de la le"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 5,
    "text": "e buffering. Il s'agit de réserver\nune zone en mémoire centrale ( MC) pouvant contenir plusieurs blocs en même temps (le buffer-\ncache). Lors de la lecture de blocs non présents en MC, des stratégies de remplacement (comme\nLRU, FIFO, …) sont utilisées afin de minimiser le nombre d'accès disque. Le prefetching\n(consistant à lire plusieurs blocs consécutifs lors d’une demande d’accès à un seul bloc donné) est\ntrès souvent utilisé, en combinaison avec le buffering, pour augmenter les chances de trouver les\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 3"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 6,
    "text": "blocs demandés, déjà présents en MC, lors de leurs éventuels futurs accès.\nD'autres techniques, comme la multi-programmation (durant l'opération d'E/S d'un programme, le\nprocesseur est alloué à un autre programme) avec le Time-Sharing (pseudo-parallélisme entre\nplusieurs processus en partageant le temps CPU) ou encore la parallélisation des E/S (les données\nsont réparties sur plusieurs disques – comme dans la technologie RAID) sont aussi utilisées pour\ndiminuer le goulot d'étranglement sur les E/S.\nDe plus, comme le temps de déplacement du bras est plus grand que celui nécessaire pour la\nrotation du disque, l'accès à des secteurs physiquement proches (situés sur la même piste ou le\nmême cylindre par exemple) est beaucoup plus rapide que l'accès à des secteurs néc essitant un\ndéplacement du bras. Le clustering est une technique de stockage rassemblant les données\nsusceptibles d'être trait"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 6,
    "text": "ccès à des secteurs néc essitant un\ndéplacement du bras. Le clustering est une technique de stockage rassemblant les données\nsusceptibles d'être traitées ensemble dans des secteurs physiquement proches.\nLe disque est contrôlé par un circuit (le contrôleur de disque) qui offre au système d'exploitation des\nprimitives d'E/S (du type 'Lire_un_Bloc(...) / Ecrire_un_Bloc(...)' ) cachant les détails internes\nconcernant les déplacements du bras et la rotation des plateaux. Pour ce type de périphériques, les\nE/S sont dites \"bufférisées\" car les transferts se font bloc par bloc (ex: un bloc = un ou plusieurs\nsecteurs). \nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 4\nplateaux Tête de \nlecture/écriture\nBras\nsurface\npiste\nRotation des plateaux Translation (déplacement) \ndu bras\nsecteurs"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 7,
    "text": "Les primitives d'E/S permettent de manipuler les secteurs du disque (l'unité de transfert) comme\nétant des tableaux d'octets de taille fixe (ex 512, 1024, 4096 octets ...).\n1.2) Structure des disques SSD\nLes Disques à base de mémoires flash : ‘ Solid State Drive’ (SSD), représentent un nouveau type de\nMS, de plus en plus utilisés pour leur performance et leur faible consommation d’énergie\n(relativement aux traditionnels disques magnétiques HDD)\nC’est des dispositifs de stockage externe à base de mémoires flash (principalement de type NAND),\nils sont aussi plus robustes que les disques magnétiques car ils ne contiennent pas de composants de\nmécanique de précision sensibles (comme les têtes de lectures/écritures du HDD) susceptibles de se\ndétériorer en cas de chocs ou de mouvements brusques du périphérique. Ils sont à base, uniquement\nde semi-conducteurs.\n \nLa mémoire du SSD est divisée en"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 7,
    "text": "ériorer en cas de chocs ou de mouvements brusques du périphérique. Ils sont à base, uniquement\nde semi-conducteurs.\n \nLa mémoire du SSD est divisée en groupes (ou bloc de pages, de capacité fixe, ex: 256K) et chaque\ngroupe est composé d’un certain nombre de pages (ex. taille d’une page = 4K).\n \nIl y a trois opérations possibles :\n- Lire une page très rapide (20 microsecondes, pour les disques actuels)⇒\n- Ecrire une page, à condition qu’elle soit dans un état effacé rapide (100 à 200 microsecondes)⇒\n- Effacer toute les pages d’un groupe (un bloc de pages) lente (quelques millisecondes)⇒\nLes groupes (ou blocs de pages) supportent un nombre fixe d’effacements, au delà duquel ils\ndeviennent inutilisables. Il faut donc répartir de manière uniforme les e ffacements\n sur l’ensemble\ndes groupes du SSD afin d’augmenter la durée de vie du disque C’est la technique du ⇒ Wear-\nLeveling\nLors de la mi"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 7,
    "text": "me les e ffacements\n sur l’ensemble\ndes groupes du SSD afin d’augmenter la durée de vie du disque C’est la technique du ⇒ Wear-\nLeveling\nLors de la mise à jour du contenu d’une page, il est aussi préférable d’é crire\n le nouveau contenu\ndirectement dans une nouvelle page (déjà effacée). Cela évite l’attente (coûteuse) de l’effacement\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 5\nPlan\nPlan\nPlan\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nFlash\nChip\nMémoire\nVolatile\nContrôleur\ngroupe\npage1 page2 page64 ...page3 page4"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 8,
    "text": "d’un groupe au moment de l’écriture du nouveau contenu de la page. Les données st ockées dans le\ndisque, changent donc souvent d’emplacements physiques.\nPour rendre ces changements transparents, les utilisateurs manipulent l es pages du SSD à travers\ndes numéros logiques (qui restent constants et indépendants des localisat ions physiques des pages\nsur la mémoire flash). Le contrôleur du disque maintient alors une table d’association (c’est la FTL)\ncontenant les correspondances entre les numéros logiques et les adresses physi ques des pages. A\nchaque écriture d’une page (dans un nouveau emplacement physique), la FTL est mise-à-jour en\nconséquence pour garder le lien entre le numéro logique de la page (qui rest e inchangé) et le\nnouveau numéro physique utilisé. La FTL est chargée dans une mémoire vive interne au\npériphérique SSD.\n2) Notion de fichier et système de fichiers\nPour faire abstr"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 8,
    "text": "o physique utilisé. La FTL est chargée dans une mémoire vive interne au\npériphérique SSD.\n2) Notion de fichier et système de fichiers\nPour faire abstraction de ces détails physiques (liés aux dispositifs ut ilisés : HDD, SSD, ...), on\nconsidère la mémoire secondaire comme une grande zone de stockage formée de blocs physiques\nde même taille fixe. Selon le type de la MS, le bloc physique, au niveau du système d’exploitation,\npeut être composé d’un ou de plusieurs secteurs d’un HDD ou alors d’une ou de plusieurs pages\nd’un SSD.\nChaque bloc physique représente donc un tableau d'octets pouvant être lu ou éc rit en une seule\nopération d'accès (ou d’E/S physique) : LireBloc(num, Buf) et EcrireBloc(num, Buf). L'accès à la\nmémoire secondaire ne peut se faire qu'à travers ces deux opérations \nde base .\nL’opération LireBloc( i ,buf ) effectue le transfert physique du contenu du bloc numéro i (de la"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 8,
    "text": " se faire qu'à travers ces deux opérations \nde base .\nL’opération LireBloc( i ,buf ) effectue le transfert physique du contenu du bloc numéro i (de la\nMS) vers une zone en MC (la variable buf) ayant une taille suffisante pour stocker le contenu d’un\nbloc.\nL’opération EcrireBloc( i ,buf ) effectue le transfert physique inverse, du contenu de la variable\nbuf (en MC) vers le bloc numéro i de la MS.\nCes deux opérations d’E/S physiques sont très coûteuses (en terme de temps d’exécution) par\nrapport aux accès à la mémoire centrale, car elles engendrent des tra nsferts de données vers des\ndispositifs externes (les disques).\nUn fichier est le concept à travers lequel, un programme ou une application stocke des données en\nmémoire externe. Les fichiers sont utilisés à différents niveaux d'abstra ction avec des sémantiques\ndifférentes:\ni) Au niveau 'application' (ou langage de programmation de haut"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 8,
    "text": "rs sont utilisés à différents niveaux d'abstra ction avec des sémantiques\ndifférentes:\ni) Au niveau 'application' (ou langage de programmation de haut niveau), un fichier est une suite\nd'enregistrements (ou articles) persistants. L'accès aux enregistrements, à travers le langage de\nprogrammation considéré, se fait via des opérations spéciales pour la mani pulation des fichiers (ex.\nen langage Pascal : read(f,e), write(f,e), reset(f), … ). On peut aussi définir un fichier comme étant\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 6\n Fichier\n(niveau applicatif)\n Fichier typé\n(suite d'enregistrements)\nFichier non typé\n (flux d'octets )"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 9,
    "text": "une suite d'octets , on parle alors de flux (ex : les streams de la librairie standard du langage C :\nFILE * ). C'est des fichiers « non typés ». Dans des systèmes d’exploitation de type Unix, ces flux\n(streams) généralisent aussi la notion d'E/S pour une manipulation uniforme et indépe ndante des\ntypes de périphérique utilisés (disques, imprimantes, écrans, clavier, réseaux, …).\nDans le cas des fichiers typés, les enregistrements (ou articles) sont formés par un ensemble de\nchamps (ou attributs). Parmi ces champs, un ou plusieurs peuvent jouer le rôle de clé de recherche\n(Search Key). C’est le (les) champ(s) utilisé(s) généralement pour recherche r des enregistrements\ndans les applications (ex : le \nmatricule d'un étudiant, le nom d'une personne, la date, le lieu et\nl’heure d’une mesure captée par une sonde … etc). N’importe quel champ (ou groupe de cha mps)\npeut jouer le rôle d’une clé"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 9,
    "text": "rsonne, la date, le lieu et\nl’heure d’une mesure captée par une sonde … etc). N’importe quel champ (ou groupe de cha mps)\npeut jouer le rôle d’une clé de recherche. Pour faciliter certaines opérat ions sur les fichiers, on peut\naussi stocker les enregistrements d’un fichier en ordre croissant ou déc roissant selon les valeurs de\nla clé (on parle alors de fichier ordonné).\nii) Au niveau système (niveau physique), un fichier est un ensemble de blocs en MS , renfermant\nune suite d'octets non interprétés. Les données (par exemple les enregist rements) du fichier sont\nstockés à l'intérieur des blocs selon une certaine organisation. L'ac cès aux contenus des blocs se fait\nvia les opérations d'E/S bufférisées (LireBloc et EcrireBloc). \nPour pouvoir manipuler correctement un fichier, on a besoin de connaître un certain nombre\nd’informations le concernant. Ce sont les caractéristiques du fichier."
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 9,
    "text": "r manipuler correctement un fichier, on a besoin de connaître un certain nombre\nd’informations le concernant. Ce sont les caractéristiques du fichier. Cela peut être par exemple le\nnom du fichier, sa taille, les blocs qui le constituent, la date de la dernière mise-à-jour, celle de la\ndernière consultation, le propriétaire, les droit d'accès, … etc.\nToutes les opérations du niveau 'application' passent par le système qui les traduit en opérations de\nbas niveau pour accéder physiquement aux blocs d'E/S de la MS. Comme les opérations d'E/S sont\ncoûteuses (en temps), le système maintient en MC une zone spéciale de taille limitée (la zone\ntampon ou \"buffer cache\") lui permettant de garder en MC les copies de quelques blocs physiques\nchoisis selon certaines stratégies (par exemple les plus utilisés ). Cette zone tampon est totalement\ntransparentes aux programmes d'application qui utilisent le"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 9,
    "text": "on certaines stratégies (par exemple les plus utilisés ). Cette zone tampon est totalement\ntransparentes aux programmes d'application qui utilisent les fichiers. El le est gérée exclusivement\npar le système d’exploitation. Par contre elle influence beaucoup les performances des applications\nqui manipulent des fichiers. \nAinsi, si par exemple, une application demande la lecture d'un enregi strement donné, le système\nvérifie d'abord si le bloc concerné ne se trouve pas déjà en MC (dans la zone tampon). S'il y est,\nl'enregistrement cherché, sera directement transmis à l'application, sans qu'il y ait de lecture\nphysique en mémoire externe. Le temps d’accès à la donnée est dans ce cas très court. Sinon, si le\nbloc concerné n’est pas en MC, l'application est mise en attente et une opération de lecture\nphysique de bloc est engagée afin de récupérer d'abord le bloc en MC et ensuite l'enregistrem"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 9,
    "text": "lication est mise en attente et une opération de lecture\nphysique de bloc est engagée afin de récupérer d'abord le bloc en MC et ensuite l'enregistrement\ncherché. Le coût d’accès dans ce cas est très élevé.\nLors de la lecture physique d'un bloc en MC, le système cherche un emplacement libre dans la zone\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 7\nEnreg1\nEnreg2\nEnreg3\nEnreg4\nEnreg5\nEnreg6\nEnreg7\nEnreg8\nEnreg9\nEnreg n-2\nEnreg n-1\nEnreg n \nFichier = ensemble de blocs physiques"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 10,
    "text": "tampon pour y copier le contenu du bloc lu. S'il n'y a pas d'emplaceme nt libre, le système choisit un\ndes blocs déjà présents en zone tampon et le recopie, éventuellement , sur disque (EcrireBloc) avant\nde réutiliser son emplacement pour stocker le contenu du nouveau bloc lu. Le choix de\nl’emplacement à écraser dépend de la stratégie de remplacement adoptée par le système (par\nexemple la stratégie LRU : l’emplacement en zone tampon du bloc le moins récemment utilisé).\nLors de la mise à jour d'un enregistrement par une application, le système réalise l'opération\ndirectement dans sa zone tampon (en MC). L'écriture physique sur disque ne se fera que plus tard\n(lors d'un remplacement de bloc par exemple).\nPériodiquement, le système synchronise son cache avec la MS. Tous les blocs qui ont été modifiés\ndans la zone tampon, seront alors physiquement écrits en MS lors de l'opération de synchron"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 10,
    "text": " son cache avec la MS. Tous les blocs qui ont été modifiés\ndans la zone tampon, seront alors physiquement écrits en MS lors de l'opération de synchronisation.\nEn cas de panne provoquant la perte de la mémoire centrale (donc de la zone t ampon aussi), les\ndernières modifications effectués sur les fichiers ouverts, risquent donc d'être perdues. \nPour les applications critiques, il existe des moyens pour forcer l'écriture physique (sans attendre\nla synchronisation périodique du cache). Dans les systèmes de type Unix, l'appel système 'fsync( f )'\npermet d'écrire physiquement sur la MS, tous les blocs modifiés de la zone tampon et non encore\nsynchronisés, relatifs au fichier f.\nCaractéristiques et bloc d'en-tête\nPour que le système puisse gérer un fichier, il a besoin de connaître les informations sur ses\ncaractéristiques : les blocs utilisés par le fichier, l'organisation du fichier, les dro"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 10,
    "text": "un fichier, il a besoin de connaître les informations sur ses\ncaractéristiques : les blocs utilisés par le fichier, l'organisation du fichier, les droit d'accès\nassociés, ...\nCes informations (ou certaines de ces informations) sont stockées à certa ins endroits réservé du\ndisque. Par exemple, pour un système de fichier très simple, le bloc se trouvant à une adresse fixe\ndu disque, pourrait être réservé par le système pour contenir une table où chaque ligne renseigne sur\nles caractéristiques d'un fichier (nom, taille, blocs utilisés, ...). Quand une application désire ouvrir\nun fichier de nom donné, le système récupère ses informations à partir de cette table.\nDans les MS séquentielles de type bandes magnétiques, ce type d'information (les cara ctéristiques)\nse trouvait au début de chaque fichier (d'où le nom de \"bloc d'en-tête\").\nCertaines applications ont besoin aussi de gérer des carac"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 10,
    "text": "ara ctéristiques)\nse trouvait au début de chaque fichier (d'où le nom de \"bloc d'en-tête\").\nCertaines applications ont besoin aussi de gérer des caractéristiques particulières pour pouvoir\nmanipuler correctement leurs fichiers de données. Ce type de caractéris tiques peuvent aussi être\nstockées en début de fichier, avant les données à proprement parler.\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 8\nE\nF\nE E\nF\nF\nE E\nF F\nE E\nF\nE E\nF\nE\nMC\nMS\nProg1\nmanip. E\nProg2\nmanip. F\nProg3\nmanip. F Buffer cache\nE/S\nPhysiques"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 11,
    "text": "Méthode d'accès\nUne structure de fichier consiste à définir et concevoir des structures de données et les algorithmes\nassociés, pour organiser les blocs d'un fichier sur MS et implémenter certaines opérations d'accès\npour la manipulation des données du fichier. \nCela inclus par exemple de définir :\n- une manière d'organiser les blocs du fichier sur MS \n- le placement des enregistrements à l'intérieur des blocs\n- les caractéristiques et informations nécessaires pour manipuler le fichier\n- le nombre de buffers à réserver en MC pour optimiser les accès\n- l'implémentation des opérations d'accès (recherche, insertion, suppression, …)\n3) Modèle pour les structures de fichiers\nAfin d'étudier les méthodes d'accès aux fichiers dans un cadre général , on modélise la MS par une\nzone contiguë de blocs numérotés séquentiellement (ces numéros représentent les adresses de\nblocs).\n \nLes blocs sont des z"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 11,
    "text": ", on modélise la MS par une\nzone contiguë de blocs numérotés séquentiellement (ces numéros représentent les adresses de\nblocs).\n \nLes blocs sont des zones contiguës de même taille, renfermant, entre a utre, les données d’un fichier\n(enregistrements ou simple suite d’octets).\nDans le schéma suivant, la MS contient trois fichiers : E, F et G\nLe fichier E est formé de 4 blocs contigus ( E1, E2, E3 et E4), le fichier F est formé de 7 blocs\ncontigus et le fichier G est une liste de blocs.\nPour écrire des algorithmes sur les structures de fichiers on utilisera la machine abstraite définie\npar le modèle suivant: \n{Ouvrir, Fermer, LireDir, EcrireDir, Aff_Entete, Entete, Allocbloc }\nDans ce modèle, on manipule des numéros de blocs relatifs au début de cha que ficher (c’est donc\ndes numéros logiques). L'utilisation des adresses physiques n'est pas d'une utilité particulière à ce\nniveau de la prése"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 11,
    "text": "de cha que ficher (c’est donc\ndes numéros logiques). L'utilisation des adresses physiques n'est pas d'une utilité particulière à ce\nniveau de la présentation.\nDans ce modèle, un fichier est donc un ensemble de blocs numérotés logi quement (1, 2, 3, ... n). La\nfonction Allocbloc(F) ne fait alors que retourner le prochain numéro de bloc après le dernier.\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 9\nG1\nE1 E2 E3 E4 G6\nF1 F2 F3 F4 F5 F6 F7\nG4\nG5 G2 G3"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 12,
    "text": "Déclaration d'un fichier f et de ses zones tampons buf1, buf2 (deux buffers) :\nTypeBloc = Structure // le contenu des blocs \ntab : Tableau [ b ] de TypeEnreg\nNB : eniter\nfin\nf : FICHIER de TypeBloc BUFFER buf1, buf2 ENTETE (type1, type2, ...typem);\nDans cette déclaration, il y a :\n• La description du contenu des blocs (un tableau d’enregistrement et un entier)\n• La variable f de type FICHIER \n• Deux variables buf1 et buf2, de type 'TypeBloc' qui servent comme zones tampons pour lire\net écrire les blocs du fichier.\n• La structure de l'entête du fichier, formée par m caractéristiques dont les types sont spécifiés\nLes opérations du modèle sont :\nOuvrir( f, nomfichier, mode )\n Ouverture ou création d’un fichier de nom nomfichier, selon la valeur de mode\n ‘A’ : Ouverture d’un ancien fichier en lecture/écriture. Ses caractéristiques sont chargés en MC \n (par exemple à partir du bloc d’entête d"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 12,
    "text": "r de mode\n ‘A’ : Ouverture d’un ancien fichier en lecture/écriture. Ses caractéristiques sont chargés en MC \n (par exemple à partir du bloc d’entête du fichier).\n ‘N’ : Création d’un nouveau fichier en lecture/écriture. Une zone en MC est allouée pour \n contenir ses caractéristiques, initialisées par des valeurs adéquates.\nFermer( f )\n Fermeture du fichier f, en sauvegardant ses caractéristiques sur disque (par exemple dans le bloc \n d’entête) en cas de modifications.\nLireDir(F, i, buf )\n Lecture du bloc numéro i du fichier f dans la variable buf.\nEcrireDir( F, i, buf )\n Ecriture du contenu de la variable buf dans le bloc numéro i du fichier f.\nEntete( f, i )\n Cette fonction retourne la valeur de la ième caractéristique de f. Elle ne nécessite pas d'accès disque\n car les caractéristiques ont déjà été chargés en MC par l’opération d’ouverture.\nAff_entete( f, i, val )\n Affecte la valeur va"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 12,
    "text": "ite pas d'accès disque\n car les caractéristiques ont déjà été chargés en MC par l’opération d’ouverture.\nAff_entete( f, i, val )\n Affecte la valeur val dans la ième caractéristique de f. Elle ne nécessite pas d'accès disque car \n l’affectation se fait en MC dans la zone déjà allouée par l’opération d'ouverture du fichier. \nAllocBloc( f )\n Allocation d’un nouveau bloc au fichier f. Cette fonction retourne le numéro du bloc alloué. \n Dans les fichiers formés par des blocs contigus, cette opération n'est pas nécessaire, car l'écriture \n dans un bloc juste après la fin du fichier est suffisante et est équivalente à une allocation de bloc.\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 10"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 13,
    "text": "4) Les fichiers en langage C\nEn langage C les fichiers sont vus comme une suite d'octets en MS. Dans la librairie standard (libc)\nil existe des fonctions portables manipulant les fichiers sous forme de flux à travers la structure\nFILE définie dans <stdio.h>. Les objets de type FILE seront alloués et libérés par les fonctions de\nla librairie de manière transparente au programme utilisateur. De ce fa it on manipule cette structure\nqu’à travers des indirections (pointeurs).\nLa déclaration d’une variable fichier f (de type flux) est comme suit :\nFILE *f;\nL’ouverture d’un fichier se fait comme suit :\nf = fopen(nomfichier, mode);\nnomfichier une chaîne de caractères indiquant le nom du fichier et mode une chaîne de \ncaractères indiquant le mode d'ouverture. \nPour un fichier texte, le mode peut être :\nmode explications\n« r » ouverture en lecture\n« w » création d'un nouveau fichier (écrasement de"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 13,
    "text": "ouverture. \nPour un fichier texte, le mode peut être :\nmode explications\n« r » ouverture en lecture\n« w » création d'un nouveau fichier (écrasement de l'ancien s'il existe déjà)\n« a » ouverture en mode « ajout »\n« r+ » ouverture en lecture/écriture\n« w+ » création d'un nouveau fichier en lecture/écriture\n« a+ » ouverture en mode « ajout » en lecture/écriture\n Pour un fichier binaire, le mode peut être :\nmode explications\n« rb » ouverture en lecture\n« wb » création d'un nouveau fichier (écrasement de l'ancien s'il existe déjà)\n« ab » ouverture en mode « ajout »\n« rb+ » / « r+b » ouverture en lecture/écriture\n« wb+ » / « w+b » création d'un nouveau fichier en lecture/écriture\n« ab+ » / « a+b » ouverture en mode « ajout » en lecture/écriture\nUn fichier texte\n est formé d'un ensemble de lignes terminées chacune par une marque de fin \nde ligne. Dans les systèmes de type Unix (comme Linux par "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 13,
    "text": "n fichier texte\n est formé d'un ensemble de lignes terminées chacune par une marque de fin \nde ligne. Dans les systèmes de type Unix (comme Linux par exemple), cette marque de fin \nde ligne est le caractère '\\n' (code ascii 10). Dans d'autres systèmes, la marque de fin de ligne\npeut être composée de deux caractères (comme '\\r' et '\\n'). Les fonctions de lecture et \nd'écriture sur les fichiers textes, permettent de s'abstraire de ces différences entre systèmes.\nUn fichier binaire\n est simplement une suite d'octets sans aucune interprétation particulière \nfaite par le système. Ces suites d'octets représentent les données telle qu'elles étaient \nreprésentées en MC avant leur transfert sur le fichier. De ce fait les données d'un fichier \nbinaire sont très dépendantes du système où elles ont été produites (donc généralement peu \nportables).\nLa fermeture d’un fichier:\nfclose(f);\nHidouci W.K. &"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 13,
    "text": "e sont très dépendantes du système où elles ont été produites (donc généralement peu \nportables).\nLa fermeture d’un fichier:\nfclose(f);\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 11"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 14,
    "text": "Pour savoir si on a dépassé la fin de fichier (en mode lecture) :\nfeof( f )\nRetourne vrai (entier différent de 0) si on a tenté de lire au delà de la fin de fichier\n.\nDonc le schéma général pour lire le contenu d'un fichier dans ce cas est le suivant :\nFILE *f ;\nf = fopen(...) ;\n// lecture des premières données\n<< opération_de_lecture>>\nwhile ( ! feof( f ) ) {\n// Traitement des données lus \n…\n// lecture des données suivantes\n<< opération_de_lecture>>\n}\nfclose( f ) ;\na) Lecture / Ecriture en mode binaire\nPour lire des données d'un fichier binaire, on utilise généralement 'fread' :\nnbelt_lus = fread(buf, taille_elt, nb_elt, f);\nDemande de lecture d'un nombre d'éléments consécutifs égal à nb_elt, chacun de taille \ntaille_elt octets depuis le fichier f. Le résultat de la lecture sera placé dans la zone pointée \npar buf et de taille au moins égale à taille_elt * nb_elt octets.\nLa fonction ret"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 14,
    "text": "ichier f. Le résultat de la lecture sera placé dans la zone pointée \npar buf et de taille au moins égale à taille_elt * nb_elt octets.\nLa fonction retourne le nombre d'éléments effectivement lus, qui peut donc être inférieur au \nnombre demandé (en cas de fin de fichier ou d'erreur de lecture).\nPour écrire des données dans un fichier binaire, on utilise généralement 'fwrite' :\nnbelt_ecr = fwrite(buf, taille_elt, nb_elt, f);\nDemande d'écriture d'un nombre d'éléments égal à nb_elt, chacun de taille taille_elt octets \ndans le fichier f. Les octets à écrire (au nombre de taille_elt*nb_elt) sont à récupérer depuis \nla zone mémoire pointée par buf. \nLa fonction retourne le nombre d'éléments effectivement écrits, qui peut donc être inférieur \nau nombre demandé (en cas d'erreur d'écriture).\nA chaque opération de lecture ou d’écriture, la position courante dans le fichier avance d’un nombre\nd’octe"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 14,
    "text": "mbre demandé (en cas d'erreur d'écriture).\nA chaque opération de lecture ou d’écriture, la position courante dans le fichier avance d’un nombre\nd’octets égal à celui des données lus ou écrits.\nPour modifier la position courante dans un fichier, on peut utiliser 'fseek' :\nfseek( f, deplacement, origine )  ;\nDéplace la position courante d'un nombre d'octets égal à deplacement, relativement à :\n- début du fichier, si origine vaut SEEK_SET\n- position courante, si origine vaut SEEK_CUR\n- fin du fichier, si origine vaut SEEK_END\nb) Lecture / Ecriture en mode texte\nPour lire un caractère dans un fichier texte, on peut utiliser :\n c = fgetc( f ); \nLit et retourne (type int) le prochain caractère de f ou bien la constante EOF si la fin de \nfichier a été dépassée. En cas d'erreur EOF est aussi retournée.\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 12"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 15,
    "text": "Pour écrire un caractère dans un fichier texte, on peut utiliser :\n fputc( c, f ); \nEcrit le caractère c à la position courante du fichier f.\nEn cas d'erreur, la fonction retourne (type int) la constante EOF.\nPour lire une ligne dans un fichier texte, on peut utiliser :\n fgets( buf, n, f ); \nLit dans la variable buf, tous les caractères à partir de la position courante de f, jusqu'à \ntrouver une marque de fin de ligne '\\n' (qui est aussi lue dans buf) ou alors jusqu'à ce que n-1\ncaractères soient lus. Un caractère de fin de chaîne '\\0' est rajouté à la fin de buf.\nEn cas d'erreur ou de dépassement de la fin de fichier, la fonction fgets retourne NULL.\nPour écrire une chaîne de caractères dans un fichier texte, on peut utiliser :\n fputs( buf, f ); \nEcrit tous les caractères contenus de buf (sauf le '\\0') dans le fichier f, à partir de la \nposition courante. Pour écrire une ligne, il faut "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 15,
    "text": ", f ); \nEcrit tous les caractères contenus de buf (sauf le '\\0') dans le fichier f, à partir de la \nposition courante. Pour écrire une ligne, il faut prévoir un caractère '\\n' à la fin de buf (et \navant le caractère de fin de chaîne '\\0').\nEn cas d'erreur, la fonction retourne EOF. \nPour effectuer une lecture formatée depuis un fichier texte, on peut utiliser :\nfscanf( f, format, &var1, &var2, … )\nComme scanf, sauf que les données proviennent du fichier texte f (au lieu de la console)\nPour effectuer une écriture formatée dans un fichier texte, on peut utiliser :\nfprintf( f, format, exp1, exp2, … )\nComme printf, sauf que les données iront dans le fichier texte f (au lieu de la console)\nLa position courante dans le fichier est automatiquement mise à j ours après chaque opération de\nlecture ou d’écriture, pour se positionner sur les prochains octets à lire ou à écrire de manière\nséquentiell"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 15,
    "text": " mise à j ours après chaque opération de\nlecture ou d’écriture, pour se positionner sur les prochains octets à lire ou à écrire de manière\nséquentielle.\nL’utilisation de fseek n’est pas conseillée avec les lectures/é criture en mode texte à cause des\néventuelles transformations des caractères de fin de ligne effectuées dans certains systèmes\nd’exploitation. Dans ce cas le calcul des déplacements devient un peu difficile à faire.\nc) Exemples de programmes C\nDans le programme suivant, on construit un fichier binaire contenant un certain nombre\nd'enregistrements pour une application simple de gestion d'agenda téléphonique :\n/* \n * Construction d'un fichier binaire avec n enregistrements : < nom , telephone > \n*/ \n#include <stdio.h> \nint main() \n{ \n // variable enregistrement \n struct Tenreg { \nchar nom[20]; \nchar tel[15]; \n } e; \nHidouci W.K. & Kermi A. / Généralités / Structures de Fichier"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 15,
    "text": " \n{ \n // variable enregistrement \n struct Tenreg { \nchar nom[20]; \nchar tel[15]; \n } e; \nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 13"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 16,
    "text": "// variable fichier \n FILE *f; \n char nomf[30]; \n printf( \"\\nConstruction d'un fichier agenda telephonique\\n\\n\"); \n printf( \"Donnez le nom du fichier à construire : \"); \n // un espace avant %s permet de sauter tous les caractères blancs avant de lire le nom de fichier\n scanf( \" %s\", nomf ); \n \n // creation du nouveau fichier en mode binaire\n f = fopen( nomf, \"wb\" ); \n if ( f == NULL ) { \nprintf( \"erreur lors de l'ouverture du fichier %s en mode wb\\n\", nomf ); \nreturn 0; \n } \n // lecture d'un enregistrement depuis la console \n printf( \"donnez un nom et un tel (ou 0 0 pour terminer le programme) : \" ); \n // un espace avant %s permet de sauter tous les caractères blancs avant de lire les données e.nom et e.tel\n scanf( \" %s %s\", e.nom, e.tel ); \n while ( e.nom[0] != '0' ) { \n // écriture dans le fichier \nfwrite( &e, sizeof(e), 1, f ); \n// lecture d'un enregistrement depuis la console \nprintf"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 16,
    "text": " \n while ( e.nom[0] != '0' ) { \n // écriture dans le fichier \nfwrite( &e, sizeof(e), 1, f ); \n// lecture d'un enregistrement depuis la console \nprintf( \"donnez un nom et un tel (ou 0 0 pour terminer le programme) : \" ); \n // un espace avant %s permet de sauter tous les caractères blancs avant de lire les données e.nom et e.tel\n scanf( \" %s %s\", e.nom, e.tel ); \n } \n // fermeture du fichier \n fclose( f ); \n return 0; \n}\nVoici un exemple de programme qui parcourt séquentiellement le fichier de données et affiche son \ncontenu :\n/*\n * Liste le contenu d'un fichier binaire avec enregistrements : < nom , telephone > \n*/ \n#include <stdio.h> \nint main() \n{ \n // variable enregistrement \n struct Tenreg { \nchar nom[20]; \nchar tel[15]; \n } e; \n FILE *f; // variable fichier \n char nomf[30]; \n int i; \nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 14"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 17,
    "text": "printf( \"\\nAffichage du contenu du fichier agenda telephonique\\n\\n\" ); \n printf( \"Donnez le nom du fichier à lister : \" ); \n // un espace avant %s permet de sauter tous les caractères blancs avant de lire le nom de fichier\n scanf( \" %s\", nomf ); \n // ouverture du fichier \n f = fopen( nomf, \"rb\" ); \n if ( f == NULL ) { \nprintf( \"erreur lors de l'ouverture du fichier %s en mode rb\\n\", nomf ); \nreturn 0; \n } \n \n // lecture des enregistrements depuis le fichier \n i = 1; \n fread( &e, sizeof(e), 1, f ); \n while ( ! feof(f) ) { \nprintf( \"%3d nom : %s \\t tel : %s\\n\", i++, e.nom, e.tel ); \n fread( &e, sizeof(e), 1, f ); \n } \n // fermeture du fichier \n fclose( f ); \n return 0; \n}\nLe programme suivant montre un exemple d'accès direct (avec fseek) à un enregistrement de \nposition donnée :\n/*\n * Accès direct à un enregistrement de type : < nom , telephone > \n*/ \n#include <stdio.h> \nint main() \n{ \n //"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 17,
    "text": " enregistrement de \nposition donnée :\n/*\n * Accès direct à un enregistrement de type : < nom , telephone > \n*/ \n#include <stdio.h> \nint main() \n{ \n // variable enregistrement \n struct Tenreg { \nchar nom[20]; \nchar tel[15]; \n } e; \n // variable fichier \n FILE *f; \n char nomf[30]; \n int n, i; \n printf( \"\\nAccès direct au contenu d'un fichier 'agenda telephonique'\\n\\n\" ); \n printf( \"Donnez le nom du fichier à manipuler : \" ); \n scanf( \" %s\", nomf ); \n // ouverture du fichier \n f = fopen( nomf, \"rb\" ); \n if ( f == NULL ) { \nprintf( \"erreur lors de l'ouverture du fichier %s en mode rb\\n\", nomf ); \nreturn 0; \n } \nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 15"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 18,
    "text": "printf( \"Donnez le numéro de l'enregistrement à lire : \" );\n // un espace avant %d permet de sauter tous les caractères blancs avant de lire la donnée i \n scanf( \" %d\", &i ); \n // lecture d'un enregistrement par un accès direct\n fseek( f, (i-1)*sizeof(e), SEEK_SET ); \n n = fread( &e, sizeof(e), 1, f ); \n if ( n == 1 ) // si le nombre d'enreg lus = 1 \n printf( \"enreg num:%3d \\t nom : %s \\t tel : %s\\n\", i, e.nom, e.tel ); \n // fermeture du fichier \n fclose( f ); \n return 0; \n}\nSi on avait opté pour un fichier texte, on aurait eu le programme suivant pour la construction :\n/*\n * Construction d'un fichier texte avec n enregistrements <nom,telephone> \n*/ \n#include <stdio.h> \nint main() \n{ \n // variable enregistrement \n struct Tenreg { \nchar nom[20]; \nchar tel[15]; \n } e; \n // variable fichier \n FILE *f; \n char nomf[30]; \n printf(\"\\nConstruction d'un fichier agenda telephonique\\n\\n\"); \n printf"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 18,
    "text": "20]; \nchar tel[15]; \n } e; \n // variable fichier \n FILE *f; \n char nomf[30]; \n printf(\"\\nConstruction d'un fichier agenda telephonique\\n\\n\"); \n printf(\"Donnez le nom du fichier à construire : \"); \n // un espace avant %s permet de sauter tous les caractères blancs avant de lire le nom de fichier\n scanf(\" %s\", nomf); \n // creation du nouveau fichier en mode texte \n f = fopen( nomf, \"w\" ); \n if ( f == NULL ) { \nprintf( \"erreur lors de l'ouverture du fichier %s en mode w\\n\", nomf ); \nreturn 0; \n } \n // insertion des enregistrements lus à la console \n printf( \"donnez un nom et un tel (ou 0 0 pour terminer le programme) : \" ); \n // un espace avant %s permet de sauter tous les caractères blancs avant de lire les données e.nom et e.tel\n scanf( \" %s %s\", e.nom, e.tel ); \n while ( e.nom[0] != '0' ) { \n // écriture formatée dans le fichier \n fprintf( f, \" %s , %s\\n\", e.nom, e.tel ); // un enregistr"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 18,
    "text": " %s\", e.nom, e.tel ); \n while ( e.nom[0] != '0' ) { \n // écriture formatée dans le fichier \n fprintf( f, \" %s , %s\\n\", e.nom, e.tel ); // un enregistrement par ligne \nprintf( \"donnez un nom et un tel (ou 0 0 pour terminer le programme) : \" ); \n scanf( \" %s %s\", e.nom, e.tel ); \n } \n // fermeture du fichier \n fclose( f ); \n return 0; \n} \nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 16"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 19,
    "text": "Voici un exemple de fichier texte produit par ce programme :\n $ cat agenda1.txt\n aaaaaa , 123456 \n bbbbb , 147258 \n ccccccc , 187456 \n ddd , 054963 \n eeeeee , 248269 \n fffff , 321654\nLe programme suivant permet de lire séquentiellement le fichier ainsi construit et affiche les\nenregistrements à l'écran :\n/*\n * Liste le contenu d'un fichier texte (enregistrements de type <nom,telephone>) \n*/ \n#include <stdio.h> \nint main() \n{ \n // variable enregistrement \n struct Tenreg { \nchar nom[20]; \nchar tel[15]; \n } e; \n FILE *f; // variable fichier \n char nomf[30]; \n int n, i; \n printf( \"\\nAffichage du contenu d'un fichier agenda telephonique\\n\\n\" ); \n printf( \"Donnez le nom du fichier à lister : \" ); \n scanf( \" %s\", nomf ); \n // ouverture du fichier texte en mode lecture \n f = fopen( nomf, \"r\" ); \n if ( f == NULL ) { \nprintf( \"erreur lors de l'ouverture du fichier %s en mode r\\n\", nomf ); \nreturn "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 19,
    "text": "texte en mode lecture \n f = fopen( nomf, \"r\" ); \n if ( f == NULL ) { \nprintf( \"erreur lors de l'ouverture du fichier %s en mode r\\n\", nomf ); \nreturn 0; \n } \n // lecture des enregistrements depuis le fichier \n i = 1; \n n = fscanf( f, \"%s , %s\", e.nom, e.tel ); \n if ( n == 2 ) // si le nombre d'elements lus = 2 (le nom et le tel) \n printf( \"%3d \\t nom : %s \\t tel : %s\\n\", i++, e.nom, e.tel ); \n while ( ! feof(f) ) { \n n = fscanf( f, \"%s , %s\", e.nom, e.tel ); \n if ( n == 2 ) // si le nombre d'elements lus = 2 (le nom et le tel) \n printf( \"%3d \\t nom : %s \\t tel : %s\\n\", i++, e.nom, e.tel ); \n } \n // fermeture du fichier \n fclose( f ); \n return 0; \n}\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 17"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 20,
    "text": "Voici un exemple d'affichage produit par ce programme :\nAffichage du contenu d'un fichier agenda telephonique \nDonnez le nom du fichier à lister : agenda1.txt \n 1 nom : aaaaaa tel : 123456 \n 2 nom : bbbbb tel : 147258 \n 3 nom : ccccccc tel : 187456 \n 4 nom : ddd tel : 054963 \n 5 nom : eeeeee tel : 248269 \n 6 nom : fffff tel : 321654 \nLes écritures forcées en C\nLes opérations de lecture/écriture du langage C utilisent des buffers addit ionnels comme une zone\ntampon entre le programme d'application et le buffer cache du système (voir la figure en page 7 de\nce même chapitre « Généralités »). Lors des écritures effectuées par un programme (par exemple à\nl'aide de fwrite) les données sont d'abord envoyées vers ces buffers applicatifs jusqu'à devenir pleins\nauquel cas ils seront ensuite automatiquement vider vers les buffers de l a zone tampon du système\n(toujours en MC). Au moment de la synch"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 20,
    "text": "enir pleins\nauquel cas ils seront ensuite automatiquement vider vers les buffers de l a zone tampon du système\n(toujours en MC). Au moment de la synchronisation du cache système, les données seront alors\nphysiquement écrites sur MS.\nLors de la fermeture d'un fichier ( fclose) les buffers applicatifs sont aussi vider vers la zone tampon\ndu système. L'opération fflush( f ) permet aussi de forcer le vidage du buffer applicatif de f vers la\nzone tampon système (en MC), même s'il n'était pas plein.\nDonc pour réaliser une écriture forcée\n (écriture physique vers la MS), il faut (après l’écriture des\ndonnées) d'abord vider le buffer applicatif (fflush) et ensuite synchroniser le cache système (fsync). \nCes écritures forcée sont quelquefois nécessaires pour mettre à l’abri des données critiques en les\nsauvegardant en MS avant l’occurrence d’une éventuelle panne qui pourrait effacer le contenu de"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 20,
    "text": "ires pour mettre à l’abri des données critiques en les\nsauvegardant en MS avant l’occurrence d’une éventuelle panne qui pourrait effacer le contenu de la\nMC et donc des buffers non encore synchronisés par le système d’exploitation.\n5) Conclusion\nLes prochains chapitres concernent les différents types d'organisations de fichie rs et l'étude de leur\nimpacts sur les performances. Ce sont les \" méthodes d'accès\" aux fichiers ou alors \" structures de\nfichiers\".\nVoici quelques exemples de structures de fichiers: \n- blocs contigus, enregistrements à taille fixe, non ordonné\n- liste de blocs, enregistrements à taille variable, ordonné\n- ensemble de blocs avec table d'index\n- arbre de blocs\n- blocs contigus avec fonction de hachage \n- … etc.\nCertaines structures de fichiers sont bien adaptées pour des fichiers dont l a taille reste relativement\nstable dans le temps (fichiers statiques) et d’autre"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 20,
    "text": "es structures de fichiers sont bien adaptées pour des fichiers dont l a taille reste relativement\nstable dans le temps (fichiers statiques) et d’autres peuvent supporter aus si des fichiers dynamiques\net très volumineux (B-Arbres, Hachage dynamique).\nHidouci W.K. & Kermi A. / Généralités / Structures de Fichiers / SFSD / ESI - 2024 18"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 21,
    "text": "Structures de Fichiers\nChapitre 2 Les Structures Séquentielles\n1) Organisation globale des blocs\nDans un premier temps, on étudiera deux possibilités distinctes d 'organiser les blocs au sein d'un\nfichier:\n- soit le fichier est « vu comme un tableau » : tous les blocs qui le forment sont contigus\n- soit le fichier est « vu comme une liste » : les blocs ne sont pas forcément contigus, mais sont \nchaînés entre eux.\nDans la figure ci-dessous, on a deux fichiers vus comme tableau ( E et F) et un fichier vu comme\nune liste (G). Les blocs F1, F2, … F7 sont contigus, de même pour les blocs E1, E2, E3 et E4. Par\ncontre les blocs G1, G2, … G6 ne sont pas contigus, ils sont chaînés entre eux formant une liste de\nblocs.\nParmi les caractéristiques nécessaires pour manipuler un fichier vu comme tableau, on pourra avoir\npar exemple :\n- Le numéro du premier bloc,\n- Le numéro du dernier bloc (ou alors l"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 21,
    "text": "ssaires pour manipuler un fichier vu comme tableau, on pourra avoir\npar exemple :\n- Le numéro du premier bloc,\n- Le numéro du dernier bloc (ou alors le nombre de blocs utilisés).\nDans le cas où on utilise des numéros logiques pour adresser les blocs, on n’aura pas alors besoin de\nla caractéristique ‘numéro du premier bloc’ car elle vaut toujours 1 dans ce cas.\nC’est par exemple le cas avec la machine abstraite définie dans le premier chapitre.\nPour un fichier vu comme liste, il suffirait par contre de connaître le numéro du premier bloc (la tête\nde la liste), car dans chaque bloc, il y a le numéro du prochain bloc (comme le champ suivant dans\nune liste). Dans le dernier bloc, le numéro du prochain bloc pourra être mis à une valeur spéciale\n(par exemple -1) pour indiquer la fin de la liste.\n2) Organisation interne des blocs\nLes blocs contiennent les enregistrements d'un fichier. Ces derni"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 21,
    "text": "(par exemple -1) pour indiquer la fin de la liste.\n2) Organisation interne des blocs\nLes blocs contiennent les enregistrements d'un fichier. Ces derniers (l es enregistrements) peuvent\nêtre de longueur fixe ou variable.\nHidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 19\nG1\nE1 E2 E3 E4 G6\nF1 F2 F3 F4 F5 F6 F7\nG4\nG5 G2 G3"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 22,
    "text": "Dans le cas des enregistrements de longueur fixe , chaque bloc pourra alors contenir un tableau\nd'enregistrements de même type.\nExemple: \nType Tenreg = structure // structure d'un enregistrement du fichier\nmatricule : chaine(10) // matricule : taille 10 octets\nnom : chaine(20) // nom : taille 20 octets\nage : entier // age : taille 4 octets (pour simplifier l’exemple)\nfin\nType Tbloc = structure // structure d'un bloc du fichier\ntab : tableau[ b ] de Tenreg // un tableau pouvant contenir (au max) b enreg.\nNB : entier // nombre d'enreg insérés dans tab (entre 0 et b).\nfin\nDans le cas où la taille d’un bloc physique est de 4096 octets (c-a-d 4K), on pourra par exemple\nchoisir la valeur 120 pour la constante b (la taille du champ ‘tab’) afin de minimiser l’espace perdu\ndans le bloc :\ntaille d’un enreg = 10+20+4 = 34 octets\navec b=120, le tableau ‘tab’ occupera alors 120*34 = 4080 octets\nle ch"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 22,
    "text": "minimiser l’espace perdu\ndans le bloc :\ntaille d’un enreg = 10+20+4 = 34 octets\navec b=120, le tableau ‘tab’ occupera alors 120*34 = 4080 octets\nle champ ‘NB’ est sur 4 octets (taille d’un entier sur 32 bits)\ndonc la structure ‘Tbloc’ occupe une taille de : 4080+4 = 4084 octets\ndonc l’espace perdu dans le bloc est 4096 – 4084 = 12 octets\nSi le champ ‘age’ dans la structure Tenreg et le champ ‘NB’ dans l a structure Tbloc étaient de taille\n1 octets (c-a-d des valeurs possibles entre 0 et 255 pour age et NB), on aurait pu mettre au\nmaximum b=132 enregistrements par blocs (avec un espace perdu de 3 octets par bloc) :\ntaille d’un enreg = 10+20+1 = 31 octets\navec b=132, le tableau ‘tab’ occupera alors 132*31 = 4092 octets\nle champ ‘NB’ est sur 1 octet\ndonc la structure ‘Tbloc’ occupe une taille de : 4092+1 = 4093 octets\ndonc l’espace perdu dans le bloc est 4096 – 4093 = 3 octets\nDans le cas d"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 22,
    "text": " octet\ndonc la structure ‘Tbloc’ occupe une taille de : 4092+1 = 4093 octets\ndonc l’espace perdu dans le bloc est 4096 – 4093 = 3 octets\nDans le cas des enregistrements de tailles variables , chaque enregistrement pourra par exemple,\nêtre vu comme étant une chaîne d’ \noctets ou de caractère s (de longueur variable).\nLes enregistrements peuvent être de longueur variable pour différentes raisons. Par exemple, il y a\nun ou plusieurs champs de tailles variables dans la structure d’un enregistrement, ou alors le nombre\nde champs varie d'un enregistrement à un autre, … etc. On peut représe nter les valeurs à taille\nvariable par des espaces de taille fixe (au risque d’une perte importante de l’espace de stockage),\nmais ce n’est pas toujours possible de le faire, car dans certaines situations, on ne connaît pas la\ntaille maximale que peut prendre une valeur donnée.\nPour séparer les champs entre "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 22,
    "text": "le de le faire, car dans certaines situations, on ne connaît pas la\ntaille maximale que peut prendre une valeur donnée.\nPour séparer les champs entre eux (à l'intérieur de l'enregistrement), on pourra soit utiliser un\ncaractère spécial, soit préfixer le début des champs par leur taill e. Dans l'exemple ci-dessous, on\nutilise trois (03) positions pour indiquer la taille des valeurs des champs.\n...\n|0|2|7|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|a|0|1|7|b|b|b|b|b|b|b|b|b|b|b|b|b|b|0|3|7|c|c|c|.......|c|c|.....\n <--------------------------------------------------><--------------------------------><----------....------>\n un champ sur 27 caractères un champ sur 17 caractères …..\nHidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 20"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 23,
    "text": "En utilisant un nombre fixe de positions pour représenter la taille, on a de ce fait limiter la taille\nmaximale de la valeur. Dans l’exemple précédent, avec cette codification des nombres sur 3\npositions, cela implique que la taille maximale d’un champ ne peut pas dépasser 999 caractères (ou\noctets). Si par contre la taille maximale n’est pas connue au mome nt de la conception de la\nméthode, on peut représenter la taille sur un nombre variable de positions terminée par un caractère\nspécial.\n \nDans le cas d'enregistrements à taille variable, le bloc ne pe ut pas être défini comme étant un\ntableau d'enregistrements, car les éléments d'un tableau doivent toujours être de même taille. Une\nsolution possible sera alors de considérer le bloc comme étant (ou conte nant) un grand tableau de\ncaractères de taille fixe, renfermant les différents enregistrements (stockés caractère par caractère).\nPou"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 23,
    "text": " étant (ou conte nant) un grand tableau de\ncaractères de taille fixe, renfermant les différents enregistrements (stockés caractère par caractère).\nPour séparer les enregistrements entre eux, on utilise les mêmes techniques que celles utilisées dans\nla séparation entre les champs d'un même enregistrement, soit avec un caractère spécial (ex. '$'), soit\non préfixe chaque enregistrement par sa taille.\nVoici un exemple de déclaration d'un type de bloc pouvant être utilisé dans la définition d'un fichier\nvu comme liste avec format (taille) variable des enregistrements.\nType Tbloc = structure\ntab : tableau[ b' ] de caractères // tableau de caractères pour les enreg.\nsuiv : entier // numéro du bloc suivant dans la liste\nfin\nRemarque: Même si les enregistrements sont de longueurs variables, la taille des blocs reste\ntoujours fixe.\nPour minimiser l'espace perdu dans les blocs (dans le cas : format"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 23,
    "text": "registrements sont de longueurs variables, la taille des blocs reste\ntoujours fixe.\nPour minimiser l'espace perdu dans les blocs (dans le cas : format va riable uniquement), on peut\nopter pour une organisation avec chevauchement entre deux ou plusieurs blocs:\nQuand on veut insérer un nouvel enregistrement dans un bloc non encore plein et où l'espace vide\nrestant n'est pas suffisant pour contenir entièrement cet enregistreme nt, celui-ci sera découpé en 2\nparties de telle sorte à occuper tout l'espace vide du bloc en questi on par la 1ere partie, alors que le\nreste (la 2e partie) sera insérée dans un nouveau bloc alloué au fichier. On dit alors que\nl'enregistrement se trouve à cheval entre 2 blocs\n. On peut facilement généraliser cette approche pour\nsupporter des enregistrements à cheval sur plusieurs blocs (c’est le cas des enregistrements de\ngrandes tailles, éventuellement supérieure à "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 23,
    "text": "che pour\nsupporter des enregistrements à cheval sur plusieurs blocs (c’est le cas des enregistrements de\ngrandes tailles, éventuellement supérieure à celle d’un bloc physique)\n3) Taxonomie des structures simples de fichiers\nEn combinant d’une part, entre l'organisation globale des fichiers ( vu comme tableau ou vu comme\nliste) et celle interne aux blocs ( format fixe ou variable des enregistrements) et d’autre part, en\nconsidérant la possibilité de maintenir le fichier ordonné ou non, on peut définir une classe de 12\nméthodes d'accès (dites « séquentielle ») pour organiser des données sur disque.\nUtilisons la notation suivante: \nT : pour fichier vu comme tableau, L : pour fichier vu comme liste\nO : pour fichier ordonné, O\n : pour fichier non ordonné\nF : pour format fixe des enregistrements, V : pour format variable\nC : avec chevauchement des enregistrements entre blocs, C : sans chevauch"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 23,
    "text": "n ordonné\nF : pour format fixe des enregistrements, V : pour format variable\nC : avec chevauchement des enregistrements entre blocs, C : sans chevauchement\nHidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 21"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 24,
    "text": "Les feuilles de l'arbre suivant, représentent les 12 méthodes d'accès séquentielles:\nPar exemple la méthode T O\n V C représente l'organisation d'un fichier vu comme tableau (T), non\nordonné (O), avec des enregistrements de taille variables (V) et acceptant les chevauchements entre\nblocs (C) :\nLa recherche est séquentielle, l'insertion en fin de fichier et la suppression est logique.\nDans le cas d'un fichier LOF (fichier vu comme liste , ordonné avec enregistrements à taille fixe),\nchaque bloc pourra contenir par exemple, un tableau d'enregistrements ( tab), un entier indiquant le\nnombre d'enregistrements dans le tableau ( nb) et un entier pour garder la trace du bloc suivant dans\nla liste (suiv) :\nLa recherche est séquentielle, l'insertion provoque des décalages intra-bl ocs uniquement (pour\ngarder l'ordre des enregistrements) et la suppression peut être logique ou physique.\n4) Exemple c"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 24,
    "text": "provoque des décalages intra-bl ocs uniquement (pour\ngarder l'ordre des enregistrements) et la suppression peut être logique ou physique.\n4) Exemple complet: fichier de type « TOF »\n(fichier vu comme tableau, ordonné avec enregistrements à taille fixe)\nNous ferons les choix suivants :\n● La recherche d'un enregistrement est dichotomique (rapide).\n● L'insertion peut provoquer des décalages intra et inter-blocs (coûteuse).\n● La suppression peut être réalisée par des décalages inverses (suppression physique coûteuse)\nou alors juste par un indicateur booléen (suppression logique beaucoup plus rapide). Optons \npour cette dernière alternative.\nHidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 22\nT L\nO O O O\nF V F V F V F V\nC CC CC CC C\n structures séquentielles\n1 2 3 N\ntête\nsuiv suiv suiv suivnbtab nbtab nbnbtab tab-1\n1 2 3 4"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 25,
    "text": "● L'opération du chargement initial consiste à construire un fichier ordonné avec n \nenregistrements initiaux, en laissant un peut de vide dans chaque bloc. Ce qui permettra de \nminimiser les décalages pouvant être provoqués par les futures insertions.\n● Avec le temps, le facteur de chargement du fichier (nombre d'insertions / nombre de places \ndisponibles dans le fichier) augmente à cause des insertions futures, de plus les suppressions\nlogiques ne libèrent pas de places. Donc les performances tendent à se dégrader avec le \ntemps. Il est alors conseillé de réorganiser le fichier en procédant à un nouveau chargement \ninitial. C'est l'opération de réorganisation périodique.\nDéclaration du fichier:\n Soit b = 30 // capacité maximale des blocs (en nombre d'enregistrements)\n // Les types utilisés :\nTenreg = structure // Structure d'un enregistrement :\ncle : typeqlq // le champs utilisé comme "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 25,
    "text": "(en nombre d'enregistrements)\n // Les types utilisés :\nTenreg = structure // Structure d'un enregistrement :\ncle : typeqlq // le champs utilisé comme clé de recherche\nchamp2 : typeqlq // les autres champs de l'enregistrement,\nchamp3 : typeqlq // … (sans importance pour la suite)\n… // … \nFin\nTbloc = structure // Structure d'un bloc :\ntab : tableau[ b ] de Tenreg // tableau d'enreg d'une capacité maximal = b\neff : tableau[ b ] de booleen // indicateurs pour la suppression logique\nNB : entier // nombre d'enreg dans tab ( ≤ b)\nFin\n// Les variables globales : F et buf \nF : Fichier de Tbloc Buffer buf Entete (entier, entier)\n/* Description de l'entête du fichier F :\n L'entête contient deux caractéristiques de type entier.\n- la première sert à garder la trace du nombre de bloc utilisés (ou alors le \n numéro logique du dernier bloc du fichier)\n- la deuxième servira comme un compteur d'insertions"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 25,
    "text": "der la trace du nombre de bloc utilisés (ou alors le \n numéro logique du dernier bloc du fichier)\n- la deuxième servira comme un compteur d'insertions pour pouvoir calculer \n rapidement le facteur de chargement, et donc voir s'il y a nécessité de \n réorganiser le fichier.\n*/\nModule de recherche: (dichotomique)\nen entrée la clé (c) à chercher. \nen sortie le booleen Trouv, le numéro de bloc (i) contenant la clé et le déplacement (j)\nRech( c : typeqlq , var Trouv : bool , var i , j :entier ) \nvar \n bi, bs, inf, sup : entier\n trouv, stop : booleen\nHidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 23"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 26,
    "text": "DEBUT\n /* on suppose que le fichier est déjà ouvert */ \n bs ← entete( F,1 ) // la borne sup (le num du dernier bloc de F) \n bi ← 1 // la borne inf (le num du premier bloc de F)\n// boucle pour la recherche dichotomique externe (dans le fichier F)\n Trouv ← faux; stop ← faux; j ← 1\n TQ ( bi ≤ bs et Non Trouv et Non stop )\n i ← (bi + bs) div 2 // le bloc du milieu entre bi et bs\n \nLireDir( F, i, buf )\n SI ( c ≥ buf.tab[1].cle et c ≤ buf.tab[ buf.NB ].cle )\n // boucle pour la recherche dichotomique interne dans le bloc i (dans buf)\n inf ← 1; sup ← buf.NB\n TQ (inf ≤ sup et Non Trouv) // recherche interne\n j ← (inf + sup) div 2 \n SI (c = buf.tab[ j ].cle) Trouv ← vrai \n SINON \n SI (c < buf.tab[ j ].cle) sup ← j-1\n SINON inf ← j+1\n FSI\n FSI\n FTQ\nSI ( inf > sup ) \nj ← inf \nSINON\nSI ( buf.eff[ j ] ) Trouv ← faux FSI // en cas d’effacement logique, retourner faux\nFSI\n// fin de la recherche interne."
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 26,
    "text": " ( inf > sup ) \nj ← inf \nSINON\nSI ( buf.eff[ j ] ) Trouv ← faux FSI // en cas d’effacement logique, retourner faux\nFSI\n// fin de la recherche interne.\n // j : la position où devrait se trouver c dans buf.tab\nstop ← vrai\n SINON // non ( c ≥ buf.tab[1].cle et c ≤ buf.tab[ buf.NB ].cle )\n SI ( c < buf.tab[1].cle )\n bs ← i-1\n SINON // donc c > buf.tab[ buf.NB ].cle\n bi ← i+1\n FSI\n FSI\n FTQ\nSI ( bi > bs ) i ← bi ; j ← 1 FSI // fin de la recherche externe.\n // i : num du bloc où devrait se trouver c\nFIN // Recherche\nLe coût de l’opération de recherche est logarithmique car la recherche dic hotomique effectue, dans\nle cas le plus défavorable, log 2 N lectures de blocs pour un fichier de taille N blocs. La complexité\nest O( log N).\nModule d'insertion: (avec éventuellement des décalages intra et inter blocs)\nDans cette solution, on essayera d’abord de réutiliser l’emplacement d’un enreg effacé lo"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 26,
    "text": "on: (avec éventuellement des décalages intra et inter blocs)\nDans cette solution, on essayera d’abord de réutiliser l’emplacement d’un enreg effacé logiquement,\navant de consommer un nouvel espace libre en fin de blocs (ou en fin de fichier).\nInserer( e:Tenreg , nomfich:chaine )\nvar \n trouv, continu, stop, reutilisation : booleen\n i,j,k : entier\n e,x : Tenreg\nHidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 24"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 27,
    "text": "Hidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 25"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 28,
    "text": "DEBUT\n Ouvrir( F,nomfich, 'A') \n // on commence par rechercher la clé e.cle avec le module précédent pour localiser l'emplacement (i,j)\n // où doit être insérer e dans le fichier.\n Rech( e.cle, nomfich, trouv, i, j )\n reutilisation ← faux // indicateur de réutilisation d’un emplacement effacé logiquement\n SI ( Non trouv ) // e doit être inséré dans le bloc i à la position j \n continu ← vrai // en décalant les enreg j, j+1, j+2, ... vers le bas\n// si i est plein, le dernier enreg de i doit être inséré dans i+1\n TQ ( continu ) // si le bloc i+1 est aussi plein son dernier enreg sera \n // inséré dans le bloc i+2, etc ... donc une boucle TQ.\n // faire les décalages internes, jusqu’à trouver un enreg effacé ou la fin du bloc ...\nstop ← faux\nTQ ( non stop et j ≤ buf.NB )\n x ← buf.tab[ j ] ; buf.tab[ j ] ← e\nSI ( buf.eff[ j ] ) \nstop ← vrai\nSINON \ne ← x ; j++ \nFSI\nFTQ\nSI ( stop ) // il y a un e"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 28,
    "text": " non stop et j ≤ buf.NB )\n x ← buf.tab[ j ] ; buf.tab[ j ] ← e\nSI ( buf.eff[ j ] ) \nstop ← vrai\nSINON \ne ← x ; j++ \nFSI\nFTQ\nSI ( stop ) // il y a un enreg effacé dans le bloc i\nbuf.eff[ j ] ← faux // donc on utilise son emplacement j\nreutilisation ← vrai\nEcrireDir( F, i, buf )\ncontinu ← faux\nSINON // il n’y a pas d’enreg effacé dans le bloc i\nSI ( buf.NB < b ) // mais il y a de la place libre \nbuf.tab[ j ] ← e ; buf.eff[ j ] ← faux ; buf.NB++\nEcrireDir( F, i, buf )\ncontinu ← faux\nSINON // pas d’enreg effacé et pas de place libre dans le bloc i\nEcrireDir( F, i, buf )\ni++ ; j ← 1 // donc décalage vers le bloc i+1 (s’il existe)\nSI ( i ≤ entete(F,1) ) \nLireDir( F, i, buf )\nSINON\ncontinu ← faux\nFSI\nFSI\nFSI\n FTQ // continu\n // si on dépassé la fin de fichier, on rajoute un nouveau bloc contenant un seul enregistrement e\n SI i > entete( F, 1 )\n buf.tab[1] ← e ; buf.eff[1] ← faux ; buf.NB ← 1\n \n"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 28,
    "text": "n de fichier, on rajoute un nouveau bloc contenant un seul enregistrement e\n SI i > entete( F, 1 )\n buf.tab[1] ← e ; buf.eff[1] ← faux ; buf.NB ← 1\n \nEcrireDir( F, i, buf ) // il suffit d'écrire un nouveau bloc à cet emplacement\n Aff-entete( F, 1, i ) // on sauvegarde le num du dernier bloc dans l'entete 1\n FSI\n// on incrémente le compteur d'insertions uniquement si on n’a pas réutilisé un emplacement effacé\nSI ( non reutilisation) Aff-entete( F, 2 , entete(F,2)+1 ) FSI\n FSI\n Fermer( F )\nFIN // insertion\nL’opération d’insertion peut nécessiter dans le cas le plus défavorable, de s décalages inter-blocs qui\nse propagent jusqu’à la fin du fichier. Comme chaque décalage coûte une lect ure et une écriture de\nbloc (c-a-d 2 accès disques), le coût total d’une insertion, en pire cas , est au voisinage de 2N accès\ndisques pour un fichier formé de N blocs plus le coût de la recherche (log2 N lect"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 28,
    "text": "t total d’une insertion, en pire cas , est au voisinage de 2N accès\ndisques pour un fichier formé de N blocs plus le coût de la recherche (log2 N lectures). La\ncomplexité est donc O(N).\nHidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 26"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 29,
    "text": "La suppression logique consiste à rechercher l'enregistrement et positionner le champs 'effacé' à \nvrai :\nSuppression( c:typeqlq; nomfich:chaine )\nvar\n trouv : booleen\n i,j : entier\nDEBUT\n Ouvrir( F,nomfich, 'A')\n // on commence par rechercher la clé c pour localiser l'emplacement (i,j) de l'enreg à supprimer\n Rech( c, nomfich, trouv, i, j )\n // ensuite on supprime logiquement l'enregistrement\n SI ( trouv ) \n// Après Rech(...) buf contient déjà le contenu du bloc i (ce n’est donc pas la peine de le relire une 2e fois)\nbuf.eff[j] ← VRAI\nEcrireDir( F, i, buf )\n FSI\n Fermer( F )\nFIN // suppression\nLa suppression logique coûte une seule écriture de bloc, en plus du coût de l a recherche (log 2 N\nlectures) pour un fichier de N blocs. La complexité est donc celle de la recherche O( log N ).\nLe chargement initial d'un fichier ordonné consiste à construire un nouveau fichier contenant dès\nle dép"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 29,
    "text": "té est donc celle de la recherche O( log N ).\nLe chargement initial d'un fichier ordonné consiste à construire un nouveau fichier contenant dès\nle départ n enregistrements. Ceci afin de laisser un peu de vide dans chaque bloc, qui pourrait être\nutilisé plus tard par les nouvelles insertions tout en évitant les dé calages inter-blocs (très coûteux en\naccès disque) :\nChargement_Initial( nomfich : chaine; n : entier; u : reel )\n// u est un réel dans ]0,1] et désigne le taux de chargement voulu au départ\nvar\n e : Tenreg\n i,j,k : entier\nDEBUT\nOuvrir( F, nomfich, 'N' ) // un nouveau fichier \n i ← 1 ; j ← 1 // i : num de bloc à remplir et j : num d'enreg dans le bloc\n ecrire( 'Donner les enregistrements en ordre croissant suivant la clé : ' )\n POUR k←1 , n\n lire( e )\n SI ( j ≤ u*b ) // ex: si u=0.5, on remplira les bloc jusqu'à b/2 enreg \n buf.tab[ j ] ← e ; buf.eff[ j ] ← faux ; j ← j+1\n SINON"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 29,
    "text": "R k←1 , n\n lire( e )\n SI ( j ≤ u*b ) // ex: si u=0.5, on remplira les bloc jusqu'à b/2 enreg \n buf.tab[ j ] ← e ; buf.eff[ j ] ← faux ; j ← j+1\n SINON // j > u*b : buf doit être écrit sur disque\n buf.NB ← j-1\n \nEcrireDir( F, i, buf )\n buf.tab[1] ← e // le kème enreg sera placé dans le prochain bloc, à la position 1\n buf.eff[ 1 ] ← faux\ni ← i+1 ; j ← 2\n FSI\n FP\n // à la fin de la boucle, il reste des enreg dans buf qui n'ont pas été sauvegardés sur disque\n buf.NB ← j-1\n \nEcrireDir( F, i, buf )\n // mettre à jour l'entête (le num du dernier bloc et le compteur d'insertions)\n Aff-entete( F, 1, i )\nAff-entete( F, 2, n )\n Fermer( F )\nFIN // chargement-initial\n \nHidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 27"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 30,
    "text": "Le chargement initial avec n enregistrements, nécessite la création d’un fichier formé de n / (b*u)\nblocs (donc n / (b*u) écritures ) avec b la capacité maximale d’un bloc et u le facteur de chargement\nsouhaité (un réel entre 0 et 1).\nLa réorganisation du fichier consiste à recopier les enregistrements vers un nouveau fichi er de\ntelle sorte à ce que les nouveaux blocs contiennent un peu de vide (1-u). Cet te opération ressemble\nau chargement initial sauf que les enregistrements sont lus à partir de l'ancien fichier.\nFusion de 2 fichiers ordonnés (TOF)\nOn parcourt les 2 fichiers ( F1 et F2) ensemble avec 2 buffers ( buf1 et buf2) et on rempli un 3e\nbuffer (buf3) pour construire un 3e fichier (F3) en ordre croissant.\nLes déclarations sont celles utilisées dans les fichier TOF standards.\nFusion (nom1,nom2, nom3: chaine)\nvar F1 : Fichier de Tbloc Buffer buf1 Entete( entier, entier)\n F2 : Fi"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 30,
    "text": "lles utilisées dans les fichier TOF standards.\nFusion (nom1,nom2, nom3: chaine)\nvar F1 : Fichier de Tbloc Buffer buf1 Entete( entier, entier)\n F2 : Fichier de Tbloc Buffer buf2 Entete( entier, entier)\n F3 : Fichier de Tbloc Buffer buf3 Entete( entier, entier)\n i1, i2, i3, j1, j2, j3, i, j, indic : entier \n continu : booleen\n e, e1, e2 : Tenreg\n buf : Tbloc\nDebut\n Ouvrir(F1, nom1, 'A' ) ; Ouvrir(F2, nom2, 'A' ) ; Ouvrir(F3, nom3, 'N' )\n i1←1; i2←1; i3 ←1 // les num de blocs de F1, F2 et F3\n j1←1; j2←1; j3 ←1 // les num d'enreg dans buf1, buf2 et buf3\n LireDir(F1, 1, buf1) ; LireDir(F2, 1, buf2) ;\n continu ← vrai \n TQ ( continu ) // tant que non fin de fichier dans F1 et F2 faire\n SI ( j1 ≤ buf1.NB et j2 ≤ buf2.NB )\n // choisir le plus petit enreg, dans buf1 et buf2\n e1←buf1.tab[ j1 ] ; e2 ← buf2.tab[ j2 ] \n SI ( e1.cle ≤ e2.cle ) e ← e1; j1← j1 + 1 SINON e ← e2; j2← j2 + 1 FSI\n // et le m"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 30,
    "text": "enreg, dans buf1 et buf2\n e1←buf1.tab[ j1 ] ; e2 ← buf2.tab[ j2 ] \n SI ( e1.cle ≤ e2.cle ) e ← e1; j1← j1 + 1 SINON e ← e2; j2← j2 + 1 FSI\n // et le mettre dans buf3\n SI ( j3 ≤ b ) \nbuf3.tab[ j3 ] ← e; j3 ← j3 + 1\n SINON \nbuf3.NB ← j3 – 1 ; \nEcrireDir(F3, i3, buf3 ); i3 ← i3 + 1 ; buf3.tab[1] ← e ; j3 ← 2\n FSI\n SINON // c-a-d : non ( j1 ≤ buf1.NB et j2 ≤ buf2.NB )\n // si tous les enreg d'un des blocs (buf1 ou buf2) ont été traités, passer au prochain\n SI ( j1 > buf1.NB )\n SI ( i1 < entete(F1, 1) ) \n i1 ← i1 + 1 ; \nLireDir( F1, i1, buf1 ) ; j1 ← 1\n SINON // ( donc i1 ≥ entete(F1, 1) )\n continu ← faux ; N ← entete(F2,1) ; buf ← buf2 ; Indic ← 2 ; i ← i2 ; j ← j2 // pour le 2e TQ\nFSI // ( i1 < entete(F1, 1) )\n SINON // c-a-d ( j2 > buf2.NB )\n SI ( i2 < entete(F2, 1) ) \n i2 ← i2 + 1 ; LireDir( F2, i2, buf2 ); j2 ← 1\n SINON // ( donc i2 ≥ entete(F2, 1) )\n continu ← faux ; N ← entete(F1,1) ; b"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 30,
    "text": "SI ( i2 < entete(F2, 1) ) \n i2 ← i2 + 1 ; LireDir( F2, i2, buf2 ); j2 ← 1\n SINON // ( donc i2 ≥ entete(F2, 1) )\n continu ← faux ; N ← entete(F1,1) ; buf ← buf1 ; Indic ← 1 ; i ← i1 ; j ← j1 // pour le 2e TQ\n FSI // ( i2 < entete(F2, 1) )\n FSI // ( j1 > buf1.NB )\n FSI // ( j1 ≤ buf1.NB et j2 ≤ buf2.NB )\n FTQ // continu\nHidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 28"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 31,
    "text": "// Le 2e TQ pour continuer à recopier les enregistrements d'un seul fichier (i,j,buf) dans F3\n continu ← vrai;\n TQ ( continu ) // tant que non fin de fichier dans F1 ou F2 faire\n SI ( j ≤ buf.NB )\nSI ( j3 ≤ b )\nbuf3.tab[ j3 ] ← buf.tab[ j ]; j3 ← j3 + 1\nSINON\nbuf3.NB ← j3 – 1\nEcrireDir(F3, i3, buf3 )\ni3 ← i3 + 1\nbuf3.tab[1] ← buf.tab[ j ]\nj3 ← 2\nFSI // ( j3 ≤ b )\nj ← j + 1\n SINON // c-a-d non ( j ≤ buf.NB )\nSI ( i ≤ N )\ni ← i + 1\nSI ( Indic = 1 )\nLireDir( F1, i, buf )\nSINON\nLireDir( F2, i, buf )\nFSI\nj ← 1\nSINON\ncontinu ← faux\nFSI\n FSI // ( j ≤ buf.NB )\n FTQ\n // Le dernier buffer (buf3) n'a pas encore été ecrit sur disque ...\n buf3.NB ← j3 – 1\n EcrireDir( F3 , i3, buf3 )\n Aff-entete( F3, 1, i3) // le nombre de blocs dand F3\n Aff-entete( F3, 2, entete(F1,1) + entete(F2,1) ) // le nombre d'enregistrements dans F3\n Fermer( F1 ) ; Fermer( F2 ) ; Fermer( F3 )\nFin\n \nL’opération de fusion de 2 f"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 31,
    "text": "2, entete(F1,1) + entete(F2,1) ) // le nombre d'enregistrements dans F3\n Fermer( F1 ) ; Fermer( F2 ) ; Fermer( F3 )\nFin\n \nL’opération de fusion de 2 fichiers F 1 et F 2 de tailles respectives N 1 et N 2 blocs, nécessite le\nparcours complet de 2 fichiers (soit N1 + N2 lectures) et la création du fichier résultat (F 3) formé par\nN1 + N2 blocs (soit N 1 + N2 écritures), en supposant un même facteur de chargement pour les trois\nfichiers. Le coût total de la fusion est donc 2N1 + 2N2 accès disques.\nSi les fichiers F1 et F2 était de même taille (N blocs chacun), le coût total de la fusi on serait alors de\n4N accès disques (2N lectures et 2N écritures). \nLa complexité de la fusion est donc en O(N).\nHidouci W.K. & Kermi A. / Les structures séquentielles / Structures de Fichiers (SFSD) / ESI - 2024 29"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 32,
    "text": "Structures de Fichiers\nChapitre 3 Fichiers avec index\n1) Introduction\nAvec les structures de fichiers séquentiels, quand le fichier de données devient volumineux, les\nopérations d'accès (recherche, insertion, ...) deviennent inefficaces.\nLes méthodes d'index permettent d'améliorer, dans une certaine mesure, les performances en gérant\nune structure auxiliaire (table d'index) accélérant la recherche d’enregistrements.\nUn index\n est (généralement) une table ordonnée en mémoire centrale ( MC) contenant\nprincipalement des couples < clé , adr > , utilisée pour accélérer la recherche des enregistrements\nd'un fichier. Le champs ' clé' représente un attribut (ou groupe d’attributs) d’un enregistrements du\nfichier et utilisé(s) pour la recherche. On appelle ce genre d’attribut une clé de recherche (Search\nKey). Cela peut être n’importe quel attribut, à valeurs uniques ou non . Le champs ' adr' rep"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 32,
    "text": "appelle ce genre d’attribut une clé de recherche (Search\nKey). Cela peut être n’importe quel attribut, à valeurs uniques ou non . Le champs ' adr' représente\nles informations de localisation d’un enregistrement dans le fichier (par exemple : <numBloc,\ndeplacement>). On peut aussi mettre dans l’index d'autres informations qui pourraient êt re utiles\npour la gestion du fichier, comme par exemple un booléen indiquant les effa cements logiques, la\ntaille occupé par l'enregistrement (surtout dans le cas avec 'format variable'), … etc.\nUn index est dit « dense » (Non Clustered Index) s'il contient toutes les valeurs de l’attribut clé\ndu fichier de données. Dans ce cas, on n'a pas besoin de garder le fichier ordonné sur cet attribut.\nUn index est dit « non dense » (Clustered Index) s'il ne contient pas toutes les valeurs de\nl’attribut clé du fichier de données (par exemple, on ne garde dans l’i"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 32,
    "text": "dit « non dense » (Clustered Index) s'il ne contient pas toutes les valeurs de\nl’attribut clé du fichier de données (par exemple, on ne garde dans l’index qu’une seule valeur par\nbloc ou groupe de blocs). Dans ce cas le fichier doit être ordonné \nsur l’attribut indexé . L'avantage\nd'un index non dense est sa taille (plus petite que celle d'un index dense pour le même fichier de\ndonnées). Voir schéma ci-dessus.\nDans le fichier de données, les valeurs de l’attribut indexé (la clé de recherche) peuvent être\nuniques (toutes les valeurs sont distinctes), ou alors multiples (non uniques, c-a-d qu’il existe des\nenregistrements différents pouvant avoir la même valeur pour l’attribut indexé). Dans ce dernier\ncas, à chaque entrée dans la table d’index est associé une liste d’adresses. On peut aussi dupliquer la\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 32,
    "text": "x est associé une liste d’adresses. On peut aussi dupliquer la\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 30\n a1, b1, c1\n a2, b2, c3\n a3, b1, c1\n a4, b3, c2\n a5, b2, c4\n a6, b4, c1\n a7, b2, c4\n a8, b5, c5\n a9, b4, c1\n \n a10, b7, c1\n a11, b2, c5\n a12, b4, c6\n a98, b2, c31\n a99, b6, c11 … … \n1 2 3 4 N\n a3 | [1 , 3]\n a7 | [2 , 4]\n a9 | [3 , 2] \n a12 | [4 , 3]\n … | … \n a99 | [N , 2]\n A | B | C A | B | C A | B | C A | B | C A | B | C\nclé | adr Fichier de données ordonné selon l’attribut A (les enreg sont formés par 3 attributs : A, B et C)\nIndex non dense sur A"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 33,
    "text": "valeur de l’attribut clé, dans la table d’index, en autant d’entrées que de valeurs multiples, chacune\navec son adresse associée. Le schéma ci-dessous montre les deux poss ibilités de représentation des\nvaleurs multiples (dans cet exemple la clé v se répète dans trois enregistrements localisés aux\nadresses a1, a2 et a3 du fichier de données).\n2) Méthode avec index à un niveau\nPour accélérer les opérations d’accès sur un fichier de données F, on peut maintenir en mémoire\ncentrale (MC) une table d’index portant sur l’attribut (champs) utilisé comme clé de recherche (l’un\ndes attributs des enregistrements de F). S’il existe plusieurs attributs ( A1, A2, A3, ... ) pouvant être\nutilisés comme des clés de recherche, on peut aussi maintenir plus ieurs index\n différents : IndexA1,\nIndexA2, IndexA3, … (un sur chaque attribut clé). \nSi de plus le fichier F est ordonné selon un des attributs clés ("
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 33,
    "text": "eurs index\n différents : IndexA1,\nIndexA2, IndexA3, … (un sur chaque attribut clé). \nSi de plus le fichier F est ordonné selon un des attributs clés (par exemple sur A1), l’index associé\n(IndexA1) sera dit « primaire » ou alors «  Clustering Index » et les autres ( IndexA2, IndexA3, …)\nseront « secondaires » ou bien «  Non clustering indexes  ». Dans ce cas ( F est ordonné selon\nl’attribut A1), IndexA1 sera donc non dense alors que IndexA2, IndexA3, … seront des index denses.\nIl est à rappeler que dans le cas d’un fichier ordonné, l'opération d'insert ion peut être coûteuse à\ncause des décalages inter-blocs générés. La suppression est généraleme nt logique pour éviter les\ndécalages inverses. Des réorganisations périodiques sont aussi à prévoir. On peut aussi maintenir\nune zone de débordement pour le fichier de données afin d’éviter les décalages inter-bloc lors des\ninsertions, mais avec "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 33,
    "text": "oir. On peut aussi maintenir\nune zone de débordement pour le fichier de données afin d’éviter les décalages inter-bloc lors des\ninsertions, mais avec le nombre des insertions qui augmente dans le temps , les performances de la\nrecherche se dégradent, malgré la présence de l’index, à cause du parcours sé quentiel dans la zone\nde débordement, nécessitant donc aussi des réorganisations périodiques.\n- Fichier d’index\nPour ne pas avoir à reconstruire la table d'index à chaque démarrage, on pe ut sauvegarder la table\ndans un fichier (dit «  fichier index ») en fin de traitement par exemple. Celui-ci sera rechargé en\nMC dans une table lors de la prochaine session. Généralement le chargement de la table d’index\ndepuis un fichier index est beaucoup plus rapide que de reconstruire la table à partir du fichier de\ndonnées (surtout si ce dernier n’est pas ordonné).\nIl est à noter que les opérations d"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 33,
    "text": "plus rapide que de reconstruire la table à partir du fichier de\ndonnées (surtout si ce dernier n’est pas ordonné).\nIl est à noter que les opérations d’accès au fichier de données (recherche, insertion, suppression …)\nutilisent uniquement la table d’index en MC et le fichier de données en MS. Le fichier d’index en\nMS n’est ni consulté, ni mis-à-jour durant ces opérations. \nLes fichiers de données et d'index peuvent être de n'importe quelle structure (blocs contigus, blocs\nchaînés, ...). De même que les enregistrements peuvent être à format fixe ou variable (avec ou sans\nchevauchement).\nLa figure ci-dessous montre les différentes structures utilisées dans un exemple de méthode d’accès\navec un seul index.\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 31\na1 a2 a3 v v a2\n v a1\n v a3\n… .\n… .\n… .\n… .\nTable d’index avec une seule entrée par valeur multip"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 33,
    "text": "ndex / Structures de fichiers (SFSD) / ESI - 2024 31\na1 a2 a3 v v a2\n v a1\n v a3\n… .\n… .\n… .\n… .\nTable d’index avec une seule entrée par valeur multiple Table d’index avec plusieurs entrées pa r valeur multiple\ni\ni+1\ni+2\ni"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 34,
    "text": "Les opérations de base\na) Cas d'un fichier de données non ordonné (index dense\n) :\n- La recherche d'un enregistrement consiste à faire une recherche dichotomi que de sa clé dans la\ntable d'index en MC, si elle existe, on récupère l'enregistrement à partir du fichier de donnée avec\nun seul accès disque.\n=> coût de l'opération : 1 accès disque (ou moins, si la clé n’existe pas dans l’index).\n- La requête à intervalle consiste à rechercher tous les enregistreme nts dont la valeur du champs clé\nappartient à un intervalle de valeurs donné : [a,b]. \n1. On commence par rechercher la plus petite clé ≥ a dans l'index (recherche dichotomique\ndans la table en MC). \n2. Puis on continue séquentiellement dans la table (en MC) jusqu'à trouver une clé > b. \n3. Pour chaque clé, on accède au fichier de données pour récupérer le (ou le s)\nenregistrement(s) associés. Ce dernier point peut être amélioré si o"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 34,
    "text": " \n3. Pour chaque clé, on accède au fichier de données pour récupérer le (ou le s)\nenregistrement(s) associés. Ce dernier point peut être amélioré si on tri les numéros de blocs\ntrouvés avant d'accéder au fichier de données (afin de ne pas lire, éventue llement, deux fois\nle même bloc).\n=> coût de l'opération en nombre d'accès : le nombre d’enregistrements vérifia nt la requête (dans le\ncas le plus défavorable).\n- L'insertion d'un nouvel enregistrement se fait au niveau du fichier de données selon sa structure et\norganisation, ensuite la valeur de son attribut indexé (la clé de recherche ) est utilisée pour mettre à\njour la table d'index (en MC). Si la valeur de la nouvelle clé n’existe pas dans la table, une nouve lle\nentrée est alors ajoutée à la table (avec les décalages nécessa ires pour maintenir l’ordre des valeurs\nde clé dans la table). Si par contre, la clé existe déjà dans la tab"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 34,
    "text": "ée à la table (avec les décalages nécessa ires pour maintenir l’ordre des valeurs\nde clé dans la table). Si par contre, la clé existe déjà dans la table (cas des valeurs multiples), la\nnouvelle localisation de l’enregistrement dans le fichier de données est alors rajoutée à la liste des\nadresses associée.\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 32\nc (i,j)\n c' (i', j')\nc' | xxx\nc | yyy\nTable d'index en MC\nFichier index \n(de sauvegarde)\nen MS\nFichier de données en MS\nClé Adr\ni'\ni\nj'\nj"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 35,
    "text": "=> coût de l'opération : le nombre d’accès disques nécessaires pour l’inse rtion de l’enregistrement\ndans le fichier de donnée non ordonné (la m-à-j de la table d’index ne coûte aucun accès disque).\n- La suppression s’effectue, éventuellement, au niveau du fichier de données (suppression physique\nou logique), ensuite la table d'index est mise à jours soit en suppri mant (par décalages) l’entrée\nassociée à la valeur de la clé (lorsque la clé est à valeurs uniques), soit en supprimant un élément de\nla liste des adresses (lorsque la clé est valeurs multiples). Dans ce dernier cas, si la liste des adresses\ndevient vide, l’entrée associée est aussi supprimée de la table par décalages.\nOn peut aussi opter pour positionner uniquement un indicateur d’effacement a u niveau de la table\nd’index pour ne pas avoir à effectuer les décalages en MC. \n=> coût : le nombre d’accès disques nécessaires pour "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 35,
    "text": " d’effacement a u niveau de la table\nd’index pour ne pas avoir à effectuer les décalages en MC. \n=> coût : le nombre d’accès disques nécessaires pour la suppression de l’enre gistrement dans le\nfichier de donnée non ordonné (la m-à-j de la table d’index ne coûte aucun accès disque).\nb) Cas d'un fichier de données ordonné (donc généralement un index non dense\n) :\nSi le fichier de données est ordonné, on peut garder dans la table d'index que certaines valeurs de\nclé. Par exemple une clé par bloc (ou groupe de blocs), on choisit soit l a plus grande ou la plus\npetite de chaque groupe. C'est alors un index non dense (car il ne contient pas toutes les clés). Cela\npermet de diminuer considérablement la taille de la table d'index tout en gardant pratiquement les\nmêmes performances de recherche qu'une méthode d'index avec fichier non ordonné (s i le nombre\nde blocs par groupe est petit, par exem"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 35,
    "text": "ratiquement les\nmêmes performances de recherche qu'une méthode d'index avec fichier non ordonné (s i le nombre\nde blocs par groupe est petit, par exemple un bloc par groupe).\nL'insertion risque par contre d’être coûteuse lorsque le fichier est formé pa r des blocs contigus ( vu\ncomme tableau ), à cause des décalages dans le fichier de données s’il n’y a pas de zone de\ndébordement. \n- La recherche d'un enregistrement consiste à faire une recherche dichotomique dans la table\nd'index, puis on continue séquentiellement dans un des groupes de blocs du fichier de données.\n=> coût de l'opération : 1 accès disque (si chaque groupe est formé d’un seul bloc) .\n- Pour la requête à intervalle (clé de recherche Î [a,b]), on procède comme suit :\n1- On commence par rechercher la plus petite clé ≥ a dans l'index (recherche dichotomique en MC).\n2- Puis on accède au fichier de données à partir du numéro d"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 35,
    "text": "mmence par rechercher la plus petite clé ≥ a dans l'index (recherche dichotomique en MC).\n2- Puis on accède au fichier de données à partir du numéro de bloc spécifié dans l'index et on \ncontinue séquentiellement dans le fichier jusqu'à trouver une clé > b. \n=> coût de l'opération en nombre d'accès se rapproche du nombre de clés vérifiant la requête divisé \npar la capacité moyenne d’un bloc (c’est un cas favorable).\n- L'insertion d'un nouvel enregistrement se fait dans le fichier de donnée s ou alors en zone de\ndébordement (voir plus bas un exemple) en utilisant l’algorithme associé à la structure du fichier\n(vu comme tableau ou comme liste, format fixe ou variable ...) . La t able d'index (en MC) est alors\nmise à jour à chaque fois que le représentant d’un groupe a changé suite aux déplacements\nd’enregistrements (les décalages, les éclatement ...) occasionnés pa r l'insertion du nouvel\ne"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 35,
    "text": "eprésentant d’un groupe a changé suite aux déplacements\nd’enregistrements (les décalages, les éclatement ...) occasionnés pa r l'insertion du nouvel\nenregistrement dans le fichier.\n=> coût de l'opération : celui de l’insertion dans le fichier de données associé\n- La suppression est généralement logique dans le fichier de données, sauf dans le cas d’un fichier \nvu comme liste et sans chevauchement inter-blocs auquel cas la suppression physique devient \nenvisageable (car peu coûteuse). La table d’index est rarement mise-à-jour.\n=> coût : celui de la suppression dans le fichier de données associé\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 33"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 36,
    "text": "Gestion d'une zone de débordement \nDans le cas d’un fichier ordonné vu comme tableau, une alternatives aux décalages inter-blocs lors\ndes insertions (et des suppressions physiques), serait de maintenir une z one de débordement pour y\nstocker, de manière simple, les enregistrements expulsés des blocs pleins du fichier de données. \nA chaque insertion, si le bloc du fichier de données est plein, les enre gistrements en surplus, seront\ninsérés dans des blocs de débordements, chaînés au bloc principal pour mainte nir l'ordre des clés.\nAu niveau de la table d'index, on met à jour la clé maximale (le représentant du groupe : la première\nou la dernière clé du groupe) si elle vient à changer suite à l'insertion.\nLes performances reste bonnes tant que la longueur des listes de blocs en débordement reste petite.\nLorsque les groupes sont formés d’un seul bloc chacun, les coûts des opérations sont pr"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 36,
    "text": "e la longueur des listes de blocs en débordement reste petite.\nLorsque les groupes sont formés d’un seul bloc chacun, les coûts des opérations sont pratiquement\nles mêmes que dans le cas d'un fichier non ordonné avec index, plus un surcoût égal à la longueur\nmoyenne des listes en débordement.\nSi les blocs en débordement deviennent trop nombreux (les listes s'allongent ), il faut réorganiser le\nfichier en créant un nouveau fichier principal, éventuellement plus grand s ’il y a eu beaucoup\nd’insertions et peu de suppressions, ou alors plus petit dans le cas inverse . La nouvelle zone de\ndébordement sera initialement vide.\nAutre représentation de l'index en MC\nOn peut aussi représenter l'index en mémoire centrale sous forme d'un arbre de recherche binaire\n(AVL, Red-Black, …), au lieu d'une table ordonnée. L'avantage est d'éviter les décalages (en\nmémoire centrale) lors de l'insertion de nou"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 36,
    "text": "rche binaire\n(AVL, Red-Black, …), au lieu d'une table ordonnée. L'avantage est d'éviter les décalages (en\nmémoire centrale) lors de l'insertion de nouvelles clés ou la suppressi on de clés dans l'index.\nL'inconvénient est l’encombrement mémoire plus important à cause des pointeurs ( fg, fd,…)\nassociés à chaque nœuds de l’arbre.\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 34\n...\nc''\n...\n...\nc\n...\n...\nc'\nFichier de données\nc\nc'\nc''\nIndex en arbre binaire en MC\n...\nc1\n...\n...\nc3\n...\n...\nc5\n... c2\n...\nc4Table d'index non \ndense en MC\nFichier de données \nzone primaire\nFichier de données \nzone de débordement\nc1\nc2\nc3\nc4\nc5"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 37,
    "text": "Pour la représentation des valeurs multiples des clés de recherche, on adapte assez facilement la\nstructures des arbres binaire de recherche pour supporter les valeurs de clés identiques :\n- Soit chaque nœud de l’arbre pointe une liste d’adresses d’enregistrements du fichier de données\nayant comme valeur de clé l’information du nœud. ,Voir exemple dans la figure ci-dessous.\n \n- Soit relaxer la contrainte du maintient de l’ordre de l’arbre binaire : < en ≤ (ou respectivement : >\nen ≥) pour accepter les valeurs en double en les plaçant à gauche (re spectivement à droite) du nœud\ncourant.\nIndex de grande taille\nSi l'index est trop grand pour résider en mémoire centrale ( MC), on peut travailler directement sur\nle fichier index à la place de la table d’index. Dans ce cas le fichier index qui est de type TOF ou\nTOVC\n (pour pouvoir faire des recherches dichotomiques), est utilisé comme structu"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 37,
    "text": " table d’index. Dans ce cas le fichier index qui est de type TOF ou\nTOVC\n (pour pouvoir faire des recherches dichotomiques), est utilisé comme structure auxiliaire\npermettant d’accélérer les opérations d’accès au fichier de données (il n’y a plus de table d’index en\nMC dans ce cas particulier). \nPar exemple une recherche d’enregistrement de clé v, commence d’abord par une recherche de v\ndans le fichier index (par dichotomie) afin de récupérer les informations de localisation (numéros de\nblocs, déplacement, indicateur d’effacement logique, taille ...etc). Ens uite l’accès au fichier de\ndonnées est effectuer pour récupérer le (ou les) enregistrement(s) associé (s). Les autres opérations\n(insertion, suppression, …) peuvent aussi être définies en utilisant le fichier index au lieu de la table\nd’index en MC.\n3) Index multi-niveaux\nSi le fichier index est assez volumineux, même la recherche di"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 37,
    "text": "en utilisant le fichier index au lieu de la table\nd’index en MC.\n3) Index multi-niveaux\nSi le fichier index est assez volumineux, même la recherche dichotomique nécessitera un nombre de\nlectures de blocs relativement élevé (par exemple de l’ordre des dizaines d’accès disques pour des\nfichiers index de plus de mille blocs). On peut diminuer ce nombre en cons truisant un deuxième\nindex sur le fichier index (ordonné). Dans ce cas, on choisira une seule c lé pour chaque groupe de\nblocs du fichier index (index non dense) pour construire le deuxième index. On obtient ainsi un\nindex à 2 niveaux.\nSi le deuxième index est encore trop grand pour résider en MC, on le stocke sur disque (deuxième\nfichier index) et on construit un troisième index en choisissant une cl é par groupe de blocs du\ndeuxième fichier index. On peut répéter ce procédé jusqu’à obtenir un index pouva nt résider en\nmémoire centra"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 37,
    "text": "sissant une cl é par groupe de blocs du\ndeuxième fichier index. On peut répéter ce procédé jusqu’à obtenir un index pouva nt résider en\nmémoire centrale (index à n niveaux). \nLa figure ci-dessous, montre les différents composants d’un index à 2 niveaux:\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 35\n...\nc\n...\n...\nc\n...\n...\nc\nFichier de données\nc\nLa valeur c apparaît dans 3 enregistrements\na1 a2 a3"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 38,
    "text": "4) Accès multiclés\nPour améliorer les recherches basées sur plusieurs clé de recherche en même temps (requêtes multi-\nclés), on peut utiliser et combiner plusieurs index (un sur chaque attribut utilisé). \nUne requête multi-clés est de la forme :\n« trouver les enregistrement /que P soit vrai » \navec P un prédicat de type conjonction ou disjonction de conditions élémentaire : C1 \n∧/∨ C2 ... Cn\nchaque condition élémentaire Ck porte sur un seul attribut du fichier de données.\nPar exemple si on dispose de 2 index : IndA1 et IndA2, construits respectivement sur les attributs\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 36\nClé Adr\nFichier de données en MS\nFichier index 1 en MS\nFichier index 2 en MS\n(de sauvegarde)\nTable index 2 \nen MC\nSauvegarde index2\nChargement index2"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 39,
    "text": "A1 et A2 du fichier de données, on peut localiser rapidement tous les enregistre ments vérifiant une\nconditions de la forme A1=v1 ∧ A2=v2 (c’est une requête multi-clés portant sur A1 et A2). Les\nétapes peuvent être résumées comme suit :\n1. On recherche v1 dans l’index IndA1 produisant comme résultat une liste L1 (éventuellement\nvide) d’adresses d’enregistrements. \n2. On recherche v2 dans l’index IndA2 produisant comme résultat une liste L2 (éventuellement\nvide) d’adresses d’enregistrements.\n3. On effectue l’intersection des deux listes L = L1 Ç L2. \n4. On trie L sur le numéro de bloc et on accède au fichier de données pour récupérer l es\nenregistrements cherchés.\nCet algorithme (les 4 étapes ci-dessus) n’est pas forcément le meilleur (d’un point de vue\nperformance). Tout dépend en fait du nombre d’enregistrements vérifiant la conditi on de la requête\n(c’est ce qui est appelé la sélectivi"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 39,
    "text": "point de vue\nperformance). Tout dépend en fait du nombre d’enregistrements vérifiant la conditi on de la requête\n(c’est ce qui est appelé la sélectivité du prédicat P). Si ce nombre est important, un parcours\nséquentiel du fichier de données sera peut être plus avantageux que d’accéder par les index. On peut\nestimer à l’avance la sélectivité d’une requête si nous disposons de st atistiques sur les valeurs des\nattributs dans le fichier de données. Par exemple lors des insertions/suppre ssion on peut mettre à\njours ce genre de statistiques.\nUn cas particulier (et assez fréquent aussi) de l’utilisation de pl usieurs index en même temps, est la\nméthode des listes inversées. Cette méthode est applicable lorsque l’un des attributs indexés est à\nvaleurs uniques (en bases de données en parle alors de clé primaire\n).\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 39,
    "text": "aleurs uniques (en bases de données en parle alors de clé primaire\n).\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 37\nx1 c, c''\nx2 c'\n X clésP\ny1 c''\ny2 c\ny3 c'\n Y clésP\nc (i,j)\n c' (i', j')\n c'' (i'',j'')\ncléP Adr\nc'' | x1, y1\nc | x1, y2\nc' | x2, y3\nFichier de données\nIndex sur clé \nsecondaire X\nIndex sur clé \nsecondaire Y\nIndex sur clé primaire"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 40,
    "text": "Par abus de langage, on désigne souvent l’index construit sur cet attribut c omme étant « primaire »\n(même si le fichier de données n’est pas ordonné) et les autres index (sur les autres attributs) seront\ndits « secondaires » (cette terminologie : ‘index primaire et index secondaire’ est légèrement\ndifférente de celle utilisées généralement dans les structures de fichi ers au niveau physique, comme\ncela a été présenté en début de chapitre et peut donc entraîner une certaine confusion chez le lecteur\nnon averti). Dans la figure précédente, on dispose d’un index sur la clé pri maire P (à valeurs\nuniques) et de deux index sur les clés secondaires X et Y (pouvant être à valeurs multiples).\nLe problème avec les clés secondaires, est qu'il peut exister plusi eurs enregistrements pour une\nmême valeur du champ indexé. On implémente généralement cette m ultiplicité à travers des listes\nde clés pr"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 40,
    "text": "xister plusi eurs enregistrements pour une\nmême valeur du champ indexé. On implémente généralement cette m ultiplicité à travers des listes\nde clés primaires (au lieu de listes d’adresses).\nQuand on recherche les enregistrements suivant une clé secondaire (par exem ple X=a), on utilise\nl'index sur la clé secondaire X pour récupérer la ou les clés primaires associées à la valeur che rchée\n(a). Pour chaque clé primaire trouvée, on utilise l'index sur la clé primaire P pour localiser\nl'enregistrement sur le fichier de données (numéro de bloc et déplacement). \nDans cette méthode (listes inversées) la recherche commence sur l’i ndex de clé secondaire, puis\npasse par l’index de clé primaire avant d’atteindre le fichier de données.\nVoici les étapes d’une requête multi-clés avec la méthode des listes inversées : \n« trouver tous les enregistrements dont la valeur de X = vx ET la valeur de Y = vy "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 40,
    "text": "s d’une requête multi-clés avec la méthode des listes inversées : \n« trouver tous les enregistrements dont la valeur de X = vx ET la valeur de Y = vy ET ... » \navec X, Y, ... des clés secondaires.\n1. En utilisant l'index secondaire X, trouver la liste Lx de clés primaires\n associées à la valeur \nde X (vx).\n2. Refaire la même action pour chaque clé secondaire mentionnée dans la requête...\n3. Faire l'intersection des listes de clés primaires\n Lx, Ly, ... pour trouver les clés primaires \nassociées avec chaque valeur de clé secondaire mentionnée dans la requête.\n4. Utiliser alors l'index primaire pour retrouver les enregistrements du fichier de données (en \ntriant d’abord la séquence des numéros de blocs avant d’effectuer les transferts physiques)\nSi la requête initiale était de forme disjonctive (c-a-d avec une condition de la forme « X = vx OU \nY = vy OU ... »), on aurait utilisé l’opérati"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 40,
    "text": "es)\nSi la requête initiale était de forme disjonctive (c-a-d avec une condition de la forme « X = vx OU \nY = vy OU ... »), on aurait utilisé l’opération d’union des listes Lx, Ly, … au lieu de l’intersection à \nl’étape 3 du pseudo algorithme précédent.\nPour insérer un enregistrement <c,vx,vy,...> avec c sa clé primaire et vx,vy,... ses clés secondaires,\non procède comme suit :\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 38\nx1 \nx2 \n X ptr\nc \nc' \nc'' \ncléP suiv\nIndex secondaire avec ses listes de clés primaires\nc (i,j)\n c' (i', j')\n c'' (i'',j'')\ncléP Adr\nIndex sur clé primaire\n…\nVers le fichier de \ndonnées\n…"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 41,
    "text": "1. Rechercher c dans l'index primaire pour vérifier qu'elle n'existe pas déjà et pour trouver l'indice ip où doit être \ninsérée cette clé (recherche dichotomique).\n2. Insérer l'enregistrement dans le fichier de données. Soit ( i,j) son adresse. Si le fichier de données est ordonné, \nl’index sera probablement non dense. Soit c la clé du dernier enregistrement du groupe où à lieu l’insertion et \nsoit (i,j) son adresse. \n3. Dans le cas d’un index dense (par exemple un fichier non ordonné), insérer le couple < c, (i,j)> dans la table \nd'index primaire, à l'indice ip (en procédant par décalages).\nDans le cas d’un index non dense (par exemple un fichier ordonné), il faut mettre à jour l’entrée ip de la table \nd’index pour qu’elle contienne <c, (i,j)> si l’ancienne valeur est différente.\n4. Rechercher la valeur vx dans l'index secondaire X,\nsi vx existe, rajouter c à la liste pointée par vx\nsi "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 41,
    "text": ",j)> si l’ancienne valeur est différente.\n4. Rechercher la valeur vx dans l'index secondaire X,\nsi vx existe, rajouter c à la liste pointée par vx\nsi vx n'existe pas, insérer vx (par décalages) dans la table X. \nLa nouvelle entrée vx, pointera une liste formé par une seule clé primaire (c).\n5. Refaire l'étape 4) pour chaque clé secondaire restante ( vy, ...).\nPour supprimer logiquement un enregistrement de clé primaire c, (c’est par exemple le cas d’un\nfichier ordonné avec blocs contigus ou bien un fichier avec format variable et chevauchement), il\nsuffit de positionner un bit (ou caractère) d'effacement au niveau du fichi er de données ou de la\ntable d'index primaire, pour l'entrée c. \nPour supprimer physiquement un enregistrement de clé primaire c, (c’est par exemple le cas d’un\nfichier ordonné avec blocs chaînés et format fixe ou variable sans chevaucheme nt ou bien alors un\nfichier n"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 41,
    "text": "rimaire c, (c’est par exemple le cas d’un\nfichier ordonné avec blocs chaînés et format fixe ou variable sans chevaucheme nt ou bien alors un\nfichier non ordonné avec format fixe ou variable sans chevauchement), il faut d’a bord supprimer\nphysiquement l’enregistrement dans le fichier de données. Ensuite il faut me ttre à jour la table\nd’index primaire soit en supprimant l’entrée relative à c (cas d’un index dense) ou alors modifier la\nclé et/ou l’adresse du représentant du groupe auquel appartient l’enregistrement supprimé (cas d’un\nindex non dense).\nDans les deux types de suppression (logique ou physique), il n’est pas nécessa ire de mettre à jour\nles autres index (associés aux clés secondaires). \nLes index Bitmaps\nToujours pour l’accès multi-clés, lorsque le nombre de valeurs distinctes d’une clé de recherche est\npetit, l’utilisation d’une table d’index classique a peu d’avantage (une t"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 41,
    "text": "ti-clés, lorsque le nombre de valeurs distinctes d’une clé de recherche est\npetit, l’utilisation d’une table d’index classique a peu d’avantage (une ta ble contenant un nombre\ntrès petit d’entrées, et pour chaque entrée, on aura de très longues liste s d’adresses à cause du grand\nnombre de valeurs qui se répètent). \nPar contre on peut construire à la place d’un index classique (table ordonnée), un ensemble de\nchaînes de bits\n (appelées ‘bitmap’), à raison d’une chaîne par valeur d’attribut . La longueur de ces\nchaînes est égale au nombre d’enregistrements dans le fichier de données. Ainsi un index bitmap sur\nun attribut A ayant K valeurs distinctes ( v1, v2, ...vk ) sera composé de K chaînes de bits ( IndA_v1,\nIndA_v2, … IndA_vk, une par valeur d’attribut) que l’on peut charger en mémoire indépendamment\nles unes des autres selon le besoin.\nLe iième bit de la chaîne bitmap associée à la v"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 41,
    "text": "leur d’attribut) que l’on peut charger en mémoire indépendamment\nles unes des autres selon le besoin.\nLe iième bit de la chaîne bitmap associée à la valeur V de l’attribut indexé sera à 1 si le iième\nenregistrement du fichier de données porte la valeur V dans l’attribut indexé. Sinon le bit associé\nsera à 0. \nIl est impératif d’avoir un moyen rapide d’accéder aux enregistrements du fichier de données à\npartir de leur numéro d’ordre. Par exemple pour un fichier de type TO\nF, il facile de calculer le\nnuméro de bloc et le déplacement dans le bloc pour localiser le iième enregistrement :\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 39"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 42,
    "text": "[num_bloc = ((i-1) div b)+1] et [depl = i mod b ; SI (depl = 0) depl = b FSI ] \nb étant la capacité maximale d’un bloc.\nS’il n’existe pas un tel moyen rapide pour localiser les enregistrement s à partir de leur numéro\nd’ordre, on peut maintenir, en plus, un index classique (table ou arbre) ass ociant chaque numéro\nd’enregistrement avec son adresse dans le fichier de données.\nExemple d’utilisation des index bitmap\nSoit un fichier F contenant N enregistrements, et soient A et B deux attributs de F. \nSupposons que A peut avoir uniquement 3 valeurs possibles : v1, v2 ou v3 \n(la cardinalité du domaine de A est donc 3). \nUn index bitmap sur \nA est donc composé de 3 chaînes de N bits chacune ( IndA_v1, IndA_v2 et\nIndA_v3) :\nn° enr  :1 2 3 4 5 6 7 8 … i … … N\n|--|--|--|--|--|--|--|--|----|--|----|--|--|--|\nIndA_v1 : 1 0 0 0 1 1 0 1 …. 0 … 1 1 0 (N bits) → la chaîne de bits associée à v1\nIndA_v2 "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 42,
    "text": "8 … i … … N\n|--|--|--|--|--|--|--|--|----|--|----|--|--|--|\nIndA_v1 : 1 0 0 0 1 1 0 1 …. 0 … 1 1 0 (N bits) → la chaîne de bits associée à v1\nIndA_v2 : 0 1 0 0 0 0 0 0 …. 1 … 0 0 0 (N bits) → la chaîne de bits associée à v2\nIndA_v3 : 0 0 1 1 0 0 1 0 …. 0 … 0 0 1 (N bits) → la chaîne de bits associée à v3\n (ex : la valeur de A dans l’enreg n°2 et n°i vaut v2)\nDe même supposons que pour l’attribut B les seules valeurs possibles sont w1, w2, w3 ou w4 (la\ncardinalité du domaine de B est donc 4). \nUn index bitmap sur B est donc composé de 4 chaînes de N bits chacune ( IndB_w1, IndB_w2,\nIndB_w3 et IndB_w4) :\nn° enr : 1 2 3 4 5 6 7 8 … i … … N\n|--|--|--|--|--|--|--|--|----|--|----|--|--|--|\nIndB_w1 : 0 0 1 0 0 0 0 1 …. 0 … 1 0 0 (N bits)\nIndB_w2 : 1 1 0 0 0 1 0 0 …. 0 … 0 0 1 (N bits)\nIndB_w3 : 0 0 0 1 1 0 0 0 …. 0 … 0 1 0 (N bits)\nIndB_w4 : 0 0 1 0 0 0 1 0 …. 1 … 0 0 0 (N bits)\n (ex : la valeu"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 42,
    "text": " 1 1 0 0 0 1 0 0 …. 0 … 0 0 1 (N bits)\nIndB_w3 : 0 0 0 1 1 0 0 0 …. 0 … 0 1 0 (N bits)\nIndB_w4 : 0 0 1 0 0 0 1 0 …. 1 … 0 0 0 (N bits)\n (ex : la valeur de B dans l’enreg n°3 , n°7 et n°i vaut w4)\nDans ce cas pour faire la recherche multi-clés suivante :\n« trouver les enregistrements de F /que A=v2 ET B=w4 »\nOn peut charger les 2 chaînes IndA_v2 et IndB_w4, pour faire leur intersection (bit à bit). Le résultat\nest une chaîne de bit dont seules les positions relatives aux enregis trements vérifiant la condition\n[A=v2 ET B=w4] seront à 1. Dans cet exemple, l’enregistrement n°i sera dans le résultat.\nLes index bitmap sont très efficaces pour les requêtes multi-clés portant sur des attributs à faibles\ncardinalités. Ils sont aussi utilisés pour compter le nombre d’enregistrem ents vérifiant certaines\nconditions. Les différentes opérations élémentaires (le ET, le OU, le NON ... ) sur les bitmap"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 42,
    "text": "ompter le nombre d’enregistrem ents vérifiant certaines\nconditions. Les différentes opérations élémentaires (le ET, le OU, le NON ... ) sur les bitmaps sont\neffectuées sur des mots mémoire regroupant plusieurs bits à la fois (ex :8 bits, 16 bits, … 64 bits),\nce qui diminue considérablement le nombre d’itérations nécessaires pour la résolution des requêtes.\nDe plus même si une chaîne bitmap peut éventuellement être de grande t aille, il est tout à fait\nenvisageable de réaliser le traitement des requêtes en chargeant l es différents bitmap, partie par\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 40"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 43,
    "text": "partie selon l’espace mémoire disponible.\nLe principal inconvénient des index bitmap, est qu’en cas d’insertions ou de suppressions\nfréquentes ou alors en cas de simples mises-à-jours des enregistrements existants dans le fichier de\ndonnées (par exemple modifier la valeur d’un attribut d’un enregistrement donné), l es anciennes\nchaînes de bits doivent être corrigées ou même régénérées complètement da ns certains cas, ce qui\nposent des problèmes de performance assez délicats. Les index bitmap s ont de ce fait, utilisés\nprincipalement qu’avec des fichiers statiques (entrepôt de données, bases de donné es en lectures\nseules, …).\nHidouci W.K. & Kermi A. / Méthodes d'index / Structures de fichiers (SFSD) / ESI - 2024 41"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 44,
    "text": "Structures de Fichiers\nChapitre 4 Les Arbres en Mémoire Secondaire (Fichiers arborescents)\n1) Introduction\nLes méthodes par tables d'index sont limitées à certains type de fichiers (petits fichiers ou fichiers\nstatiques). Les méthodes basées sur les structures d'arbres sont mi eux adaptées aux fichier volumineux\net/ou dynamiques.\nAfin de mieux occuper l'espace des blocs, on utilise des arbres m-ai re où chaque nœud est représenté\ndans un bloc d'E/S.\n2) Les Arbres de Recherche m-aire\nUn arbre de recherche m-aire est la généralisation d'un arbre de recherche binaire.\nUn arbre de recherche m-aire d'ordre n\n est un arbre où chaque nœud peut avoir au maximum n fils\n(Fils1..n) et n-1 valeurs (Val1..n-1). \nLe degré (d) d'un nœud représente le nombre de fils dans le nœud. Il est toujours égal au nombre de\nvaleurs stockées dans le nœud plus un. Dans un arbre m-aire de recherche d'ordre n, chaque "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 44,
    "text": "re de fils dans le nœud. Il est toujours égal au nombre de\nvaleurs stockées dans le nœud plus un. Dans un arbre m-aire de recherche d'ordre n, chaque nœud aura\ndonc un degré d £ n.\nLes valeurs à l'intérieur d'un nœud sont ordonnées en ordre croissant. Les fils sont organisés en\nfonction des valeurs du nœuds, selon les règles suivantes :\ni) Le Fils1 pointe un sous-arbre contenant des valeurs < Val1\nii) Le Filsi, pour i Î [2 , d-1], pointe un sous-arbre contenant des valeurs Î ]Vali-1 , Vali[\niii) Le Filsd pointe un sous-arbre contenant des valeurs > Vald-1\nLa figure suivante montre un arbre de recherche m-aire d'ordre 5 de racine le nœud a. Le nœud b est le\nfils1 de a, le nœud c est le fils2 de a et ainsi de suite, jusqu'au nœud f qui est le fils5 de a.\nDans un nœud feuille, tous les fils sont à nil. Par contre dans un nœud interne, au moins un des fils doit\nêtre différent de nil. Le nœud"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 44,
    "text": " fils5 de a.\nDans un nœud feuille, tous les fils sont à nil. Par contre dans un nœud interne, au moins un des fils doit\nêtre différent de nil. Le nœud qui n'a pas de père (et qui doit être unique) est appelé racine de l'arbre.\nPar exemple, dans l'arbre de la figure, tous les fils de b à part le 3e fils, sont à nil. \nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 42"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 45,
    "text": "La recherche d'une valeur C commence dans le nœud racine P et se poursuit le long d'une branche :\n1- Si C existe dans P alors la recherche s'arrête avec succès\n2- Si C n'existe pas dans P alors\nsoit k la position dans P où devrait être insérée C (pour que les valeurs restent ordonnées)\nSi Filsk différent de nil alors P ← Filsk ; aller à 1 \nSinon la recherche s'arrête avec échec.\nPar exemple, la recherche de 48 dans l'arbre de la figure précédente se déroule comme suit:\n– on commence la recherche dans le nœud a. La valeur 48 n'existe pas et est comprise entre 40 et \n67. Donc le prochain nœud à visiter est le 3e fils (le nœud d)\n– la recherche se poursuit dans le nœud d, et le prochain nœud à explorer est le 2e fils, car 48 est \ncomprise entre 42 et 50\n– on continue la recherche dans le nœud h. La valeur 48 existe (Val2), on s'arrête donc avec \nsuccès.\nSi on avait recherché la valeur 15, o"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 45,
    "text": "e 42 et 50\n– on continue la recherche dans le nœud h. La valeur 48 existe (Val2), on s'arrête donc avec \nsuccès.\nSi on avait recherché la valeur 15, on aurait visité d'abord le nœud a, puis le nœud b (Fils1 de a, car 15\n< 24). Là, on se serait arrêté avec un échec, car 15 est comprise entre 12 et 20 et le 4e fils de b est à nil.\nPour insérer une nouvelle valeur V dans un arbre de recherche m-aire, on recherche d'abord la valeur,\npour vérifier qu'elle n'existe pas déjà et pour localiser le nœud P où doit être insérée cette valeur ( P est\nle dernier nœud visité dans la recherche). La recherche retourne aussi l 'indice k où devrait être insérée\nV s'il y a avait de l'espace dans P.\nSi P n'est pas plein, \n• on insère V dans P, par décalages afin de garder le tableau de valeurs ordonné.\nSinon (P est plein) : \n• on alloue un nouveau nœud Q contenant une seule valeur (Val1 =V) et deux fils à nil"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 45,
    "text": " de garder le tableau de valeurs ordonné.\nSinon (P est plein) : \n• on alloue un nouveau nœud Q contenant une seule valeur (Val1 =V) et deux fils à nil (Fils1 = nil\net Fils2 = nil)\n• on fait pointer le nouveau nœud Q par Filsk dans le nœud P (qui était, avant l'insertion, \nforcément à nil). L'indice k est celui retourné par la recherche.\nPar exemple, si on insère la valeur 64 dans l'arbre de la figure précédente, on procédera comme suit:\n1- recherche de 64 → échec (le dernier nœud visité est i et la position où devrait être insérée 64 \n est k=2)\n2- comme le nœud i n'est pas plein, on peut alors insérer 64 à la position 2 en décalant à droite \n les valeurs > 64\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 43\n24 40 67 82\n2 5 12 20 27 30 42 50 55 60 71 80 90 95 97 99\n47 48 63 65 6610\na\nb c d e f\ng h i"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 46,
    "text": "Le résultat de l'insertion est montré dans la figure ci-dessous :\nSi ensuite, on insère la valeur 62, on allouera alors un nouveau nœud ( j) qui va contenir 62 et il sera\npointé par Fils1 au niveau du nœud i ( i étant le dernier nœud visité lors de la recherche de 62 et la\nposition ou devrait être insérée 62, s'il y avait de l'espace dans i, était k = 1).\nLa figure suivante montre le résultat d'une telle insertion:\nUn arbre de recherche m-aire est dit « Top-Down\n » si tous ces nœuds internes sont remplis à 100%.\nL'algorithme d'insertion présenté ci-dessus, maintient cette propriété.\nLa suppression d'une valeur V peut être logique (ce qui favorise le maintient de la propriété top-down)\nou bien physique en généralisant la suppression des arbres de recherche bina ires (mais le maintient de\nla propriété top-down est légèrement plus difficile dans ce cas).\n- En mémoire secondaire\nChaque nœud "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 46,
    "text": "es de recherche bina ires (mais le maintient de\nla propriété top-down est légèrement plus difficile dans ce cas).\n- En mémoire secondaire\nChaque nœud de l'arbre est représenté par un bloc d'E/S. \nLa structure générale d'un bloc est alors comme suit :\ntype \nTbloc = structure\nVal : tableau[N-1] de typeqlq; // enregistrements ou (clés-adr)\nFils : tableau[N] d'entier; // numéros de blocs\ndegré : entier; // nb d'elt dans le tableau Fils\nFin;\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 44\n24 40 67 82\n2 5 12 20 27 30 42 50 55 60 71 80 90 95 97 99\n47 48 63 64 65 6610\na\nb c d e f\ng h i\n24 40 67 82\n2 5 12 20 27 30 42 50 55 60 71 80 90 95 97 99\n47 48 63 64 65 6610\na\nb c d e f\ng h i\n62\nj"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 47,
    "text": "Les adresses de nœuds sont des entiers (des n° de blocs). Un entier spécial (ex -1) représente nil.\nParmi les caractéristiques d'un fichier vu comme arbre, il y a l a racine. C'est le numéro du bloc\ncontenant le nœud racine de l'arbre.\nPar exemple, si l'arbre de la figure précédente était un fichier, le contenu du bloc d serait comme suit:\nalors que le contenu du bloc g serait :\nLe module suivant permet de réaliser une recherche dans un fichier orga niser sous forme d'un arbre de\nrecherche m-aire :\nRech( c:Typeqlq, var trouv:booleen, var i, j, prec : entier)\n/* \n * recherche c et retourne en plus du booléen trouv, le num de bloc (i) qui contient c, \n * sa position (j) dans le tableau Val ainsi que le numéro du bloc qui précède i (prec).\n * Si c n'existe pas, alors i sera positionnée à -1 et prec indique le numéro du dernier bloc visité.\n * la position ou devrait se trouver c dans le bloc"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 47,
    "text": "Si c n'existe pas, alors i sera positionnée à -1 et prec indique le numéro du dernier bloc visité.\n * la position ou devrait se trouver c dans le bloc prec est indiquée par j.\n */\n//on suppose que le fichier est déjà ouvert\ni ← Entete(F ,1); // le num du bloc racine\nprec ← -1; j ← 1; trouv ← F AUX\nTQ ( Non trouv et i <> -1 )\n LireDir( F , i, buf )\n // recherche interne dans le buffer en MC …\n Rech_interne( c, trouv , j ) // retourne : trouv et j \n Si ( Non trouv ) prec ← i; i ← buf.Fils[j] Fsi\nFTQ\n// fin du module de recherche.\n// Recherche dichotomique interne de c dans buf. Résultats: trouv et j (la position de c) \nRech_interne( c : typeqlq , var trouv:bool , var j:entier )\nbi ← 1; bs ← buf.degre-1 ; trouv ← F AUX\nTQ ( Non trouv et bi ≤ bs )\nj ← (bi + bs) div 2\nSi ( c = buf.Val[j].cle ) trouv ← VRAI \n Sinon Si ( c < buf.Val[j].cle ) bs ← j-1 Sinon bi ← j+1 Fsi\nFsi\nFTQ\nSi ( bi > bs ) j "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 47,
    "text": "s )\nj ← (bi + bs) div 2\nSi ( c = buf.Val[j].cle ) trouv ← VRAI \n Sinon Si ( c < buf.Val[j].cle ) bs ← j-1 Sinon bi ← j+1 Fsi\nFsi\nFTQ\nSi ( bi > bs ) j ← bi Fsi\n// fin de la recherche interne.\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 45\n42 50 55 60\ni-1 h -1 -1\n5\n 1 2 3 4 5\nVal\nFils degré\n10\n-1 -1\n2\n 1 2 3 4 5\nVal\nFils degré"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 48,
    "text": "L'insertion d'une nouvelle valeur (enregistrement ou clé/adr) dans le fichier utilise la recherche:\nIns( e:Tenreg; nomf:chaine )\nOuvrir( F , nomf, 'A' )\n Si ( Entete(F ,1) = -1 ) // Si le fichier est vide\n i ← AllocBloc( F ); Aff_entete( F , 1, i ) // i est la nouvelle racine\n buf.degre ← 2; buf.Val[1] ← e; buf.Fils[1] ← -1; buf.Fils[2] ← -1\n EcrireDir( F , i, buf )\nSinon\n Rech( e.cle, trouv, i, j, prec )\n Si ( Non trouv )\n// si le dernier bloc visité n'est pas plein, on y insère l'enreg e …\nSi ( buf.degre < N )\n// décalages interne à partir de j …\nPour k ← buf.degre, j+1, -1 // boucle arrière avec pas = -1\nbuf.Val[k] ← buf.Val[k-1]\nbuf.Fils[k+1] ← buf.Fils[k]\nFinPour\nbuf.Val[j] ← e // insérer e à la pos j\nbuf.Fils[j+1] ← -1 // et son « fils droit » à nil\nbuf.degre ← buf.degre + 1 // incrémenter le degré\nEcrireDir( F , prec, buf )\nSinon // si le bloc est plein, il faut allouer un nouveau"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 48,
    "text": "s droit » à nil\nbuf.degre ← buf.degre + 1 // incrémenter le degré\nEcrireDir( F , prec, buf )\nSinon // si le bloc est plein, il faut allouer un nouveau …\ni ← AllocBloc( F )\n// et le chaîner avec le précédent\nbuf.Fils[j] ← i\nEcrireDir( F , prec, buf )\n// insérer e à la pos 1 du nouveau bloc …\nbuf.degre ← 1; buf.Val[1] ← e; buf.Fils[1] ← -1; buf.Fils[2] ← -1\n EcrireDir( F , i, buf )\nFsi // buf.degre < N\n Fsi // Non trouv\nFsi // Entete(F ,1) = -1\nFermer(F)\nLa requête à intervalle dans un fichier en arbre de recherche m-aire, s’effectue en recherchant d’abord\nla borne inférieure de l’intervalle, ensuite les prochaines valeurs sont retrouvé es à l’aide des suivants-\ninordre.\nPour localiser le suivant-inordre d’une valeur v se trouvant dans le bloc numéro i à la position j, on\neffectue les tests suivants :\n1- Si v se trouve à la dernière valeur du bloc i et le dernier fils est à nil (c-a-d : j "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 48,
    "text": "c numéro i à la position j, on\neffectue les tests suivants :\n1- Si v se trouve à la dernière valeur du bloc i et le dernier fils est à nil (c-a-d : j = buf.degre - 1 &&\nFilsdegre = -1 ) le suivant v’ se trouve dans un nœud ascendant de i. Il faut remonter de bloc en bloc (à\nl’aide d’une pile par exemple) jusqu’à localiser le premier ascendant par lequel la remontée s’est\neffectuée par un fils autre que le dernier. Soit j’ ce numéro de fils. Le suivant de v se trouve alors à la\nposition j’ de cet ascendant.\nV oir schéma ci-dessous.\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 46"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 49,
    "text": "2- Si v n’est pas la dernière valeur du bloc i et son fils-droit ( Filsj+1) est à nil (c-a-d : j < buf.degre - 1\n&& et Filsj+1 = -1 ), alors le suivant v’ se trouve à la position j+1 du même bloc i.\nV oir schéma ci-dessous.\n3- Si v (qui se trouve à la position j du bloc i) a un fils-droit différent de nil (c-a-d : Filsj+1 <> -1 ) alors\nle suivant inordre v’ se trouve à la 1ere position du bloc le plus à gauche du sous-arbre Filsj+1. \nPour localiser le bloc le plus à gauche, on descend de Fils1 en Fils1 jusqu’à trouver un bloc qui n’a pas\nde Fils1 (c-a-d Fils1 = -1). V oir schéma ci-dessous.\nLe parcours inordre d’un arbre m-aire de recherche permet de visiter toutes les valeurs de l’arbre en \nordre croissant.\nInordre( r:entier ) // en entrée r : le numéro du bloc racine de l’arbre\nvar buf : Tbloc ; k:entier // variables locales : le buffer buf et l’indice k\nSI ( r <> -1 )\nLireDir( F , r ,"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 49,
    "text": " r : le numéro du bloc racine de l’arbre\nvar buf : Tbloc ; k:entier // variables locales : le buffer buf et l’indice k\nSI ( r <> -1 )\nLireDir( F , r , buf ) // on suppose que la variable F est globale (le fichier déjà ouvert)\nPOUR (k = 1 , buf.degre - 1 )\nInordre( buf.Fils[k] )\nvisiter( Val[k] )\nFP\nInordre( buf.Fils[ buf.degre ] )\nFSI\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 47\n... ... ... \n... ... ... v\n… ... v’ ...\nLe dernier fils\nj’\nj\ni\n... v v’ ...\n j j+1\ni\n... ... ... \n... ... ... ...\n… ... v ...\nj\n1\ni\nv’ ... ...\nFilsj+1"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 50,
    "text": "3) Les B-Arbres\nCe sont des arbres de recherche m-aire qui restent toujours équilibrés et sont donc très utilisés pour\ngérer des fichiers volumineux et dynamiques\n. Inventés par R. Bayer et E. Mc Creight en 1972, les B-\nArbres sont devenus un standard de facto à cause de leurs performances remarquables et ce, jusqu'à nos\njours.\nPour simplifier la présentation, on choisira un ordre impair ( N = 2d+1 )\nDans un B-Arbre d'ordre N : \nTous les nœuds à part la racine, sont remplis au minimum à 50% (soit d valeurs)\nLa racine peut contenir au minimum 1 valeur\nToutes les branches ont la même longueur (arbre complètement équilibré)\nLa figure ci-dessous montre un B-Arbre d'ordre 5 (c-a-d au minimum d=2 valeurs, au maximum 2d=4 \nvaleurs par nœud)\nLa recherche dans un B-Arbre est similaire à la recherche dans un arbre de recherche m-aire. \nLa différence se situe dans l'algorithme d'insertion et l'algo"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 50,
    "text": "herche dans un B-Arbre est similaire à la recherche dans un arbre de recherche m-aire. \nLa différence se situe dans l'algorithme d'insertion et l'algorithme de suppression.\nPour insérer une valeur v dans un B-Arbre de racine R, on procède comme suit :\nOn insère v et son fils-droit fd (initialement fd = -1 ), c-a-d si v sera insérée à une position j dans un\nnœud, alors il faudra insérer aussi son fils-droit fd à la position j+1 (dans le tableau des fils) :\n1- Rechercher v, pour vérifier qu'elle n'existe pas et trouver le dernier nœud feuille visité (P)\n2- si P n'est pas plein, on insère (v, fd) dans P par décalages internes et on s'arrête.\n3- si P est déjà plein, alors il va « éclater » en deux (P et Q, un nouveau nœud alloué) :\na) former la « séquence ordonnée » des valeurs de P incluant la valeur v (et son fils-droit fd)\nb) affecter les d premières valeurs avec les d+1 premiers fils au "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 50,
    "text": " « séquence ordonnée » des valeurs de P incluant la valeur v (et son fils-droit fd)\nb) affecter les d premières valeurs avec les d+1 premiers fils au nœud P\nc) affecter les d dernières valeurs avec les d+1 derniers fils au nouveau nœud Q\nd) insérer la valeur du milieu (celle qui se trouve à la position d+1 dans la séquence ordonnée) \ndans le nœud parent de P, s'il existe. Le fils droit de cette valeur sera le nœud Q :\nSi le parent de P existe, Aller à 2 pour réaliser cette insertion de la valeur du milieu,\nSinon si le nœud parent de P n'existe pas (P était la racine de l'arbre) : allouer une nouvelle \nracine R contenant uniquement la valeur du milieu avec comme fils 1 et 2, les nœuds P et Q \net on s'arrête.\nPar exemple, l'insertion de 76 dans le B-Arbre de la figure précédente, se déroule comme suit:\n1- recherche de 76 → trouv =FAUX, le dernier nœud visité = E (c'est une feuille) et la p"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 50,
    "text": "ns le B-Arbre de la figure précédente, se déroule comme suit:\n1- recherche de 76 → trouv =FAUX, le dernier nœud visité = E (c'est une feuille) et la position \n où doit être insérée 76 est 2\n2- comme le nœud E n'est pas plein, on insère alors \n76 avec son « fils-droit » -1 respectivement \n aux positions 2 dans le tableau Val et 3 dans le tableau Fils du nœud E\nOn obtient alors le B-Arbre ci-dessous :\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 48\n24 40 70\n2 5 12 20 27 30 42 50 55 60 71 80 97\nA\nB C D E"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 51,
    "text": "Si on insère maintenant la valeur 57, c'est le nœud D qui sera visité en dernier par la recherche.\nLa position de 57 dans D devrait alors être 4 (et son fd à la position 5)\nComme le nœud D est déjà plein, il y aura alors un « éclatement » (cela veut dire, allocation d'un\nnouveau nœud, F par exemple).\na) formation de la « séquence ordonnée » incluant la nouvelle valeur 57:\nVal : 42, 50, 55, 57, 60\nFils: -1, -1, -1, -1, -1, -1\nb) les d premières valeurs ( 42, 50 ) et les d+1 premiers fils (-1, -1, -1) seront affectés au nœud D\n les d dernières valeurs ( 57, 60 ) avec les d+1 derniers fils (-1, -1, -1) seront affectés au nœud F\n la valeur du milieu (55) avec comme fils-droit (F) seront insérés dans le nœud parent (le nœud A).\n Comme le nœud A n'est pas plein, l'insertion de ( 55, F ) peut se faire par décalages internes\n \nOn obtient alors le B-Arbre suivant:\nSi on continue l'insertion de \n7"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 51,
    "text": "n'est pas plein, l'insertion de ( 55, F ) peut se faire par décalages internes\n \nOn obtient alors le B-Arbre suivant:\nSi on continue l'insertion de \n7, le nœud B va « éclater » (donc allocation d'un nouveau nœud G)\nla séquence ordonnée des valeurs de B + la valeur 7 est formée:\nVal : 2 , 5 , 7 , 12 , 20\nFils: -1, -1, -1, -1 , -1 , -1\nLes valeurs (2 et 5) avec les 3 premiers fils restent dans B. Les valeurs (12 et 20) avec les 3 derniers fils\nseront affectés au nouveau nœud G. La valeur du milieu ( 7) avec comme fils-droit le nœud G seront\ninsérés dans le père (le nœud A).\nComme le nœud A est lui aussi plein, il va alors «  éclater » à son tour. Un nouveau nœud H est alors\nalloué et la séquence ordonnée est formée :\nVal : 7 , 24 , 40, 55, 70\nFils: B , G , C , D , F , E\nLes d premières valeurs ( 7 et 24) avec les 3 premiers fils ( B, G et C) restent dans A. Les d dernières\nvaleurs (55 et 7"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 51,
    "text": "\nFils: B , G , C , D , F , E\nLes d premières valeurs ( 7 et 24) avec les 3 premiers fils ( B, G et C) restent dans A. Les d dernières\nvaleurs (55 et 70) avec les 3 derniers fils ( D, F et E) seront affectés au nouveau nœud H. La valeur du\nmilieu (40) avec comme fils-droit le nœud H seront insérés dans le père du nœud A. \nComme le nœud A était la racine de l'arbre (il n'a donc pas de père), une nouvelle racine ( I) est alors\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 49\n24 40 55 70\n2 5 12 20 27 30 42 50 71 76 80 97\nA\nB C D E57 60F\n24 40 70\n2 5 12 20 27 30 42 50 55 60 71 76 80 97\nA\nB C D E"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 52,
    "text": "allouée contenant uniquement la valeur 40 avec comme fils-gauche ( Fils[1]), l'ancienne racine ( A) et\ncomme fils-droit (Fils[2]) le nœud H.\nLa figure suivante, montre l'arbre obtenu :\nQuand la racine d'un B-Arbre éclate (à cause d'une insertion), la profondeur de l'arbre augmente d'un\nniveau.\nLa suppression d'une valeur dans un B-Arbre, se déroule de manière symétrique à une opérati on\nd'insertion. Certaines suppressions entraînent une diminution de la profondeur de l'Arbre.\nPour supprimer une valeur v, on procède comme suit:\n1- rechercher v\n les résultats → p : le nœud qui contient v et\n k : la position de v dans le tableau Val de p\n2- Si p est une feuille, Aller à 3 \n Sinon // p est un nœud interne\n a- remplacer v par son successeur (v'), qui se trouve à la 1ere position de la feuille (p') la plus à\n gauche du sous-arbre droit de v (le sous-arbre de racine Fils[k+1])\n b- supprimer v' "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 52,
    "text": ", qui se trouve à la 1ere position de la feuille (p') la plus à\n gauche du sous-arbre droit de v (le sous-arbre de racine Fils[k+1])\n b- supprimer v' dans p' comme suit : \nv ← v' \np ← p' \nAller à 3\n3- // suppression d'une valeur v dans un nœud p …\n Ecraser v ainsi que son fils-droit en réalisant des décalages internes dans le bloc p\n Si p contient encore au moins d valeurs alors Aller à 4 // fin de la suppression\n Sinon // il reste moins de d valeurs (donc p devient sous-chargé)\nSi un des frères (q) de p contient plus de d valeurs, \neffectuer une \nredistribution entre p et q (voir ci-dessous)\nSinon // aucun des frères n'a plus de d valeurs\nfusionner p avec l'un de ses frères (voir ci-dessous aussi)\net supprimer la valeur qui les séparait dans leur père comme suit :\n v ← cette valeur\np ← le père de p\nAller à 3\n4 - fin\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD)"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 52,
    "text": "ns leur père comme suit :\n v ← cette valeur\np ← le père de p\nAller à 3\n4 - fin\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 50\n7 24\n2 5 27 30 42 50 71 76 80 97\nA\nB C D E57 60F12 20\n55 70H\n40\nG\nI"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 53,
    "text": "La redistribution entre deux nœuds frères X et Y, met en jeu leur père P afin d'ajouter une valeur à X et \nd'enlever une valeur à Y :\n Soit sep la valeur qui séparait X et Y dans le père P\n Si Y est un frère droit de X,\n sep est inséré comme dernière valeur de X\nLa 1ère valeur de Y monte vers P pour remplacer sep\nLe Fils[1] de Y est transmis à X à la dernière position\nLes valeurs et les fils sont décalés d'une position vers la gauche dans Y\nLes degrés dans X et Y sont mis à jour en conséquence\n Si Y est un frère gauche de X,\nLes valeurs et les fils sont décalés d'une position vers la droite dans X\n sep est inséré comme première valeur de X (Val[1])\nLa dernière valeur de Y monte vers P pour remplacer sep\nLe dernier fils de Y est transmis à X à la première position (Fils[1])\nLes degrés dans X et Y sont mis à jour en conséquence \nLes schémas suivants montrent une redistribution de Y vers X "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 53,
    "text": " à la première position (Fils[1])\nLes degrés dans X et Y sont mis à jour en conséquence \nLes schémas suivants montrent une redistribution de Y vers X (avec Y un frère droit)\nAvant la redistribution :\nAprès la redistribution :\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 51\n50 60\na b c\n3\n 1 2 3 4 5\nVal\nFils degré\n80 90\nd e f\n3\n 1 2 3 4 5\nVal\nFils degré\n23 45 70 97\nzu v x y\n5\n 1 2 3 4 5\nVal\nFils degré\nP\nX Y\n50\na b\n2\n 1 2 3 4 5\nVal\nFils degré\n70 80 90\nc d e f\n4\n 1 2 3 4 5\nVal\nFils degré\n23 45 60 97\nzu v x y\n5\n 1 2 3 4 5\nVal\nFils degré\nP\nX Y\nsep"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 54,
    "text": "La fusion de 2 nœuds frères X et Y de père P, consiste à rassembler dans un même nœud ( X ou Y) tous\nles contenus des 2 nœuds (X et Y) en plus du séparateur qui se trouvait dans P. L'un des 2 nœuds frères\nsera libéré.\nPour fusionner Y dans X, il faut :\nFaire descendre le séparateur de P vers X (en le supprimant de P)\nTransférer toutes les valeurs et tous les fils de Y vers X\nLibérer le nœud Y\nExemples de suppressions\nSi on veut supprimer la valeur 70 dans l'arbre ci-dessous :\ncomme 70 se trouve dans un nœud interne, on doit alors la remplacer par son successeur (71)\nqui se trouve à la 1ère position de la feuille E\non doit ensuite supprimer 71 du nœud E,\ncomme E n'est pas encore sous-chargé (il reste encore 3 valeurs), on s'arrête ici.\nSi maintenant on supprime 57, le nœud F va devenir sous-chargé (nombre de valeurs restantes < d )\ncomme l'un des frères de F (le nœud E) contient plus de d"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 54,
    "text": "intenant on supprime 57, le nœud F va devenir sous-chargé (nombre de valeurs restantes < d )\ncomme l'un des frères de F (le nœud E) contient plus de d valeurs, on peut alors faire une \nredistribution: 71 descend vers F et 76 monte vers H (le père des nœuds F et E)\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 52\n7 24\n2 5 27 30 42 50 76 80 97\nA\nB C D E57 60F12 20\n55 71H\n40\nG\nI\n7 24\n2 5 27 30 42 50 80 97\nA\nB C D E60 71F12 20\n55 76H\n40\nG\nI\n7 24\n2 5 27 30 42 50 71 76 80 97\nA\nB C D E57 60F12 20\n55 70H\n40\nG\nI"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 55,
    "text": "Si on continue à supprimer par exemple la valeur 40, il y aura :\nfusion des nœuds D et F (avec libération par exemple de F)\nfusion des nœuds A et H (avec libération par exemple de H) et libération de la racine I (vide)\nla profondeur de l'arbre décroît\n→ comme exercice, retrouver les détails !\nOpération de chargement d’un B-arbre\nSouvent on a besoin d’insérer, de manière groupée, un grand nombre de données dans un B-arbre. Cela\narrive par exemple quand on veut construire un fichier index (sous forme de B-arbre ) à partir d’un\nfichier de données déjà existant (contenant déjà un nombre important d’enregis trements). Si on utilise\npour cela l’algorithme de l’insertion classique, cela risque de prendre un temps assez grand (malgré que\nl’insertion dans un B-arbre d’une valeur donnée soit efficace O(log n), le problème provient du grand\nnombre de données à insérer nécessitant donc un nombre imp"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 55,
    "text": "n dans un B-arbre d’une valeur donnée soit efficace O(log n), le problème provient du grand\nnombre de données à insérer nécessitant donc un nombre important de lectures e t écritures physiques\nde blocs). \nUne solution efficace, consiste à insérer les données en ordre crois sant dans le B-arbre à construire,\navec un algorithme particulier ( Bulk Insertions ). Cette approche consiste à remplir les feuilles de\nl’arbre de gauche à droite en réalisant les éclatements le long de la branche la plus à droite de l’arbre.\nLes performances seront encore meilleurs en gardant en MC (dans un tableau de buffers pour exemple)\ntous les blocs de la branche la plus à droite de l’arbre en cours de construc tion. En effet, durant cette\nopération de chargement, toutes les insertions et éclatements ne vont concerner que les nœuds de la\nbranche la plus à droite de l’arbre. A la fin, tous les buffers (représenta"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 55,
    "text": "toutes les insertions et éclatements ne vont concerner que les nœuds de la\nbranche la plus à droite de l’arbre. A la fin, tous les buffers (représentant les blocs de la branche la plus\nà droite) seront écrits physiquement en MS. Dans le schéma ci-dessous, les nœuds en rouge sont les\nbuffers en MC, les nœuds en noir sont les blocs déjà écrits physiquement en MS (disque).\nL’idée principal de cet algorithme est d’insérer la prochaine valeur, directement dans le buffer associé à\nla feuille la plus à droite sans effectuer de recherche. Un grand nombre de valeurs pourront donc être\ninsérées de cette manière sans faire aucun accès disque. Lorsque le buffer devient plein, on réalise un\néclatement en écrivant sur disque, uniquement le bloc renfermant la moi tié de gauche. La moitié de\ndroite (le nouveau nœud le plus à droite) ainsi que la valeur du milieu (le nœud père sur la branche la\nplus à dr"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 55,
    "text": "t la moi tié de gauche. La moitié de\ndroite (le nouveau nœud le plus à droite) ainsi que la valeur du milieu (le nœud père sur la branche la\nplus à droite) restent en MC (jusqu’à ce qu’ils deviennent pleins à leur tour). De cette manière, le coût\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 53\n2 5 10 11 \nIns : 2, 5, 10 , 11\nEn MC En MC\n2 5 11 15 \n10 Ins : 15\nEn MC\n2 5 11 15 20 22\n10 Ins : 20 et 22\nLa pile\n2 5 11 15 \n10 20 Ins : 30\nLa pile\n22 30"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 56,
    "text": "d’un éclatement est ramené à une seule écriture seulement (au lieu de 3 écritures dans le cas classique).\nComme les données vont être insérées en ordre croissant, l’arbre ainsi obte nu sera faiblement chargé\n(au voisinage de 50 %). Pour éviter cela, on peut modifier légèrement l’opération d’éclatement utilisée\nlors du chargement pour remplir les nœuds de gauche avec un pourcentage contrôlé (supérieur à 50 %)\net laisser les nœuds de droite temporairement sous-chargés (< 50%). A la fin de l’opération de\nchargement, on rééquilibre les nœuds de la branche la plus à droite (pouvant être sous-chargés à cause\nde cet éclatement particulier) en réalisant des redistributions avec leurs frères gauches respectifs avant\nde les écrire sur disque. \nQuelques variantes\na) Les B+-Arbres\nLa variante la plus utilisée de nos jours est sans aucun doute celle dite «  B+-Arbre » car elle est bien\nadaptée aux fi"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 56,
    "text": "es variantes\na) Les B+-Arbres\nLa variante la plus utilisée de nos jours est sans aucun doute celle dite «  B+-Arbre » car elle est bien\nadaptée aux fichiers en séquentiel-indexé qui supportent de manière effi cace aussi bien les accès\naléatoires que les accès séquentiels (comme les requêtes à inte rvalle). De plus on peux gérer des\nfichiers dynamiques et volumineux avec pratiquement les mêmes algorith mes utilisés dans les B-\nArbres de base.\nL'idée est que le dernier niveau de l'arbre joue le rôle d'un fichier ordonné sous forme de liste de blocs,\nafin de favoriser l'opération « next » dans les parcours séquentiels. Les niveaux internes représentent un\nindex pour guider la recherche aléatoire.\nLors des insertions, à chaque fois qu'un bloc feuille déborde, il éclate e n deux et la première clé du\nnouveau bloc (la clé du milieu dans la séquence d'éclatement) et « recopiée\n » dans le bloc p"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 56,
    "text": "euille déborde, il éclate e n deux et la première clé du\nnouveau bloc (la clé du milieu dans la séquence d'éclatement) et « recopiée\n » dans le bloc père (niveau\ninterne) pour séparer les deux blocs issus de l'éclatement (« recopiée » veut dire : insérée dans le père\nsans être supprimée de la feuille). Si le nœud père éclate suite à cette recopie, la nouvelle clé du milieu\nest cette fois-ci déplacée (et non recopiée) vers le nœud parent (à ce niveau on reprend les mêm es\ntechniques utilisées dans les B-Arbres de base).\nDans un B +-arbre, les valeurs dans les nœuds internes sont les copies de certaines valeurs\n du niveau\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 54\n--- --- --- --- --- --- --- --- --- --- --- --- \n--- --- --- --- \n--- \nEn MC\nAprès plusieurs insertions\n12 27\n2 5 27 30 35 42 50 52 80 97 99\nA\nB C D E60 71 74 78F12 20 22 25\n60 80H\n42\n"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 56,
    "text": "- --- --- --- \n--- --- --- --- \n--- \nEn MC\nAprès plusieurs insertions\n12 27\n2 5 27 30 35 42 50 52 80 97 99\nA\nB C D E60 71 74 78F12 20 22 25\n60 80H\n42\nG\nI"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 57,
    "text": "feuille. Ce sont des ‘ séparateurs’ utilisés pour guider la recherche le long d’une branche. Le niveau\nfeuille contient toutes les clés (et les informations associées).\nSi le B +-arbre représente un fichier de données, le niveau feuille contient les enre gistrements (clés\ncomprises). Si le B+-arbre représente un fichier index, le niveau feuille contient les c ouples <clé, adr>.\nDans les deux cas, les nœuds internes ne contiennent que quelques clés (sans le reste de l’information\nutile) pour guider la recherche vers les feuilles de l’arbre.\nComme les valeurs dans les nœuds internes sont des copies des clés qui existent déjà dans le niveau\nfeuille, les niveaux internes de l’arbre décrivent donc des intervalles semi-ouverts\n (de la forme ]a,b], au\nlieu d’intervalles ouverts ]a,b[ comme dans le cas des B-arbre de base). L’algorithme de recherche est\nlégèrement modifié pour tenir compte de ce"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 57,
    "text": ", au\nlieu d’intervalles ouverts ]a,b[ comme dans le cas des B-arbre de base). L’algorithme de recherche est\nlégèrement modifié pour tenir compte de ce petit changement.\nV oici un exemple d’insertion de la valeur 64 dans le B+-arbre de la figure précédente :\n1- la recherche de 64 mène vers le bloc feuille F\n2- comme F est déjà plein, il y aura un éclatement au niveau feuille :\n- Allocation d’un nouveau bloc feuille → le bloc J\n- La séquence ordonnée : [60,64,71,74,78] est divisée en 2 : [60,64] dans F et [71,74,78] dans J\n- la clé du milieu: 71 (la 1ere du nouveau bloc J) sera recopiée dans le bloc parent H\n (comme H n’est pas plein, l’insertion de 71 se fait juste par décalages)\nOn obtient l’arbre suivant :\nb) Les B*-Arbres\nC'est des B-Arbres où chaque nœud (autre que la racine) doit être rempli au minimum à 2/3 de sa\ncapacité maximale (au lieu de 1/2 dans la version de base).\nLors d'une"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 57,
    "text": "es où chaque nœud (autre que la racine) doit être rempli au minimum à 2/3 de sa\ncapacité maximale (au lieu de 1/2 dans la version de base).\nLors d'une insertion, l'éclatement d'un nœud plein est retardé, en employant des redistributions avec les\ndeux frères directs du nœud (celui à gauche et celui à droite), jusqu'à c e que ceux ci soient aussi\nremplis à leur capacité maximale. A ce moment là, deux de c es trois nœuds (celui subissant l'insertion\net l'un des ses frères gauche ou droit) seront éclatés en trois, chacun rempli à 2/3.\nAvec cette variante, on peut avoir un remplissage minimal des nœuds proche de 66%. Ce qui a pour\neffet d'augmenter le facteur de branchement moyen, donc de diminuer la profondeur de l'arbre et donc,\nd'améliorer les coûts d'accès.\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 55\n12 27\n2 5 27 30 35 42 50 52 80 97 99\nA\nB C D "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 57,
    "text": "s coûts d'accès.\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 55\n12 27\n2 5 27 30 35 42 50 52 80 97 99\nA\nB C D E60 64 \nF\n12 20 22 25\n60 71 80H\n42\nG\nI\n71 74 78 \nJ"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 58,
    "text": "c) Les B+-Arbres préfixés\nL'idée dans ce type de B +-Arbre, est de compacter au maximum la partie index de l'arbre (formée par\nles nœuds internes) en utilisant la plus petite partie de clé (e t non pas la clé elle même) nécessaire pour\nséparer deux nœuds fils dans le tableau des séparateurs ( Val[]). Ainsi les nœuds internes pourront\ncontenir un nombre plus grand de séparateurs et par conséquent un nombre plus grand de fils aussi, ce\nqui permet de diminuer la profondeur de l'arbre et d'augmenter les performances d'accès.\nComme les préfixes ne sont pas forcément de même taille, le nombre m aximum de valeurs (et donc de\nfils aussi) par nœud devient variable. Cela complique un peu plus les algorithmes d'accès.\nLa figure ci-dessous montre un exemple de structure utilisée pour représenter les nœuds internes d’un \nB+-arbre préfixé.\nCe nœud interne contient 4 séparateurs (czdda, pad, q et resta"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 58,
    "text": "emple de structure utilisée pour représenter les nœuds internes d’un \nB+-arbre préfixé.\nCe nœud interne contient 4 séparateurs (czdda, pad, q et restaure) et 5 fils (f1, f2, … f5). \nLe champ Nb représente le nombre de séparateurs\nLe champ Tab est un tableau d’octets, contenant : la liste des numéros fils avec les indices vers les \ndébuts de chaque séparateurs qui se trouvent à l’autre extrémité de Tab. Le vide se trouve donc au \nmilieu.\nCette manière d’organiser de la structure d’un nœud interne (Slotted page), permet d’effectuer des \nrecherches dichotomiques (dans les séparateurs) malgré le format variable des valeurs.\nHidouci W. K. & Kermi A. / Arbres en MS / Structures de fichiers (SFSD) / ESI - 2024 56\n4 ..|..|..|..|..|..|..|..|.. vide restaure | q | pad | czdda\nNb --------–----------------------------------------- Tab ----------------------------------------------\nf1 f2 f3 f4 f5\nTab"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 58,
    "text": "restaure | q | pad | czdda\nNb --------–----------------------------------------- Tab ----------------------------------------------\nf1 f2 f3 f4 f5\nTab : |f1|96|f2|93|f3|92|f4|84|f5|………………………………….|Restaure Q Pad Czdda|\n 84 92 93 96"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 59,
    "text": "Structures de fichiers\nChapitre 5 Méthodes de Hachage en MS\nCela concerne l’accès aux données d'un fichier en utilisant une fonction de hachage avec un temps\nconstant. La fonction de hachage permet le calcul d'adresses (numéro de blocs) à partir de la clé.\nLes notions de fonctions de hachage et de méthodes de résolution de collision en mémoire centrale\nont été présentés dans le cours ALSDD (Algorithmes et Structures de données).\nLorsqu’on veut utiliser les méthodes de hachage pour l’accès aux fichiers, il y a principalement trois\npossibilités :\n1. Utiliser une table de hachage comme index, en mémoire centrale , pour accélérer les accès aux\nfichiers de données. \n2. Utiliser un index en mémoire secondaire, géré par une méthode de hachage.\n3. Gérer le fichier de données par une méthode de hachage.\nLorsqu’un fichier (index ou de données) est géré par une méthode de hachage (l es deux dernièr"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 59,
    "text": "Gérer le fichier de données par une méthode de hachage.\nLorsqu’un fichier (index ou de données) est géré par une méthode de hachage (l es deux dernières\npossibilités 2 et 3), le fichier sera formé par des blocs contigus (numérotés 0, 1, … N-1). La fonction\nde hachage retourne alors un numéro de bloc ( h(x) : représente le numéro de bloc où devrait se\ntrouver la clé x, c’est l’adresse primaire de \nx ).\n5.1 Essai Linéaire en MS\nPour voir un exemple d’utilisation d’une des méthodes du hachage statique (vue s en ALSDD) pour\nla manipulation des fichiers, considérons l’Essai-Linaire appliquée aux fichiers. \nLa fonction h(x) retourne le numéro de bloc où commence la recherche de x. Si le bloc est plein et\nx n’existe pas dans ce bloc, on continue la séquence de tests : i-1, i-2, … 0 , N-1 , N-2, …. jusqu’à,\nsoit trouver x, soit trouver un bloc non plein (critère d’arrêt de la séquence de tests)."
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 59,
    "text": "a séquence de tests : i-1, i-2, … 0 , N-1 , N-2, …. jusqu’à,\nsoit trouver x, soit trouver un bloc non plein (critère d’arrêt de la séquence de tests).\nAlgorithme de recherche\nV oici un exemple de solution algorithmique pour la procédure de recherche avec cette méthode :\nRech(x:typeqlq, var trouv:booleen, var i:entier, var j:entier)\n// on suppose que le fichier F est déjà ouvert \ni ← h(x) ; trouv ← faux ; stop ← faux ; N ← Entete(F,1) \n// le nombre de blocs dans F\nTQ ( Non trouv && Non stop )\nLireDir( F , i, buf ) \n// rech interne dans buf …\nj ← 1 \nTQ ( j ≤ buf.NB && Non trouv )\nSI ( x = buf.tab[ j ].cle ) trouv ← vrai SINON j ← j+1 FSI\nFTQ\nSI ( buf.NB < b )\n// présence d'une case vide, donc arrêt de la séquence de tests\nstop ← vrai\nSINON \n SI ( Non trouv )\ni ← i - 1 ; SI ( i < 0 ) i ← N-1 FSI \nFSI\nFSI\nFTQ \nHidouci W.K. & Kermi A. / Hachage en MS / Structures de Fichiers (SFSD) / 2CP / ES"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 59,
    "text": "SI ( Non trouv )\ni ← i - 1 ; SI ( i < 0 ) i ← N-1 FSI \nFSI\nFSI\nFTQ \nHidouci W.K. & Kermi A. / Hachage en MS / Structures de Fichiers (SFSD) / 2CP / ESI - 2024 57"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 60,
    "text": "Mécanisme d’insertion\nPour insérer une nouvelle données e dans un fichier F géré par Essai-Linéaire, il suffit de\nrechercher la clé de e pour localiser l’emplacement où elle doit être insérée. Il faut aus si laisser au\nmoins une case vide dans le fichier (c-a-d il doit toujours rester, au moins un bloc non plein dans F),\npour cela on peut utiliser un compteur d’insertions (comme caractérist ique du fichier) et vérifier à\nchaque insertion qu’il reste inférieur au nombre de places disponibles ( NbIns < N * b avec b la\ncapacité maximale d’un bloc et N le nombre de blocs formant le fichier) :\nInsertion (e:Tenreg)\n// on suppose que le fichier F est déjà ouvert \nN← Entete(F,1) \n// le nombre de blocs dans F\nNbIns ← Entete(F,2) // le compteur d’insertions \nSI ( NbIns < (N * b - 1) )\nRech( e.clé , trouv , i , j )\nSI ( Non trouv )\n// buf contient déjà le dernier bloc visité (le bloc i) …\nbuf.NB++\n"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 60,
    "text": "ertions \nSI ( NbIns < (N * b - 1) )\nRech( e.clé , trouv , i , j )\nSI ( Non trouv )\n// buf contient déjà le dernier bloc visité (le bloc i) …\nbuf.NB++\nbuf.tab[ buf.NB ] = e\n// on rajoute x dans le bloc i\nEcrireDir( F , i, buf ) \n// incrémenter le compteurs d’insertions …\nAff_Entete( F , 2 , NbIns+1 )\nFSI\nFSI\nMécanisme de Suppression\nLe principe de la suppression physique d’un enregistrement de clé x dans un fichier géré par la \nméthode Essai-Linéaire, consiste à :\n1. Rechercher x → bloc numéro : i et déplacement : j (où se trouve x dans le fichier)\n2. Si le bloc i était déjà non plein, aller à 3. \n Sinon Il faut vérifier qu’aucune autre donnée se trouvant dans les blocs précédents i (c-a-d : i-1, i-2 … ), ne devienne \ninaccessible lorsque le bloc i sera non plein (c-a-d contiendra un vide). \nPour chaque donnée y devenant inaccessible et se trouvant dans un bloc k (k = i-1, i-2, ….), \n il "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 60,
    "text": " bloc i sera non plein (c-a-d contiendra un vide). \nPour chaque donnée y devenant inaccessible et se trouvant dans un bloc k (k = i-1, i-2, ….), \n il faut déplacer y à la place de x dans le bloc i et continuer les tests à partir de k-1, \n en modifiant i et j : i ← k et j ← l’ancien emplacement de y dans le bloc k. \n La donnée à supprimer maintenant devient y (c-a-d : x ← y). \nLes vérifications s’arrêtent lorsque k atteint un bloc non plein et que toutes ses données auront été vérifiées.\n3. Supprimer x dans le bloc i. Cela à pour conséquence de rendre le bloc i non plein.\n4. Fin de la suppression.\nLa suppression physique d’une donnée dans un bloc plein, le rend non plein. Cela a ura pour\nconséquence de faire apparaître une nouvelle case vide. Cette nouvelle cas e vide va probablement\nbriser une séquence de tests en deux. Il faut donc effectuer des tests dans la 2 e sous-séquence pour\nvoir"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 60,
    "text": ". Cette nouvelle cas e vide va probablement\nbriser une séquence de tests en deux. Il faut donc effectuer des tests dans la 2 e sous-séquence pour\nvoir si le vide introduit, perturbe ou pas les données existantes :\nancienne séquence : [ a a-1 … i+1 i i-1 i-2 … m-1 m ]\ntous les blocs entre a et m-1 étaient pleins avant la suppression (le bloc m n’est pas plein)\naprès la suppression dans le bloc \ni , ce dernier va contenir un vide, on aura donc 2 séquence indépendantes : \nnouvelles séquences : [ a a-1 … i+1 i ] [i-1 i-2 … m-1 m ]\nil faut donc tester les données dans les blocs k de la 2e séquence uniquement : [ i-1, i-2, … m ]\nHidouci W.K. & Kermi A. / Hachage en MS / Structures de Fichiers (SFSD) / 2CP / ESI - 2024 58"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 61,
    "text": "La séquence de blocs à tester [i-1, i-2, … m ] peut éventuellement être coupée par 0, car la gestion\ndes indices est circulaire (ex : [i-1, … 1 , 0, N-1, … m ] ). Ce dernier cas est représenté par le 3 e\nintervalle de la figure ci-dessous.\nPour vérifier si une donnée y (se trouvant dans un bloc k) va devenir inaccessible lorsque le bloc i\nva devenir non plein, il faut vérifier si son adresse primaire ( h(y)) se trouve dans l’un des 3\nintervalles de la figure ci-dessous :\nLe 1er intervalle est caractérisé par la condition : h(y) < k < i\nLe 2e intervalle est caractérisé par la condition : k < i ≤ h(y)\nLe 3e intervalle est caractérisé par la condition : i ≤ h(y) < k\nDans le cas où le bloc i était plein, l’algorithme consiste donc à parcourir tous les blocs k,\nprécédents i, jusqu’à trouver un bloc non plein (donc contenant au moins un vide). Si k devient < 0\net on n’a pas encore trouvé un bl"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 61,
    "text": "ous les blocs k,\nprécédents i, jusqu’à trouver un bloc non plein (donc contenant au moins un vide). Si k devient < 0\net on n’a pas encore trouvé un bloc non plein, on continue à partir de la fin du fichier ( N-1) de\nmanière circulaire.\nPour chaque bloc k, on doit parcourir son contenu pour vérifier toutes les données y à l’intérieur de\nk pour voir s’il est nécessaire de les déplacer, ou non, avant de supprimer la donnée x dans i.\nA chaque fois qu’une donnée y du bloc k, doit être déplacée dans i, on positionne i à k pour tester\nles blocs restant par rapport au nouveau i.\nA la fin du parcours des blocs précédents i (c-a-d : lorsqu’on trouve un bloc non plein), on supprime\nphysiquement x dans le bloc i en l’écrasant par la dernière donnée du bloc (buf.tab[ buf.nb ] ).\nIl est à noter qu’il existe toujours, au moins un bloc non plein avec la méthode Essai Linéaire.\nL’algorithme pour supprime"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 61,
    "text": "bloc (buf.tab[ buf.nb ] ).\nIl est à noter qu’il existe toujours, au moins un bloc non plein avec la méthode Essai Linéaire.\nL’algorithme pour supprimer la donnée x est comme suit :\nHidouci W.K. & Kermi A. / Hachage en MS / Structures de Fichiers (SFSD) / 2CP / ESI - 2024 59\nx\ny\nBloc i\nBloc k\nBloc m \nnon plein\nx\ny\nBloc i\nBloc k\nBloc m \nnon plein\n 1\n 2\n 3"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 62,
    "text": "Sup(x)\n // On suppose que le fichier est déjà ouvert\n Rech(x, trouv, i, j)\n SI ( trouv )\n SI ( buf.nb == b ) \n// si le bloc i est plein ...\n k ← i-1 ; SI ( k < 0 ) k ← N-1 FSI\n // boucle principale pour vérifier tous les blocs précédents i : i-1, i-2,… 0, N-1,…\n stop ← faux\n TQ ( Non stop )\nLireDir( f, k, buf2 )\n// boucle interne pour récupérer et tester les données y du bloc k ...\nm ← 1 ; stop2 ← faux\nTQ ( m ≤ buf2.nb et Non stop2 )\ny ← buf2.tab[ m ]\nSI ( [ h(y) < k < i ] ou [ k < i ≤ h(y) ] ou [ i ≤ h(y) < k ] )\n// déplacement de y à la place de x …\nbuf.tab[ j ] = y\nEcrireDir( f, i, buf )\ni ← k\nj ← m\nbuf ← buf2\nstop2 ← vrai\nSINON\nm++\nFSI\nFTQ\n//fin de la boucle interne : les données y du bloc k\nSI ( buf2.nb < b ) \nstop ← vrai \nSINON\nk ← k-1 ; SI ( k < 0 ) k ← N-1 FSI\nFSI\n FTQ // fin de la boucle principale :vérification des blocs précédents i\n // suppression physique de x dans i …\n buf."
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 62,
    "text": "1 ; SI ( k < 0 ) k ← N-1 FSI\nFSI\n FTQ // fin de la boucle principale :vérification des blocs précédents i\n // suppression physique de x dans i …\n buf.tab[ j ] ← buf.tab[ buf.nb ]\n buf.nb-- \n \nEcrireDir( f, i, buf )\nSINON\n // si le bloc i était au départ non plein …\n // suppression physique de x dans i …\n buf.tab[ j ] ← buf.tab[ buf.nb ]\n buf.nb--\n \nEcrireDir( f, i, buf )\nFSI // ( buf.nb == b )\n FSI // ( trouv )\n \n5.2 Hachage Linéaire (une méthode du hachage dynamique)\nDans ce qui suit nous allons présenter une des méthodes du hachage dynamique\n (la méthode \nHachage Linéaire) applicable aux fichiers volumineux et dynamiques.\nOn dispose d’un fichier F formé par des blocs contigus numérotés: 0, 1, 2, …\nOn maintient deux entiers (i et n) comme caractéristiques du fichier (ce sont des paramètres\nutilisées par cette méthode de hachage) :\nHidouci W.K. & Kermi A. / Hachage en MS / Structures de "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 62,
    "text": "caractéristiques du fichier (ce sont des paramètres\nutilisées par cette méthode de hachage) :\nHidouci W.K. & Kermi A. / Hachage en MS / Structures de Fichiers (SFSD) / 2CP / ESI - 2024 60"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 63,
    "text": "n représente le numéro du prochain bloc qui subira l’opération d’éclatement.\nIl est initialisé à 0 et est incrémenté à chaque éclatement de bloc.\n(lors d’un éclatement, un nouveau bloc est rajouté à la fin du fichier)\nCe paramètre est réinitialisé à 0 à chaque fois que la taille du fichier double.\ni représente le nombre de fois que le fichier a doublé de taille.\nIl est initialisé à 0 et est incrémenté à chaque fois que n atteint 2i.\nLes enregistrements sont insérés dans F en utilisant deux fonctions de hachage : hi et hi+1 définies\ncomme suit : hi(x) = x mod 2i et hi+1(x) = x mod 2i+1\nLors de l’insertion d’un enregistrement de clé x, le numéro de bloc à utiliser est calculer avec \nl’algorithme ‘Adr’ suivant :\nAdr(x)\n a ← hi(x) ;\n SI ( a < n )\na ← hi+1(x) ;\n FSI\n return a ; // a représente le num de bloc où devrait se trouver x\nSi le bloc numéro a n’est pas plein, l’enregistrement de clé "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 63,
    "text": " )\na ← hi+1(x) ;\n FSI\n return a ; // a représente le num de bloc où devrait se trouver x\nSi le bloc numéro a n’est pas plein, l’enregistrement de clé x est inséré dans a.\nSinon (si le bloc a est déjà plein) l’enregistrement de clé x est inséré séquentiellement en zone de\ndébordement associé au bloc a.\nChaque bloc du fichier F peut alors avoir une liste de blocs de débordement contenant les\nenregistrements qui n’ont pas pu être insérés dans le bloc principal (car celui-ci était déjà plein).\nLa figure ci-dessous donne un aperçu du fichier F après un certain nombre d’insertions :\nL’algorithme Adr(x) est aussi utilisé pour rechercher les enregistrements :\nRech(x)\n a = Adr(x)\n \nLireDir( F , a , buf )\n SI ( x est dans buf )\ntrouv ← vrai\n SINON\n // continuer séquentiellement dans la liste de blocs de débordement de a.\n i ← buf.lien ; trouv ← faux\nTQ ( Non trouv && i <> -1 )\nLireDir(F , i, buf )"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 63,
    "text": "/ continuer séquentiellement dans la liste de blocs de débordement de a.\n i ← buf.lien ; trouv ← faux\nTQ ( Non trouv && i <> -1 )\nLireDir(F , i, buf )\nSI ( x est dans buf ) trouv ← vrai SINON i ← buf.lien FSI\nFTQ\n FSI\nHidouci W.K. & Kermi A. / Hachage en MS / Structures de Fichiers (SFSD) / 2CP / ESI - 2024 61\n0 1 2 3 4 5 6 7 8 9 10 11\nLes paramètres actuels :\nn = 5 , i = 3\nn\n12"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 64,
    "text": "Après chaque nouvelle insertion (ou alors périodiquement) , on vérifie une ce rtaine condition sur\nl’état du chargement du fichier (par exemple : vérifier si le fac teur de chargement global du fichier\ndépasse un certain seuil Smax ou alors si le nombre de cases ayant subi un éclatement dépasse un\ncertain seuil … etc).\nSi la condition est vérifiée, on réalise alors l’opération d’éclatement du bloc n, comme suit :\n1. Rajouter un nouveau bloc à la fin du fichier F (forcément le numéro du nouveau bloc sera 2i+n)\n2. Re-hacher avec la fonction hi+1 tous les enregistrements du bloc n et éventuellement, ceux de sa liste de \ndébordement (si elle n’est pas vide). Cela a pour effet de déplacer, un certain nombre d’enregistrements vers \nle nouveau bloc (2i+n). (ceux pour lesquels hi+1(enreg.clé) a retourné 2i+n)\n3. Incrémenter n\n4. SI ( n == 2i )\nn ← 0 ; // réinitialiser n à 0\ni++ // à chaque incré"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 64,
    "text": "c (2i+n). (ceux pour lesquels hi+1(enreg.clé) a retourné 2i+n)\n3. Incrémenter n\n4. SI ( n == 2i )\nn ← 0 ; // réinitialiser n à 0\ni++ // à chaque incrémentation de i, la taille de F aura doublé\n FSI\nQuand les données x d’une case c sont re-hachées avec hi+1, il y aura que deux résultats possibles :\nhi+1(x) = c ou alors hi+1(x) = c + 2i \nCar pour toute donnée x se trouvant dans une case c (avant l’éclatement de c) on a hi(x) = c \nx est donc de la forme 2i k + c (avec k un entier naturel et c < 2i).\nSi k est pair (k = 2k’) alors x = 2i(2k’) + c = 2i+1 k’ + c. Donc hi+1(x) = c\nSi k est impair (k = 2k’+1) alors x = 2i(2k’+1) + c = 2i+1 k’ + 2i + c. Donc hi+1(x) = c + 2i\nLa suppression est réalisée de manière complètement symétrique à l’insertion :\nquand une certaine condition est vérifiée (par exemple, quand le facteur de chargement global\ndevient inférieur à un certain seuil Smin), on fusion"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 64,
    "text": " :\nquand une certaine condition est vérifiée (par exemple, quand le facteur de chargement global\ndevient inférieur à un certain seuil Smin), on fusionne le bloc n-1 avec le dernier bloc du fichier, on\ndécrément n et si n devient < 0, on décrémente i et on remet n au dernier bloc de la zone adressable\npar hi (2i-1). A chaque fois que i est décrémenté, la taille de F aura été divisée par 2.\nSup( x )\n Rech(x) (⇒ trouv , k )\n SI ( trouv )\nSupprimer x dans le bloc k ou dans sa zone de débordement\n SI ( facteur de charg. < Smin && i > 0 )\n // on réalise une FUSION : l'inverse d'un éclatem ent...\n n--\n SI ( n < 0 )\n i--\n n ← 2i - 1\n FSI\n - transférer le contenu du bloc 2i + n (et éventuellement de sa liste de \n débordement) dans le bloc n (et sa liste de débordement s'il est plein)\n - libérer le bloc 2i + n et sa liste de débordement si elle existe\n FSI\n FSI\nHidouci W.K. & Kermi A. / Hachage en"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 64,
    "text": "iste de débordement s'il est plein)\n - libérer le bloc 2i + n et sa liste de débordement si elle existe\n FSI\n FSI\nHidouci W.K. & Kermi A. / Hachage en MS / Structures de Fichiers (SFSD) / 2CP / ESI - 2024 62\n0 1 2\n2i-1\n3 4 5 6 7 8 9 10\nn\n11\n2i+n-1\n en cas de fusion"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 65,
    "text": "Explications de l’algorithme de localisation Adr(x) utilisé dans les différentes opérations \nd’accès (recherche, insertion et suppression)\nPour bien comprendre la principe de l’algorithme Adr(x) permettant de localiser x, il faut d’abord\ncomprendre comment le fichier F est découpé en parties accessibles par les fonctions de hachage hi\net hi+1 comme dans la figure ci-dessous :\nDans cet exemple le fichier est formé par 12 blocs (0, 1, … 11), cert ains blocs ont débordés (0, 2 et\n6). Les valeurs des paramètres actuels sont n = 4 (le prochain bloc à subir une opération\nd’éclatement) et i = 3 (le fichier a doublé de taille 3 fois). \nCela veut dire donc que n a déjà complètement parcouru le fichier (entre 0 et 2 i) 3 fois et on est\nactuellement dans le 4e passage.\nAu début du 4e passage, n était à 0, ensuite il y a eu un éclatement (celui du bloc 0) et n est passé à\n1, ensuite le bloc 1 a écla"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 65,
    "text": "ans le 4e passage.\nAu début du 4e passage, n était à 0, ensuite il y a eu un éclatement (celui du bloc 0) et n est passé à\n1, ensuite le bloc 1 a éclaté et n est passé à 2 … etc jusqu’à atteindre le bloc 4 (l’état actuel). Aux\nprochains éclatements (les blocs 4, 5, 6 et 7), n va continuer à avancer jusqu’à atteindre le bloc 8\n(23), A ce moment, le fichier aura doublé de taille pour la 4e fois, le paramètre i devra être\nincrémenté et le paramètre n réinitialisé à 0 pour entamer un 5 e passage (de 0 à 2 4 = 16) et ainsi de\nsuite … \nDonc à l’état actuel ( n = 4 et i = 3) on sait que les blocs 0, 1, 2 et 3 ont déjà éclatés (c-a-d leurs\ncontenus ont été rehacher avec hi+1 et dans ce cas, si on doit par exemple rechercher un\nenregistrement qui se trouve dans l’un des ces blocs, il faut le loca liser avec la fonction hi+1). Alors\nque les blocs 4, 5, 6 et 7 n’ont pas encore éclatés et donc pour "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 65,
    "text": " trouve dans l’un des ces blocs, il faut le loca liser avec la fonction hi+1). Alors\nque les blocs 4, 5, 6 et 7 n’ont pas encore éclatés et donc pour trouver les enregistrements qui y sont\nstockés, il faut utiliser la fonction hi uniquement. Les blocs qui restent (c-a-d entre 8 et la fin du\nfichier : 2i + n – 1 = 11) ne sont que les résultats des éclatements qui s e sont produits pour les blocs\n0,1, 2 et 3. Donc leurs contenus peuvent être retrouvés à l’aide de la fonction hi+1.\nEn résumé donc, quand on veut localiser un enregistrement x, on calcule d’abord le numéro de bloc\navec hi (cela retourne forcément un numéro entre 0 et 2 i-1), si le numéro trouvé est inférieur à n, on\nutilise alors la fonction hi+1 (car cela concerne un bloc qui a déjà éclaté). C’est le principe de\nl’algorithme Adr(x) vu au début de la section.\nHidouci W.K. & Kermi A. / Hachage en MS / Structures de Fichiers (SF"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 65,
    "text": "déjà éclaté). C’est le principe de\nl’algorithme Adr(x) vu au début de la section.\nHidouci W.K. & Kermi A. / Hachage en MS / Structures de Fichiers (SFSD) / 2CP / ESI - 2024 63\n2i-1n\n0 1 2 3 4 5 6 7 8 9 10\nhi+1 hi+1hi\n11\nn-1 2i 2i+n-10"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 66,
    "text": "Structures de Fichiers\nChapitre 6  Opérations de haut niveau sur les fichiers\nLes systèmes de bases de données utilisent des langages de requêtes de haut niveau pour la\nconsultation de grands volumes de données.\nLe langage SQL de consultation de bases de données, permet d’exprimer des requêtes simplement à\nun niveau d’abstraction élevé. Voici un exemple de requête en SQL :\nSelect E.nom, E.prenom, N.moy, M.code\nFrom Etudiant E , Notes N , Module M\nWhere E.mat = N.mat and N.code = M.code and M.annee = 2018\nOrder by N.moy desc\nL’exécution de ce type de requêtes passe par une traduction en opérations de base\n ( scan, tri,\njointure…). Il existe un ou plusieurs algorithmes pour chacune de ces opérations de base.\nL'implémentation efficace de ces opérations de base dépend souvent de la taille de la zone mémoire\nde travail allouée (en MC).\nNous allons voir dans ce chapitre l’implémentation de que"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 66,
    "text": "pérations de base dépend souvent de la taille de la zone mémoire\nde travail allouée (en MC).\nNous allons voir dans ce chapitre l’implémentation de quelques opérations de base utilisées dans le\ntraitement des requêtes de haut niveau. \n1) Opération du tri séquentiel d’un fichier\nLe tri d’un fichier de données est une opération très utilisée aussi bie n dans les requêtes elles\nmêmes (les clauses order by et unique) que dans l’implémentation d’autres opérations de base aussi.\nSi on dispose d'une zone en MC de M buffers, on peut alors trier un fichier formé de N blocs\n(souvent N >> M) avec un coût = 2N (LogM-1[N/M] + 1).\nDonc avec une complexité → O(N log(N) ).\nCet algorithme de \ntri externe se compose de deux étapes : (i) Fragmentation et (ii) Fusion.\n(i) La première étape consiste à ‘découper’ le fichier à trier en [N/M] fragments ordonnées en MS\n(en utilisant un algorithme de tri interne p"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 66,
    "text": "Fusion.\n(i) La première étape consiste à ‘découper’ le fichier à trier en [N/M] fragments ordonnées en MS\n(en utilisant un algorithme de tri interne pour ordonner chaque fragment en MC).\n(ii) La deuxième étape consiste en une ou plusieurs phases de multi-fusion (fusions par groupe de\nM-1 fragments). La fusion d’un groupe utilise en MC, M-1 buffers d'entrée et 1 buffer de sortie .\nA chaque phase de multi-fusion, le nombre de fragments est donc divisé par M-1. Les phases de\nmulti-fusion se répètent jusqu'à l'obtention d'un seul fragment (de taille N blocs) représentant le\nrésultat final du tri externe.\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 64"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 67,
    "text": "La première étape (fragmentation du fichier de N blocs en [N/M] fragments ordonnés) coûte 2N \nopérations d'accès (N lectures et N écritures), car tous les blocs du fichier en entrée sont lus une \nseule fois et réécrits une seule fois dans de nouveaux fichiers appelés ‘Fragments’.\nDans la deuxième étape, chaque phase de multi-fusion nécessite la lecture de tous les blocs des\nfragments en entrées (soit N blocs) et l'écriture d'autant de blocs réparties sur moins de fragments\nmais plus longs (le nombre total de blocs reste donc N). Chaque phase de multi-fusion coûte ainsi\n2N accès.\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 65\n[N/M] Fragments initiaux triés, de taille M blocs chacun\n Fragmentation du fichier en entrée\nFichier initial (non trié) de taille N blocs\nM buffers en MC\n(algo de tri interne)\nFusion du 1er gr de M-1 Fragments\nFus"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 67,
    "text": "entation du fichier en entrée\nFichier initial (non trié) de taille N blocs\nM buffers en MC\n(algo de tri interne)\nFusion du 1er gr de M-1 Fragments\nFusion du 3e gr de M-1 Fragments\nFusion du 2e gr de M-1 Fragments\n1er \ngrp\n2eme \ngrp\n3eme \ngrp\nnouveaux fragments\nM-1 buf \nd'entrée\n1 buf\nsortie\nanciens fragments\nMC\nOn fusionne par groupes de M-1 fragments\nUne Phase de Multi-Fusion"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 68,
    "text": "Comme à chaque phase de multi-fusion, le nombre de fragments est divisé par M-1, le nombre total\nde phases nécessaires pour avoir un seul fragment résultat est de l’ordre de LogM-1[N/M].\nLe coût total du tri externe d'un fichier de taille N blocs en utilisant M buffers en MC est donc : \n2N + 2N * LogM-1[N/M] accès disque.\nLes fragments temporaires générés par l’algorithme du tri externe, peuvent ê tre gérés comme dans\nune file d’attente (FIFO) de fragments. L’algorithme général du tri externe d’un fichier F formé par\nN blocs physiques aura alors la forme suivante :\n/* Algorithme du Tri externe */\n// F est le fichier à trier de taille N blocs\n// buf est tableau de M buffers représentant l’espace MC alloué pour le tri\n/* Etape 1 : fragmentation du fichier F en N/M fragments triés */\ni = 1 ; j = 1 ; k = 1\nTQ (i ≤ N )\nSI ( j ≤ M )\n LireBloc( F, i, buf[i] ) ; i++ ; j++\nSINON\nfragk = Tri_inter"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 68,
    "text": "on du fichier F en N/M fragments triés */\ni = 1 ; j = 1 ; k = 1\nTQ (i ≤ N )\nSI ( j ≤ M )\n LireBloc( F, i, buf[i] ) ; i++ ; j++\nSINON\nfragk = Tri_interne( buf, 1, j-1 )\n // tri interne de buf[1], buf[2], … buf[j-1]\nEnfiler( fragk , FIFO )\nk++\nj = 1\nFSI\nFTQ\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 66\nFragmentation Fusion\nM buffers\nen MC\nFichier en\nentrée de \nN blocs\nFichier en sortie\n(trié) de N blocs\nA chaque niveau le nb de \nfragments est divisé par M-1"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 69,
    "text": "// Ecriture du dernier fragment\nfragk = Tri_interne( buf, 1, j-1 ) // tri interne de buf[1], buf[2], … buf[j-1]\nEnfiler( fragk , FIFO )\n/* Etape 2 : Phases de multi-fusions … jusqu’à l’obtention d’un seul fragment */\nTQ ( la file fifo contient plus d’un élément )\n// retirer de la file les M-1 premiers fragments (ou moins, s’il n’y a pas assez)\nDefiler_groupe( M-1, r1, r2, … rj , FIFO ) // r1, r2, … rj  : les j fragments défilés\nk++\nfragk = Multi_Fusion( r1, r2, … rj )\nEnfiler( fragk, FIFO )\n// Enfiler le résultat fragk de la multi-fusion\nFTQ ;\n/* A la fin de la boucle la file FIFO contient un seul fragment : le résultat final */\nDefiler( resultat , FIFO )\n/* Fin de l’algorithme du tri externe */\nCette manière de procéder (gestion des fragments temporaires en FIFO) permet d’optimiser le\nnombre d’itérations de l’étape de multi-fusion. A chaque itération on fusion M-1 fragments\ntemporaires,"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 69,
    "text": "nts temporaires en FIFO) permet d’optimiser le\nnombre d’itérations de l’étape de multi-fusion. A chaque itération on fusion M-1 fragments\ntemporaires, même si on est à la fin d’une phase de la multi-fusion et que le nombre de fragments\nrestants dans cette phase est inférieur à M-1. Le mécanisme de la file FIFO nous permet dans ce cas\nparticulier de compléter le nombre de fragments à fusionner (pour atteindre M-1 fragments) en\nprélevant des nouveaux fragments de la prochaine phase (qui se trouvent forcément en tête de file).\nCi-dessous les grandes lignes de l’algorithme de la multi-fusion d’un groupe de k fichiers\nordonnés, en utilisant k+1 buffers en mémoire centrale (MC) :\n// En entrée : k fichiers ordonnés F1, F2, … Fk de tailles respectives N1, N2, ...Nk blocs\n// En sortie : un fichier ordonné G contenant tous les enregistrements des fichiers en entrée\n// buf est un tableau de k+1 buf"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 69,
    "text": "ves N1, N2, ...Nk blocs\n// En sortie : un fichier ordonné G contenant tous les enregistrements des fichiers en entrée\n// buf est un tableau de k+1 buffers représentant l’espace MC alloué pour la multi-fusion\n// ind est un tableau de k+1 entiers représentants les indice de parcours des buffers associés\n// numBloc est un tableau de k+1 entiers représentants les numéros de blocs des k+1 fichiers\nLa fonction PlusPetit-existe( e ) récupère dans e le plus petit enregistrement parmi :\nbuf[1].Tab[ ind[1] ] , buf[2].Tab[ ind[2] ] , … , buf[k].Tab[ ind[k] ]\nL’indice associé à e (ind[i]) est incrémenté en conséquence, et s’il dépasse le nombre d’élément s\ndans le buffer associé, le prochain bloc du fichier d’entrée associé ( F[i]) sera lu et l’indice associé\n(ind[i]) sera remis à 1.\nSi le fichier associé (F[i]) a été complètement lu (c-a-d numBloc[i] > Ni), il ne sera plus considéré.\nSi tous les fi"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 69,
    "text": "associé\n(ind[i]) sera remis à 1.\nSi le fichier associé (F[i]) a été complètement lu (c-a-d numBloc[i] > Ni), il ne sera plus considéré.\nSi tous les fichiers en entrée ont été complètement lus, la fonction PlusPetit-existe retournera faux.\n/* Algorithme de la multi-fusion */\n/* Lecture des premiers blocs de chaque fragment et initialisations */\nPour i = 1..k\nLireBloc( Fi , 1 , buf[i] )\nind[i] = 1 \n// en initialisant les indices de parcours et\nnumBloc[i] = 1 // les numéros de blocs (fichiers en entrée)\nFP ;\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 67"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 70,
    "text": "ind[k+1] = 1 ; numBloc[ k+1 ] = 1 // pour le fichier sortie aussi\n/* Boucle principale de la multi-fusion : k buffers en entrée vers 1 buffer de sortie */\nTQ ( PlusPetit-existe( e ) ) // retourne dans e le plus petit enreg non encore considéré \n// dans les k buffers d’entrée. \nbuf[ k+1 ].Tab[ ind[k+1] ] = e // mettre e dans le buffer de sortie\nind[k+1]++\nSI ( ind[ k+1 ] > b )\n// écrire le buffer de sortie s’il est plein\nEcrireBloc( G , numBloc[k+1], buf[k+1] )\nnumBloc[k+1]++\nind[k+1] = 1\nFSI\nFTQ\n/* Ecriture du dernier bloc de G */\nSI (ind[ k+1 ] > 1 ) EcrireBloc( G, numBloc[k+1], buf[k+1] ) FSI\n/* Ecritures des entêtes et Fermetures des fichiers */\n…\n/* Algorithme de la multi-fusion */\n2) Opération de jointure séquentielle de deux fichiers\nLa jointure de deux fichiers est un genre de produit cartésien avec un filtre, sous forme de condition\npermettant de sélectionner les enregistrements "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 70,
    "text": "La jointure de deux fichiers est un genre de produit cartésien avec un filtre, sous forme de condition\npermettant de sélectionner les enregistrements à concaténer dans le résultat final.\nSoient F1 et F2 deux fichiers de tailles respectives N1 et N2 blocs. La jointure de F1 et F2 selon\nune condition C, consiste pour chaque couple d’enregistrements <e1,e2> de F1 et F2, à produire un\nnouvel enregistrement en concaténant e1 et e2 dans un nouveau fichier résultat, à condition que les\nattributs de e1 et e2 vérifient la condition donnée C.\nDans le cas général, la condition C est formée d’opérateurs binaires faisant intervenir un opérande\nde chaque fichier : attrF1 <op> attrF2, avec <op> un opérateur binaire : = , < , > , ≥ , ≤ …\nExemple : Soit à joindre deux fichiers F1 et F2.\nF1(mat, nom, prenom) représente un fichier d’étudiants caractérisés par un matricule (mat), un nom \net un prénom.\nF2(ma"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 70,
    "text": "oindre deux fichiers F1 et F2.\nF1(mat, nom, prenom) représente un fichier d’étudiants caractérisés par un matricule (mat), un nom \net un prénom.\nF2(mat, code, moy) représente un fichier de notes où chaque enregistrement représente la moyenne \n(moy) obtenue par un certain étudiant (mat) dans un certain module (code)\n F1 mat | nom | prenom F2 mat | code | moy\n---------|--------|------------- ---------|--------|-----------\n 100 | aaaa | bbbb 400 | sfsd | 12\n 200 | cccc | dddd 400 | poo | 14\n 300 | eeee | fffff 100 | sfsd | 15\n 400 | gggg | mmm 300 | stat | 11\n La jointure de F1 et F2 sur la condition : (F1.mat = F2.mat) donne le résultat suivant :\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 68"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 71,
    "text": "F1.mat | nom | prenom |F2.mat| code | moy\n ---------|--------|-----------------|--------|--------|-----------\n 100 | aaaa | bbbb | 100 | sfsd | 15\n 300 | eeee | fffff | 300 | stat | 11\n 400 | gggg | mmm | 400 | sfsd | 12\n 400 | gggg | mmm | 400 | poo | 14\nPour implémenter l’opération de jointure de deux fichiers, nous supposerons par la suite que nous\ndisposons d’un espace en MC de taille suffisante pour maintenir M buffers (généralement M << N1\net M << N2 ).\nIl existe trois grandes classes d’algorithmes de jointure : \n‘Boucles-Impriquées’, ‘Tri-Fusion’ et ‘Hachage’.\n- Algorithme de jointure par ‘Boucles Imbriquées’ (Nested-Loop join algorithm)\nC’est l’algorithme de base pour la jointure dans le cas général (quelque soit le type de la condition).\nCet algorithme est composé de deux boucles imbriquées : une boucle externe et une boucle interne.\nDans la boucle externe\n, on parcourt F1 en ch"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 71,
    "text": "tion).\nCet algorithme est composé de deux boucles imbriquées : une boucle externe et une boucle interne.\nDans la boucle externe\n, on parcourt F1 en chargeant, à chaque itération, M-2 blocs à la fois.\nPour chaque fragment de F1 en MC (occupant M-2 buffers), on parcourt dans la boucle interne le\nfichier F2 bloc par bloc (1 buffer) et on réalise la jointure (en MC) entre les M-2 buffers de F1 et\nl'unique buffer de F2. Un dernier buffer est utilisé pour l'écriture des résultats (buffer de sortie)\nCi-dessous un pseudo-algorithme de type 'boucles imbriquées' :\n \n/* Boucle externe pour parcourir F1 */\n Pour chaque fragment Fr de F1 (lecture en MC de M-2 blocs de F1 )\n/* Boucle interne pour parcourir F2 */\nPour chaque bloc B de F2 (lecture en MC d'un bloc de F2 )\n/* jointure en MC de Fr avec B */\nPour chaque enreg e1 dans Fr\nPour chaque enreg e2 dans B\nSi C(e1,e2) rajouter <e1.e2> au buffer de s"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 71,
    "text": "un bloc de F2 )\n/* jointure en MC de Fr avec B */\nPour chaque enreg e1 dans Fr\nPour chaque enreg e2 dans B\nSi C(e1,e2) rajouter <e1.e2> au buffer de sortie R\nSi le buffer R est plein, le vider sur disque\nFP\nFP\nFP \n/* fin boucle interne */\n FP /* fin boucle externe */\nLe fichier F1 est lu une seule fois (soit un coût de N1 lectures). A chaque itération de la boucle\nexterne, un fragment de F1 est lu (de taille M-2 blocs). \nLe nombre d'itérations de la boucle externe est donc : [N1 / (M-2)]. (la parie entière supérieure)\nLe fichier F2 est lu entièrement (dans la boucle interne) pour chaque itération de la boucle externe. \nLe coût en opération de lecture est alors = N1 + N2 * [N1 / (M-2)] lectures de blocs.\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 69"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 72,
    "text": "Le coût en écriture ( a) dépend de la condition C. Dans le pire des cas ( C est vérifiée pour chaque\ncouple d'enregistrements <e1,e2> de F1 et F2). Le coût en écriture serait alors (n1 * n2) / b , avec\nn1 et n2 les nombres d'enregistrements des fichiers F1 et F2 et b la capacité maximale d’un bloc. Si\npar contre la condition C n'est vérifiée par aucun couple, a vaut 0. C’est le cas le plus favorable. \nLe coût total de l'algorithme de jointure par ‘boucles imbriquées’ est donc :\nN1 + N2 * [N1/(M-2)] + a opérations d'E/S.\n- Algorithme de jointure par ‘Tri-Fusion’ (Sort-Merge join algorithm)\nL'idée dans l’algorithme de jointure par tri-fusion est de trier d’abord les fichiers F1 et F2, puis\nparcourir les deux fichiers triés (en une seule passe) de la même manière que l'algorithme de fusion.\nCette algorithme ne s'applique que si la condition de jointure est l'égalité des attributs (c-a-d de "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 72,
    "text": ") de la même manière que l'algorithme de fusion.\nCette algorithme ne s'applique que si la condition de jointure est l'égalité des attributs (c-a-d de la\nforme attrF1 = attrF2). On parle alors d'équi-jointure.\nL’algorithme nécessite, au minimum, 3 buffers en MC. Deux buffers pour parcourir les deux\nfichiers en entrée et un 3e buffer pour la sortie (écriture du résultat dans le fichier de sortie), donc M\n= 3. Le traitement des valeurs multiples nécessite cependant un espa ce supplémentaire en MC pour\néviter les éventuels retours arrières générant des opérations de lectures physiques supplémentaires.\nCi-dessous un algorithme possible tenant compte du traitement (en MC) des valeurs multiples :\n/* Algorithme de jointure : Tri-Fusion */\n/* Déclaration des fichiers et zones tampons: */\nTbloc1 = struct\ntab[b1] de Tenreg1\nNB : entier\n Fin\nTbloc2 = struct\ntab[b2] de Tenreg2\nNB : entier\n Fin\nTbloc3"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 72,
    "text": "ation des fichiers et zones tampons: */\nTbloc1 = struct\ntab[b1] de Tenreg1\nNB : entier\n Fin\nTbloc2 = struct\ntab[b2] de Tenreg2\nNB : entier\n Fin\nTbloc3 = struct\ntab[b3] de Tenreg3\nNB : entier\n Fin\nF1 : Fichier de Tbloc1 buffer buf1, entete(entier \n/* num du dernier bloc */ )\nF2 : Fichier de Tbloc2 buffer buf2, entete(entier /* num du dernier bloc */ )\nF3 : Fichier de Tbloc3 buffer buf3, entete(entier /* num du dernier bloc */ )\nE : Tableau[m] de Tenreg2 /* m représente le plus grand nombre d'occurrence des \n valeurs multiples dans F2 */\nOuvrir(F1, \"...\", 'A') \nOuvrir(F2, \"...\", 'A') \nOuvrir(F3, \"...\", 'N')\ni1 = 1; i2 = 1; i3 = 1 \nj1 = 1; j2 = 1; j3 = 1\nlireDir(F1, 1, buf1)\nlireDir(F2, 1, buf2) \nFinF1 = faux\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 70"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 73,
    "text": "FinF2 = faux\nTQ ( Non FinF1 && Non FinF2 )\nts = buf2.tab[j2]; k = 1; E[k] = ts; k++; j2++\nSi (j2 > b2)\ni2++ \nSi ( i2 ≤ entete(F2,1) ) \nlireDir(F2, i2, buf2)\nj2 = 1\nSinon \nFinF2 = vrai\nFsi\nFsi\nstop = faux\nTQ ( non stop && non FinF2 )\nt = buf2.tab[j2] \nSi (t.attr == ts.attr) \n/* attr : attribut de jointure */\nE[k] = t \nk++ \nj2++ \nSi (j2 > b2)\ni2++\nSi ( i2 ≤ entete(F2,1) ) \nlireDir(F2, i2, buf2) \nj2 = 1\nSinon \nFinF2 = vrai\nFsi\nFsi\nSinon \nstop = vrai \nFsi\nFTQ \n // ( non stop && non FinF2 )\ntr = buf1.tab[j1]\nTQ ( non FinF1 && tr.attr < ts.attr )\nj1++ \nSi (j1 > b1)\ni1++\nSi ( i1 ≤ entete(F1,1) ) \nlireDir(F1, i1, buf1)\nj1 = 1\nSinon\nFinF1 = vrai\nFsi\nFsi\ntr = buf1.tab[j1]\nFTQ \n// ( non FinF1 && tr.attr < ts.attr )\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 71"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 74,
    "text": "TQ ( non FinF1 && tr.attr == ts.attr ) // Test de la condition de jointure C\nPOUR (i=1,k-1) \nts = E[i]\n/* ajouter <tr.ts> dans le résultat */\nbuf3[j3] = <tr.ts> // concaténation de tr et ts\nj3++\nSi (j3 > b3) buf3.NB = b3\necrireDir(F3, i3, buf3)\nbuf3[1] = <tr.ts>\ni3++\nj3 = 2\nFsi\nFP\nj1++\nSi (j1 > b1)\ni1++\nSi ( i1 ≤ entete(F1,1) ) lireDir(F1, i1, buf1); j1 = 1\nSinon FinF1 = vrai\nFsi\nFsi\ntr = buf1.tab[j1]\nFTQ \n// ( non FinF1 && tr.attr == ts.attr )\nFTQ // ( Non FinF1 && Non FinF2 )\n/* Dernière écriture dans F3 */\nSi (j3 > 1) buf3.NB = j3 - 1\necrireDir(F3, i3, buf3)\ni3++\nFsi\nAff_entete(F3, 1, i3 - 1) \n// numero du dernier bloc de F3\nFermer(F1); Fermer(F2); Fermer(F3)\n/* Fin de l’algorithme de jointure par tri-fusion */\nLe coût de cet algorithme, en opérations de lectures, est celui du t ri des deux fichiers en entrée plus\ncelui de la fusion :\nN1(1 + LogM-1[N1/M]) + N2(1 + LogM-1[N2/M]) + (N1 "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 74,
    "text": " en opérations de lectures, est celui du t ri des deux fichiers en entrée plus\ncelui de la fusion :\nN1(1 + LogM-1[N1/M]) + N2(1 + LogM-1[N2/M]) + (N1 + N2) lectures de blocs\n –-- tri de F1 –--- –--tri de F2 ---- -Fusion-\nLe coût en opérations d'écriture est celui associé au tri des 2 fi chiers plus celui de la génération du\nrésultat de la jointure lors de la phase de fusion (dépend de la condition C). Appelons a ce dernier\ncoût dépendant de la condition. On aura donc :\nN1(1 + LogM-1[N1/M]) + N2(1 + LogM-1[N2/M]) + \na écritures de blocs\n –-- tri de F1 –--- –--tri de F2 ---- -Fusion-\nDonc l \ne coût total (en nombre de lectures et d'écritures) de l'algorithme de jointure 'Tri-Fuision',\nen supposant que le fichier résultat occupera a blocs, est estimé à :\n2N1(1 + LogM-1[N1/M]) + 2N2(1 + LogM-1[N2/M]) + (N1 + N2 + a) op. d'E/S.\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 74,
    "text": " estimé à :\n2N1(1 + LogM-1[N1/M]) + 2N2(1 + LogM-1[N2/M]) + (N1 + N2 + a) op. d'E/S.\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 72"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 75,
    "text": "- Jointure par Hachage (Hash join algorithm)\nLe principe de cet algorithme d'équi-jointure (la condition C doit être de type « égalité » aussi :\nF1.attr = F2.attr) est de fragmenter les deux fichiers en entrée à l'aide d'une foncti on de hachage h,\nde sorte qu'un enregistrement e, soit stocké dans le fragment d'indice h(e.attr). On obtient alors les\nfragments suivants :\nF1 = < r0 , r1 , r2 , … rn-1 >\nF2 = < s0 , s1 , s2 , … sn-1 >\nLa jointure de F1 avec F2 se réalise ensuite avec plusieurs petites jointures indépendantes : \nr0 * s0 , r1 * s1 , … rn-1 * sn-1\nChacune de ces petites jointures ( ri * si) est supposée être réalisable en MC. On doit donc disposer\nd'un espace en MC ayant une taille suffisante pour charger le plus grand fragment d'un des deux\nfichiers en entrée.\nCi-dessous un pseudo-algorithme de jointure par hachage :\n// Pour le partitionnement on utilise n buffers de sortie en"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 75,
    "text": "un des deux\nfichiers en entrée.\nCi-dessous un pseudo-algorithme de jointure par hachage :\n// Pour le partitionnement on utilise n buffers de sortie en MC\nPartitionner F1 en r0, r1, ... rn-1 ;\nPartitionner F2 en s0, s1, ... sn-1 ; \nPOUR i = 0 , n-1\n/* Construction d’un index par hachage du fragment 'si' : étape du Build */\nLire bloc par bloc, le frag 'si' et construire un index par hachage en MC\n(en utilisant une autre fonction de hachage, différente de h) \n/* Jointure entre les enreg de 'ri' et ceux de 'si' : étape du Probe */\nPOUR chaque enreg tr dans le frag 'ri' (lire 'ri' bloc par bloc)\n- récupérer avec l'index en MC les enreg ts ayant la même \n val d'attr que tr ( =condition de jointure C)\n- POUR chaque ts récupéré\nrajouter la concaténation <ts.tr> dans le résultat\n FP\nFP\nFP\nDans la phase de partitionnement, les deux fichiers d'entrée ( F1 et F2) sont lus une seule fois (donc\nN1 + N"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 75,
    "text": "ation <ts.tr> dans le résultat\n FP\nFP\nFP\nDans la phase de partitionnement, les deux fichiers d'entrée ( F1 et F2) sont lus une seule fois (donc\nN1 + N2 lectures de blocs). Le nombre de blocs utilisés pour former l'ensemble de s fragments ri et\nsi est au minimum égal à N1 + N2 blocs et au maximum N1 + N2 + 2n blocs (dans ce dernier cas,\nchaque fragment se termine par un bloc additionnel non plein). De ce fait, le coût en opérations de\nlecture et écriture de la phase de partitionnement est borné par : 2(N1 + N2) + 2n op. d'E/S.\nDans la deuxième partie de l'algorithme, les étapes 'Build' et 'Probe' nécessitent la lecture de tous les\nfragments ri et si une seule fois. Soit au maximum N1 + N2 + 2n opérations de lectures.\nLa taille (\na) du fichier résultat dépend principalement de la condition C. Ainsi le coût total de\nl'algorithme de jointure par hachage est : 3(N1 + N2) + 4n + a opérations d"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 75,
    "text": "r résultat dépend principalement de la condition C. Ainsi le coût total de\nl'algorithme de jointure par hachage est : 3(N1 + N2) + 4n + a opérations d'E/S.\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 73"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 76,
    "text": "3) Parallélisation des opérations sur les fichiers\nSouvent les accès aux données externes (les fichiers) représentent le principal goulot d’étranglement\npour les performances des applications de traitement de données massives. La répartition des\ndonnées sur différents nœuds de calcul (architecture en cluster par exemple) permet souvent\nd’améliorer l’efficacité si la parallélisation est bien faite. \nNous nous intéressons ici à l’architecture dite ‘à mémoire distribuée’ (shared nothing) où chaque\nnœud du cluster renferme une unité de calcul ( CPU), une mémoire centrale ( MC) et une mémoire\nsecondaire (MS). Les nœuds sont supposés être connectés par un réseau haut débit. La\ncommunication se fait exclusivement par envoi de messages (message passing model).\nPour programmer des applications sur ce type d’architecture, on peut utilise r les API systèmes déjà\nexistantes sur chaque nœud (comme pa"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 76,
    "text": "sing model).\nPour programmer des applications sur ce type d’architecture, on peut utilise r les API systèmes déjà\nexistantes sur chaque nœud (comme par exemple la combinaison : Sockets BSD et Processus\nlocales, sur un réseau TCP/IP). On peut aussi utiliser des librairies spécifiques au modèle ‘Me ssage\nPassing’ (comme MPI ou PVM) ou alors des frameworks de parallélisation automatique (comme\nMapReduce ou Spark). Les deux premiers outils (Socket/Processus et Message-Passing) sont\ndestinés à des programmeurs de haut niveau technique, maîtrisant les as pects théoriques de la\nprogrammation parallèle (Les ordres partiels, la synchronisation, la théorie de la sérialisabilité, le\nrecouvrement …). Ils sont un peu difficiles à utiliser mais permettent généralement des solutions\nefficaces et très optimisées. Les frameworks de parallélisation a utomatiques sont beaucoup plus\nfacile à utiliser et son"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 76,
    "text": "t généralement des solutions\nefficaces et très optimisées. Les frameworks de parallélisation a utomatiques sont beaucoup plus\nfacile à utiliser et sont destinés principalement à des programmeurs n’a yant pas obligatoirement de\ntelles connaissances théoriques sur la programmation parallèle. Leur but est d’utiliser le plus\nfacilement et le plus rapidement possible un cluster à travers un langage séquentiel bien maîtrisé. La\nparallélisation (souvent simpliste mais à grande échelle) est en fait effectuée automatiquement par\nle framework d’exécution, déchargeant le programmeur des aspect complexes liés à la répartition de\ncharges, de synchronisation, de recouvrement, ...etc.\nLes solutions parallèles des opérations sur fichiers, peuvent améliorer très significativement les\nperformances si les données sont bien réparties entre les différents nœuds du cluster. L’accélération\nobtenue peut ainsi ê"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 76,
    "text": " très significativement les\nperformances si les données sont bien réparties entre les différents nœuds du cluster. L’accélération\nobtenue peut ainsi être maximale lorsque les différentes ressources disponibles sont bien exploitées.\nUne mauvaise répartition des données peut facilement provoquer un déséquilibre de charge où\ncertains nœuds auront beaucoup de travail à faire alors que d’autres seront sous-ut ilisés, induisant\nune utilisation non optimisée du cluster. Les effets d’un mauvais équil ibrage de charge ou d’une\nforte contention sur les ressources partagées peuvent induire une très forte dégradation des\nperformances.\nNous allons présenter dans ce qui suit, les approches de parallélisation des opérations de tri, de\nmulti-fusion et de jointure. Nous terminerons cette section par un survol e rapide des traitements\nparallèles en présence d’opérations de mises à jours tels que rencontré"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 76,
    "text": "ointure. Nous terminerons cette section par un survol e rapide des traitements\nparallèles en présence d’opérations de mises à jours tels que rencontré dans le cadre des transactions\nconcurrentes et/ou réparties (OLTP) et un mot sur le contexte ‘ Big Data’ nécessitant les traitements\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 74\n MS\n MC\ncpu\n MS\n MC\ncpu\n MS\n MC\ncpu\n MS\n MC\ncpu\nRéseau haut débit (ex. LAN)\nNœud_1 Nœud_2 Nœud_3 Nœud_4\nCluster de 4 nœuds"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 77,
    "text": "de consultation massivement parallèles.\n- Le tri parallèle\nIl y a deux grandes approches pour la parallélisation de l’algorithme du tri externe sur un cluster\nformé de k nœuds :\n1- On peut découper équitablement (en nombre d’enregistrements) le fichier à trier en k fragments\nde tailles similaires. Chaque fragment fragi sera trié au niveau d’un nœuds Ni du cluster. Ainsi les\ndifférents fragments seront triés en parallèle. Les résultats des tris des différents fragments sont\nensuite récoltés et fusionnés pour reconstituer le fichier final trié.\n2- On peut aussi partitionner le domaine des valeurs de la clé en k intervalles ( Interv₁, Interv …₂\nIntervk ) et fragmenter par valeurs le fichier à trier, de telle sorte à former k fragments. Chaque\nfragment fragi ne contient que des valeurs appartenant à l’intervalle Intervi et sera trié au niveau du\nnœud Ni du cluster. A la fin, on récupère les "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 77,
    "text": "fragment fragi ne contient que des valeurs appartenant à l’intervalle Intervi et sera trié au niveau du\nnœud Ni du cluster. A la fin, on récupère les résultats des différents tris pour les concaténer et\nformer le fichier final trié.\nNous pouvons remarquer que dans la première approche, les différents nœuds auront une charge de\ntravail équitable (car les fragments sont pratiquement de même taill e), par contre l’opération de\nfusion (en O(n)) des résultats se déroulera en séquentiel sur un seul nœud, ce qui e ngendre au final\nun fort déséquilibre de charge et une sous-utilisation des ressources disponibles . Ce problème est\névité dans la deuxième approche, car la concaténation des résultats e st une opération très rapide (en\nO(1)). Par contre la fragmentation par valeurs (en intervalles) nécessaire pour le lancement de la\ndeuxième approche détériore la qualité de la solution car elle doit "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 77,
    "text": " la fragmentation par valeurs (en intervalles) nécessaire pour le lancement de la\ndeuxième approche détériore la qualité de la solution car elle doit s’effe ctuer (en O(n)) dans un seul\nnœud.\nCes deux solutions naïves peuvent être améliorées. Pour la première solut ion, l’opération de fusion\nfinale peut se réaliser en parallèle sur plusieurs nœuds (voir fusion para llèle ci-dessous). Pour la\ndeuxième solution, la fragmentation par intervalle peut se faire de manière incrémentale. Les\ndonnées sont envoyés par petits blocs aux différents nœuds au fur et à mesure que le fichier en\nentrée est parcouru par le nœuds initial. Cela permet à chaque nœud de calcul d’entamer le\nprocessus de tri sans attendre que tout le fragment soit disponible dans sa mémoire locale. \nFusion parallèle (c’est une multi-fusion parallèle de k fragments triés) :\nChaque nœuds N1, N2, …. Nk dispose d’un fragment trié da"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 77,
    "text": "a mémoire locale. \nFusion parallèle (c’est une multi-fusion parallèle de k fragments triés) :\nChaque nœuds N1, N2, …. Nk dispose d’un fragment trié dans sa mémoire locale. Le résultat de la\nmulti-fusion sera transmis à un nœud maître M (qui peut être l’un des nœuds N1, N2, ...Nk).\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 75\n. . . . .\nNkN4N3N2\nb1\nb2\nb3\nbk-1\n. \n. \n.\nN1\nb0\nbk\nP1,1\nP1,2\nP1,3\nP1,k\nP2,1\nP2,2\nP2,3\nP2,k\n.\n. \nP3,3\nP3,2\nP3,1\nP3,k P4,k\nP4,3\nP4,2\nP4,1\nPk,1\nPk,2\nPk,3\nPk,k\n.\n. \n.\n. \n.\n.\n."
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 78,
    "text": "Pour réaliser la fusion de ces k fragments en parallèle, l’ un des nœuds (N1 par exemple) effectue\nce qui suit : \n1) Découpage du fragment trié en k parties égales : \n P 1,1 = ]-∞ – b1] , P1,2 = ]b1 – b2] , … , P1,k = ]bk-1 – +∞[ \n k-1 bornes sont ainsi déterminées ( b 1, b2, … bk-1 ).\n2) Diffusion des bornes ( b1, b2, … bk-1 ) à tous les autres nœuds (N2, N3, … Nk).\n3) Envoi à chaque nœud Nj (j=2...k), la jème partie (P1,j = ]bj-1 .. bj]) du fragment local.\n4) Attendre des autres nœuds les 1eres parties de leurs fragments respectifs (les Pi,1 avec i =2...k).\n5) Effectuer une multi-fusion (séquentielle) entre les parties reçues et celle locale au nœud  :\n Res = MultiFusion( P₁ 1,1 , P2,1 , P3,1 , … Pk,1 ) \n6) Envoi du résultat Res au nœud maître M.₁\nDe son coté, chacun des autres nœuds Ni (i = 2...k) doit effectuer les actions suivantes :\n1) Attendre la réception des bornes ( b1, b2, … b"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 78,
    "text": "aître M.₁\nDe son coté, chacun des autres nœuds Ni (i = 2...k) doit effectuer les actions suivantes :\n1) Attendre la réception des bornes ( b1, b2, … bk-1 ) provenant de N1\n2) Pour chaque borne bj (j =1...k-1), effectuer une recherche dichotomique dans le fragment local pour \nlocaliser l’indice où elle devrait se positionner : indj = Rech_dicho( Fragi , bj )\n3) A l’aide des indices trouvés ind , ind … ind₁ ₂ k-1, découper le fragment local (Fragi) en k parties :\nPi,1 , Pi,2 , … Pi,k. Puis envoyer à chaque nœud Nj (j=1 … k et j ≠ i) la partie qui le concerne : Pi,j .\n4) Attendre des autres nœuds les ièmes parties de leurs fragments respectifs (Pj,i avec i =1...k et j≠i).\n5) Effectuer une multi-fusion (séquentielle) entre les parties reçues et celle locale au nœud  :\n Res i = MultiFusion( P1,i , P2,i , P3,i , … Pk,i ) \n6) Envoi du résultat Resi au nœud maître M.\nLe nœud maître M concatène ("
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 78,
    "text": " celle locale au nœud  :\n Res i = MultiFusion( P1,i , P2,i , P3,i , … Pk,i ) \n6) Envoi du résultat Resi au nœud maître M.\nLe nœud maître M concatène (en O(1)) les différents résultats reçus (res , res … res₁ ₂ k) des autres \nnœuds pour former le résultat final trié.\n- La jointure parallèle\nPour réaliser une jointure entre deux fichiers R et S, on utilise toujours le principe de la répartition\ndes données entre les différents nœuds de calcul disponibles, puis on effectue des jointures\nindépendantes en parallèle dans chaque nœud de calcul et on termine en combinant les résultats\nobtenus.\n \nUne première solution consiste à découper un des fichiers ( R par exemple) en parties de tailles\négales (r1, r2, … rk ). Puis on envoie à chaque nœud de calcul Ni, la ième partie ri de R ainsi que le\ncontenu du deuxième fichier S en entier pour que Ni puisse calculer la jointure ri * S.\nLes résultats des"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 78,
    "text": "lcul Ni, la ième partie ri de R ainsi que le\ncontenu du deuxième fichier S en entier pour que Ni puisse calculer la jointure ri * S.\nLes résultats des différentes jointures indépendantes ri * S sont ensuite concaténées au niveau du\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 76"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 79,
    "text": "nœud maître pour former le résultat.\nCette solution découpe la charge de travail de manière équitable, mais la taille des sous-problèmes\ngénérés (S n’est pas découpé en parties) reste éventuellement importante (surtout e n présence de\nfichiers volumineux). Cette première solution s’applique pour des jointures avec une condition\nquelconque (ainsi que les opérations analogues : Résolution d’Entités par exemple dans le cas\ngénéral).\nL’idée pour une deuxième solution plus efficace (mais restreinte uniquement a ux équi-jointures),\nest de s’inspirer de l’algorithme de jointure par hachage pour proposer une approche où les deux\nfichiers R et S, sont fragmentés par valeurs.\nPour fragmenter un fichier par valeurs, en k fragments, il y a deux possibilités :\n- Soit utiliser une fonction de hachage h (avec un ensemble d’arrivées de cardinalité k) pour obtenir\nk fragments contenant chacun des données"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 79,
    "text": "lités :\n- Soit utiliser une fonction de hachage h (avec un ensemble d’arrivées de cardinalité k) pour obtenir\nk fragments contenant chacun des données ayant la même image par la fonction h (des synonymes).\n- Soit partitionner le domaine des valeurs de l’attribut de jointure en k intervalles et utiliser les\nbornes de la partition pour fragmenter le fichier par valeur en k intervalles.\nDans les deux cas, on obtiendra des fragment de R et S où les équi-jointures ne sont possibles\nqu’entre fragments ayant le même indice : \nR = r1 , r2 , r3 , …. rk\nS = s1 , s2 , s3 , …. sk\nAu niveau de chaque nœud Ni, on effectue une des petites jointures : ri * si\nLes résultats des k jointures effectuées en parallèle seront concaténés au niveau du nœud maître :\nR * S = (r1 * s1) \n∪ (r2 * s2) … ∪ (rk * sk)\nL’inconvénient de cette deuxième solution est que la fragmentation par val eurs n’assure pas dans\ntous l"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 79,
    "text": "\nR * S = (r1 * s1) \n∪ (r2 * s2) … ∪ (rk * sk)\nL’inconvénient de cette deuxième solution est que la fragmentation par val eurs n’assure pas dans\ntous les cas, un découpage équitable en termes de taille des fragment s. D’où une possible exécution\nparallèle déséquilibrée.\nBeaucoup de travaux de recherche ont abordé ce problème de déséquilibre de charge dû à la\nrépartition des données (data skew).\n- Les opérations de mises à jours\nDans un contexte d’exécution parallèles des opérations d’accès aux fichiers, les opérations de mises\nà jours (insertions, suppression et modification des enregistrements) doivent être exécutées en\nsuivant rigoureusement des protocoles d’accès adéquats garantissant des exécuti ons concurrentes et\ncorrectes (sans incohérences).\nLes incohérences pouvant être introduites dans les données, proviennent soit d’une exécution\nconcurrente non conforme à l’ordre séquentiel de"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 79,
    "text": "rences).\nLes incohérences pouvant être introduites dans les données, proviennent soit d’une exécution\nconcurrente non conforme à l’ordre séquentiel des opérations d’accès, soit de pannes systèmes (par\nexemple arrêt brutal causé par une interruption de l’alimentation électr ique) provoquant l’exécution\nincomplète de certaines tâche modifiants les données. Ces aspects liés à la correction des exécutions\nconcurrentes sont étudiés dans le cadre de théorie de la sérialisabilité des opérations d’accès aux\ndonnées et des techniques de recouvrement et reprise sur panne.\nLes systèmes OLTP (Online Transaction Processing) où des bases de données sont manipulées par\nun grand nombre d’applications clientes concurrentes, pouvant effectuer des mises à jours en-ligne,\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 77"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 80,
    "text": "sont très utilisés pour la gestion des bases de production. L’une des métri ques de performances les\nplus importantes dans ce type de système est le ‘débit transactionnel’ représentant le nombre de\ntransactions validées (effectuées avec succès) par seconde. Parmi le s protocoles de contrôle d’accès\naux données les plus utilisés dans ces systèmes, nous pouvons citer : le verrouillage à 2 phases\n(2PL), l’ordonnancement par estampillage (TO) et les nouveaux schémas mult i-versions\nsérialisables (comme SSI par exemple). Pour ce qui est de la repris e et de la persistance des\nmodifications, les protocoles de journalisation (comme WAL : Write-Ahead Logging), en plus de\ncelui de la validation atomique (ex : 2PC) dans le cas des systèm es répartis sur plusieurs nœuds de\ncalcul, sont très utilisés dans les systèmes actuels.\n- Le contexte ‘Big Data’\nDe nos jours la quantité de données générées par"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 80,
    "text": "sur plusieurs nœuds de\ncalcul, sont très utilisés dans les systèmes actuels.\n- Le contexte ‘Big Data’\nDe nos jours la quantité de données générées par les différentes applications est gigantesque (traces\ndes internautes, fichiers logs des serveurs, bases de données semi-structuré s des réseaux sociaux,\ndonnées de mesures générés par des capteurs ou des dispositifs connectés de l’IoT …). De plus, les\npossibilités de stockage actuelles ont rendu possible la persistance de ces données à des fins\nd’analyses et d’études de tout genre (analyse de données, études comportementale s, statistiques,\nextraction de connaissances, apprentissage, ...). \nL’accès efficace à ces données serait, en théorie, possible à condi tion d’avoir le temps de les\nstructurer (par exemple en B-arbres, Hachage dynamique … et en général vers des bases de données\nfortement structurées). Le problème est que la vitesse avec"
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 80,
    "text": "urer (par exemple en B-arbres, Hachage dynamique … et en général vers des bases de données\nfortement structurées). Le problème est que la vitesse avec laquelle c es données sont produites est\nplus grande que celle nécessaire pour bien les structurer, car elles s ont nombreuses, variées et\ngénérées en quasi-continu. Dans ce contexte, dit de ‘ Big Data’, où certaines applications doivent\nanalyser rapidement l’information massive générée en peu de temps, l’utilisation des grands clusters\nde calcul offre une solution relativement acceptable. Le stockage est généralement réalisé en vrac\nsur des systèmes de fichiers répartis, qui fragmentent automatiquement les données sur un grand\nnombre de nœuds (de manière rapide et simpliste). Les programmes d’analyse s ont massivement\nparallélisés (le plus souvent automatiquement avec des frameworks de calc ul parallèle ou dans\ncertains cas, manuellement "
  },
  {
    "file": "polycopie_SFSD (1).pdf",
    "page": 80,
    "text": "d’analyse s ont massivement\nparallélisés (le plus souvent automatiquement avec des frameworks de calc ul parallèle ou dans\ncertains cas, manuellement avec des librairies de type Message-pa ssing ou autres) pour espérer des\ntemps de réponses raisonnables.\nHidouci W. K. & Kermi A. / Opérations de haut niveau / Structures de fichiers (SFSD) / ESI - 2024 78"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 1,
    "text": "Devoir S F S D \n \nLes algorithmes de : \n* Recherche \n * Insertion \n * Suppression \n * Requête a intervalle \n \n \n \n Les membres : \n * Touati Kamel \n* Hamrani Ferroudja \n* Hadjebar Mounia \n* Habi yasmine"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 2,
    "text": "1 \nType : TOF \n \ntype tbloc : structure \n tab : tableau [1..b] de tenreg \n NB : entier \nfin structure \ntype tenreg : structure \n cle : entier \n efface : booleen \n champ1 :typeQLq … \nfin structure \nf = fichier de tbloc buffer buf ENTETE (entier , entier) \n // 1 car = nombre des blocs et 2 car = nombre des éléments dans le fichier"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 3,
    "text": "2"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 4,
    "text": "3"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 5,
    "text": "4 \n \nsuppression_physique( c : typeqlq ; nomfichier : chaine ) \nVar \nTrouv : booleen ; i,j,k : entier \nDebut \n Rech(c,nomfichier,trouv,i,j) \n Si (trouv) alors \n Ouvrir(f,nomfichier,’r+’) \n Liredir(f,i,buf) \n k := j \n Si ( j != buf.NB) alors \n Tq (k < buf.NB) faire \n buf.tab[k] := buf.tab[k+1] \n k := k +1 \n fin tq \n(1) : i := i + 1 \n si ( i < entete(f,1)) alors"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 6,
    "text": "5 \n buf1 := lire(f,i) \n buf.tab[buf.NB] := buf1.tab[1] \n fin si \n ecriredir(f,i-1,buf) \n buf := buf1 \n Tq ( i < entete(f,1)) faire \n k := 1 \n Tq (k < buf.NB) faire \n buf.tab[k] := buf.tab[k+1] \n k := k +1 \n fin tq \n i := i + 1 \n si ( i < entete(f,1)) alors \n liredir(f,i,buf1) \n buf.tab[buf.NB] := buf1.tab[1] \n fin si \necriredir(f,i-1,buf) \n buf := buf1 \n fin tq \n sinon \n aller a (1) \n fin si \n i := entete(f,1) \n lirebloc(f,i,buf) \n si (buf.NB == 1 ) // si le dernier bloc contient une seule élément donc \nlorsque en faire le décalage le dernier bloc vas supprimer \n nb := entete(f,1) \n affecte_entete(f,1,nb-1) \n finSI \n n := entete(f,2)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 7,
    "text": "6 \n affecte_entete(f,2,n-1) \n sinon \n Ecrire (‘’ L’ élément n’existe pas ! ‘’) \nFermer(f) \n \nFin \n \narticles : structure \n tab : tableau[1..100]de typeEnreg \n nb : entier \nfin structure \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \nTrouv : booleen ; i,j : entier \nDebut \n Rech(a,nomfichier,trouv,i,j) \n k := 1 \n nb := 0 \n si (trouv) alors \n Ouvrir(f,nomfichier,’r+’) \n tantque(i<=entete(f,1))faire \n Liredir(f,i,buf) \n tantque(j<=buf.NB)faire \n si( buf.tab[j].cle <= b ) \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n j := j + 1 \n articles.nb := articles.nb + 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 8,
    "text": "7 \n sinon \n aller a (2) \n fin tq \n j := 1 \n i := i + 1 \n fin tq \n \n sinon \n Ecrire(\"L' élément n'existe pas!\") \n finsi \n (2) fermer(f) \nFin \n \nType TNOF \ntype tbloc : structure \n tab : tableau [1..b] de tenreg \n NB : entier \nfin structure \ntype tenreg : structure \n cle : entier \n efface : booleen \n champ1 :typeQLq … \nfin structure \nf = fichier de tbloc buffer buf ENTETE (entier , entier) \n // 1 car = nombre des blocs et 2 car = nombre des éléments dans le fichier \n \n \nProcédure Recherche( c:entier ; nomfichier : chaine ; var trouv :booleen ; \ni,j:entier )"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 9,
    "text": "8 \nVar \ni := 1 ; trouv := faux ; \nDebut \n ouvrir(f,nomfichier,'r') \n TQ ( i<=entete(f,1) et trouv == faux) faire \n liredir(f,I ,buf) \n j := 1 \n TQ ( j<=buf.NB et trouv == faux) faire \n si ( buf.tab[j].cle == c et buf.tab[j].efface == faux) alors \n trouv := vrai \n sinon \n j := j + 1 \n fin TQ \n i := i + 1 \n fin TQ \n si ( trouv := faux ) alors \n i := entete(f,1) \n j := buf.NB \n fermer(f) \nFin \n \n \ninsertion( c:entier ; nomfichier : chaine ; element : typeEnreg ) \nVar \nTrouv : booleen ; i,j : entier \nDebut \n ouvrir(f,nomfichier,'w') \n Recherche( c , nomfichier , trouv , i , j ) \n si (non trouv) alors // i = dernier bloc et j = dernier element dans le bloc"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 10,
    "text": "9 \n liredir(f,i,buf) \n si(j<b) alors \n buf.tab[j+1] = element \n sinon \n i = i + 1 \n affecte_entete(f,1,i) \n buf.tab[1] = element \n buf.NB = 1 \n ecriredir(f,i,buf) \n fin si \nn := entete(f,2) \n affecte_entete(f,2,n+1) \n \n sinon \n ecrire (\"L'élément existe déjà ! \" ) \n \n fermer(f) \nFin \n \nSuppression Logique c’est la même dans type TOF \n \nsuppression_physique( c : typeqlq ; nomfichier : chaine ) \nVar \nTrouv : booleen ; i,j : entier \nDebut \nRech(c,nomfichier,trouv,i,j) \nSi (trouv) alors \n Ouvrir(f,nomfichier,’r+’) \n Liredir(f,i,buf)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 11,
    "text": "10 \n si ( i == entete(f,1) et j == buf.NB) alors \n buf.tab[j] := # \n buf.NB := buf.NB -1 \n si (buf.NB == 0 ) alors \n affecte_entete(f,1,i-1) \n sinon \n ecriredir(f,i,buf) \n finsi \n \n sinon \n i1 = entete(f,1) \n Liredir(f,i1,buf1) \n j1 := buf1.NB \n buf.tab[j] := buf1.tab[j1] \n ecriredir(f,i,buf) \n buf1.tab[j1] := # \n buf1.NB := buf1.NB -1 \n si (buf1.NB == 0 ) alors \n affecte_entete(f,1,i1-1) \n sinon \n ecriredir(f,i1,buf1) \n finsi \n finsi \nn := entete(f,2) \naffecte_entete(f,2,n-1) \nsinon \n Ecrire (‘’ L’ élément n’existe pas ! ‘’) \nFermer(f)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 12,
    "text": "11 \nFin \n \n \n \n \n \narticles : structure \n tab : tableau[1..100]de typeEnreg \n nb : entier \nfin structure \n \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \ni :=1 \nDebut \n ouvrir(f,nomfichier,'r') \n TQ ( i<=entete(f,1)) faire \n liredir(f,I,buf) \n j := 1 ; k := 1 \n TQ ( j<=buf.NB) faire \n si ( buf.tab[j].cle >= a et buf.tab[j].cle <=b ) alors \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n articles.nb := articles.nb + 1 \n sinon \n j := j + 1 \n fin TQ \n i := i + 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 13,
    "text": "12 \n fin TQ \nfermer(f) \nFin \n \n \n \n \nType LNOF \ntype tbloc : structure \n tab : tableau [1..b] de tenreg \n NB : entier \n suivant : entier \nfin structure \ntype tenreg : structure \n cle : entier \n efface : booleen \n champ1 :typeQLq … \nfin structure \nf = fichier de tbloc buffer buf ENTETE (entier , entier) \n // 1 car = nombre des blocs et 2 car = nombre des éléments dans le fichier \nProcédure Recherche( c:entier ; nomfichier : chaine ; var trouv :booleen , i , j) \nVar \ni := 1 , trouv := faux ; tete : pointeur sur tbloc \nDebut \n ouvrir(f,nomfichier,'r') \nTQ (i <= entete(f,1) et trouv == faux) faire \n liredir(f,i,buf) \n j := 1 \n TQ ( j<=buf.NB et trouv == faux) faire"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 14,
    "text": "13 \n si ( buf.tab[j].cle == c et buf.tab[j].efface == faux) alors \n trouv := vrai \n sinon \n j := j + 1 \n fin TQ \n i := buf.suivant \n fin TQ \n si ( trouv := faux ) alors \n i := entete(f,1) //i c’est le dernier bloc \n j := buf.NB // j c’est le dernier élément dans le dernier bloc \n fin si \n fermer(f) \nfin \n \ninsertion( c:entier ; nomfichier : chaine ; element : typeEnreg ) \nVar \n Trouv : booleen ; i,j,k : entier ; x : tenreg \nDebut \n ouvrir(f,nomfichier,'r+') \n Recherche( c , nomfichier , trouv , i , j) \n si (non trouv) alors // i= dernier bloc et j = dernier element dans le bloc \n liredir(f,i,buf) \n si(j<b) alors \n buf.tab[j+1] = element \n ecrirebloc(f,i,buf) \n sinon \n i := buf.suivant \n affecte_entete(f,1,i) \n allouer(nouveau)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 15,
    "text": "14 \n nouveau.tab[1] := element \n nouveau.NB := 1 \n nouveau.suivant := -1 \n ecrirebloc(f,i, nouveau) \n fin si \nn := entete(f,2) \n affecte_entete(f,2,n+1) \n sinon \n ecrire (\"L'élément existe déjà! \" ) \n \n fermer(f) \nFin \nSuppression Logique c’est la même dans type TOF \n \nsuppression_physique( c : typeqlq ; nomfichier : chaine ) \nVar \nTrouv : booleen ; i,j : entier \nDebut \n Rech(c,nomfichier,trouv,i,j) \n Si (trouv) alors \n Ouvrir(f,nomfichier,’r+’) \n liredir(f,i,buf) \n si ( i == entete(f,1) et j == buf.NB) alors \n // supprimer le dernier element dans le dernier bloc \n buf.tab[j] := # \n buf.NB := buf.NB -1 \n si (buf.NB == 0 ) alors \n i := entete(f,1) - 1 \n lirebloc(f,i,buf)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 16,
    "text": "15 \n buf.suiv := -1 \n ecrirebloc(f,i,buf) \n affecte_entete(f,1,i) \n sinon \n ecriredir(f,i,buf) \n finsi \n \n sinon \n i1 = entete(f,1) \n liredir(f,i1,buf1) \n j1 := buf1.NB \n buf.tab[j] := buf1.tab[j1] \n ecriredir(f,i,buf) \n buf1.tab[j1] := # \nbuf1.NB := buf1.NB -1 \n si (buf1.NB == 0 ) alors \n i := entete(f,1) - 1 \n lirebloc(f,i,buf) \n buf.suiv := -1 \n ecrirebloc(f,i,buf) \n affecte_entete(f,1,i) \n sinon \n ecriredir(f,i1,buf1) \n finsi \n finsi \n n := entete(f,2) \n affecte_entete(f,2,n-1) \n sinon \n Ecrire (‘’ L’ élément n’existe pas ! ‘’)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 17,
    "text": "16 \nFermer(f) \n \nFin \n \narticles : structure \n tab : tableau[1..100]de typeEnreg \n nb : entier \nfin structure \n \n \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \n i,j,k : entier \nDebut \n ouvrir(f,nomfichier,'r') \n i :=1 \n TQ ( i <= entete(f,1) ) faire \n liredir(f,i,buf) \n j := 1 ; k := 1 \n TQ ( j<=buf.NB) faire \n si ( buf.tab[j].cle >= a et buf.tab[j].cle <=b ) alors \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n articles.nb := articles.nb + 1 \n finSi \n j := j + 1 \n fin TQ \n i := buf.suivant"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 18,
    "text": "17 \n fin TQ \nfermer(f) \nFin \n \nType LOF \ntype tbloc : structure \n tab : tableau [1..b] de tenreg \n NB : entier \n suivant : entier \n prec : entier \nfin structure \ntype tenreg : structure \n cle : entier \n efface : booleen \n champ1 :typeQLq … \nfin structure \nf = fichier de tbloc buffer buf ENTETE (entier , entier) \n // 1 car = nombre des blocs et 2 car = nombre des éléments dans le fichier"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 19,
    "text": "18 \n \ninsertion( c:entier ; nomfichier : chaine ; element : typeEnreg ) \nVar \n Trouv : booleen ; i,j,k : entier ; x : tenreg \nDebut \n Recherche( c , nomfichier , trouv , i , j) \n si (non trouv) alors"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 20,
    "text": "19 \n ouvrir(f,nomfichier,'r+') \n liredir(f,i,buf) \n x := buf.tab[buf.NB] \n k := buf.NB \n TQ (k > j) faire \n Buf.tab[k] := buf.tab[k-1] \n k:= k – 1 \n FinTQ \n Buf.tab[j] := element \n si(buf.NB<b) alors \n buf.NB := buf.NB + 1 \n buf.tab[Buf.NB] = element \n ecrirebloc(f,i,buf) \n sinon \n allouer(nouveau) \n nouveau.tab[1] := element \n nouveau.NB := 1 \n buf.suiv := nouveau \n i := i + 1 \n si (i<= entete(f,1)) alors \n lirebloc(f,i,buf1) \n nouveau.suivant := buf1 \n sinon \n nouveau.suivant := -1 \n affecte_entete(f,1,i) \n fin si \n n := entete(f,2) \n affecte_entete(f,2,n+1) \n sinon"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 21,
    "text": "20 \n ecrire (\"L'élément existe déjà ! \" ) \n \n fermer(f) \nFin \n \nSuppression Logique c’est la même dans type TOF \n \nsuppression_physique( c : typeqlq ; nomfichier : chaine ) \nVar \n Trouv : booleen ; i,j,k : entier ; \nDebut \n Rech(c,nomfichier,trouv,i,j) \n Si (trouv) alors \n Ouvrir(f,nomfichier,’r+’) \n liredir(f,i,buf) \n k := j \n Si ( j != buf.NB) alors \n Tq (k < buf.NB) faire \n buf.tab[k] := buf.tab[k+1] \n k := k +1 \n fin tq \n(1) : i := buf.suivant \n si ( i < entete(f,1)) alors \n buf1 := lire(f,i) \n buf.tab[buf.NB] := buf1.tab[1] \n fin si \n ecriredir(f,i-1,buf) \n buf := buf1 \n Tq ( i < entete(f,1)) faire"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 22,
    "text": "21 \n k := 1 \n Tq (k < buf.NB) faire \n buf.tab[k] := buf.tab[k+1] \n k := k +1 \n fin tq \n i := buf.suivant \n si ( i < entete(f,1)) alors \n liredir(f,i,buf1) \n buf.tab[buf.NB] := buf1.tab[1] \n fin si \necriredir(f,i-1,buf) \n buf := buf1 \n fin tq \n sinon \n aller a (1) \n fin si \n (buf.NB == 1 ) // si le dernier bloc contient un seul élément donc lorsque en \nfaire le décalage le dernier bloc vas supprimer \n nb := entete(f,1) - 1 \n affecte_entete(f,1,nb) \n lirebloc(f,nb,buf) \n buf.suivant := -1 \n ecriredir(f,i-1,buf) \n \n finSI \n \n n := entete(f,2) \n affecte_entete(f,2,n-1) \n sinon \n Ecrire (‘’ L’ élément n’existe pas ! ‘’)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 23,
    "text": "22 \nFermer(f) \n \nFin \n \narticles : structure \n tab : tableau[1..100]de typeEnreg \n nb : entier \nfin structure \n \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \nTrouv : booleen ; i,j : entier \nDebut \n Rech(a,nomfichier,trouv,i,j) \n k := 1 \n articles.nb := 0 \n si (trouv) alors \n Ouvrir(f,nomfichier,’r+’) \n tantque(i<=entete(f,1))faire \n Liredir(f,i,buf) \n tantque(j<=buf.NB)faire \n si( buf.tab[j].cle <= b ) \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n j := j + 1 \n articles.nb := articles.nb + 1 \n sinon \n aller a (2)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 24,
    "text": "23 \n fin tq \n j := 1 \n i := buf.suivant \n fin tq \n \n sinon \n Ecrire(\"L' élément n'existe pas!\") \n finsi \n (2) fermer(f) \nFin \n \n \nType LnoVc \ntype tbloc : structure \n tab : tableau [1..b] de caractères \n NB : entier \n suivant : entier \nfin structure \nf = fichier de tbloc buffer buf ENTETE(entier , entier ,entier ,entier) \n// 1 car = num du premier bloc \n 2 car = num de dernier bloc \n3 car =la 1ere position libre dans le dernier bloc \n4 car le nombre de caractères perdus suite aux suppressions logiques \nl’enregistrement peut avoir le forme suivante : \nbbb | b | bbbbbbbbbbbbbbbbbbbb |bbbb…….b \n3 caractère pour la taille de l’enregistrement \n1 caractère pour indiquer l’effacement logique \n20 caractère pour la clé de l’enreg"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 25,
    "text": "24 \nN car pour les autres informations \n \n \nProcédure Recherche( c:entier ; nomfichier : chaine ; var trouv :booleen , i , j) \nVar \ni , j : entier ; trouv := booléen \nDebut \n ouvrir(f,nomfichier,'r') \n i := 1 \n j := 1 \n trouv := faux \n liredir(f,i,buf) \n TQ (non trouv) et (i <= entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n Recuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n Si (cle_rech == c) et (efface == ‘F’) alors \n Trouv = vrai \n Sinon \n j := j + nombre( longeur)-24 \n si ( j > b ) alors \n j := j – b \n i := buf.suivant \n liredir(f,i,buf) \n finSI \n finSi \n finTQ \n fermer(f) \nfin \nProcédure recuperer_chaine(n :entier : Var i,j :entier ; Var ch : chaine )"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 26,
    "text": "25 \nVar k :entier \nDebut \nPour (k := 1 ,n ) faire \n Si (j <= b ) alors \n Ch[k] := buf.tab[j] \n j := j + 1 \n sinon //chevauchement \n i := buf.suivant \n liredir (f,i,buf) \n ch[k] := buf.tab[1] \n j := 2 \n finsi \nfinPour \nFin \ninsertion( c:chaine[20] ; nomfichier : chaine; element : typeEnreg ) \nVar \n Trouv : booleen ; i,j,k : entier \nDebut \n Recherche( c , nomfichier , trouv , i , j) \n Si (trouv == faux ) alors \n ouvrir(f,nomfichier,'A') \n i := entete (f,2) \n j := entete(f,3) \n chaine_longueur := element[1 :3] \n//convertir la longueur en chaine de 3 car \n Ecrire_chaine(3,chaine_longueur,i,j) \n Ecrire_chaine(1,’F’,i,j) \n chaine_longueur := entier(chaine_longueur ) \n Ecrire_chaine(chaine_longueur- 4 ,element[4 : ],i,j)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 27,
    "text": "26 \n buf.suivant := -1 \n ecriredir(f,i,buf) \n si ( i != entete(f,2)) alors \n affecte_entete(f,2,i) \n finSI \n affecte_entete(f,3,j) \n sinon \n ecrire (\"L'élément existe déjà ! \" ) \n \n finSi \n fermer(f) \nFin \n \n \n \nProcédure Ecrire_chaine (n :entier , ch : chaine , Var i,j : entier ) \nVar \nK : entier ; i1 : entier \nDebut \n Pour ( k := 1 , n ) faire \n Si ( j<=b ) alors \n Buf.tab[j] := ch[k] \n j := j + 1 \n sinon \n i1 : allocbloc(f) \n buf.suivant := i1 \n ecriredir(f,i,buf) \n i := i1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 28,
    "text": "27 \n buf.tab [1] := ch[k] \n j := 2 \n finSI \n finPour \n \nFin \n \nProcédure Suppression_logique(c : chaine[20] , nomfichier :chaine) \nVar \nTrouv : booleen ; i,j : entier \nDebut \n Ouvrir(f,nomfichier,’A’) \n Recherche(c,nomfichier,trouv,i,j) \n Si (trouv ) alors \n j := j + 3 \n buf.tab[j] := ‘ V ’ \n ecriredir(f,i,j) \n \n Sinon \n Ecrire ( ‘’L’élément n’existe pas ! ‘’) \n finSI \nFin \narticles : structure \n tab : tableau[tailleMax]de caractères \n nb : entier //nombre des enreg \nfin structure"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 29,
    "text": "28 \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \n i,j,k : entier \nDebut \n ouvrir(f,nomfichier,'r') \n i :=1 \n TQ ( i < entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n liredir(f,i,buf) \n j := 1 ; k := 1 \nRecuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n cle_rech := entier (cle_rech) //convertir \n longueur := entier (longueur) //convertir \n j := j – 24 \n Si (cle_rech >= a et cle_rech <= b) et (efface == ‘F’) alors \n Pour ( n := 1 , longueur ) faire \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n j := j + 1 \n finPour \n articles.nb := articles.nb + 1 \n \n Sinon \n j := j + nombre( longeur) \n si ( j > b ) alors \n j := j – b \n i := buf.suivant \n finSI"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 30,
    "text": "29 \n finSi \n finTQ \n \nfermer(f) \nFin \n \nType LnoVnc \ntype tbloc : structure \n tab : tableau [1..b] de caractères \n NB : entier \n suivant : entier \nfin structure \nf = fichier de tbloc buffer buf ENTETE(entier , entier ,entier ,entier) \n// 1 car = num du premier bloc \n 2 car = num de dernier bloc \n3 car =la 1ere position libre dans le dernier bloc \n4 car le nombre de caractères perdus suite aux suppressions logiques \nl’enregistrement peut avoir le forme suivante : \nbbb | b | bbbbbbbbbbbbbbbbbbbb |bbbb…….b \n3 car pour la taille de l’enregistrement \n1 car pour indiquer l’effacement logique \n20 car pour la clé de l’enreg \nN car pour les autres informations \n \n \nProcédure Recherche( c:entier ; nomfichier : chaine ; var trouv :booleen , i , j) \nVar \ni , j : entier ; trouv := booléen"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 31,
    "text": "30 \nDebut \n ouvrir(f,nomfichier,'r') \n i := 1 \n j := 1 \n trouv := faux \n liredir(f,i,buf) \n TQ (non trouv) et (i <= entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n Recuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n Si (cle_rech == c) et (efface == ‘F’) alors \n Trouv = vrai \n Sinon \n j := j + nombre( longeur)-24 \n si ( j > b ) alors \n j := 1 \n i := buf.suivant \n liredir(f,i,buf) \n finSI \n finSi \n finTQ \n fermer(f) \nfin \nProcédure recuperer_chaine(n :entier : Var i,j :entier ; Var ch : chaine ) \nVar k :entier \nDebut \nPour (k := 1 ,n ) faire \n Si (j <= b ) alors \n Ch[k] := buf.tab[j] \n j := j + 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 32,
    "text": "31 \n finsi \nfinPour \nFin \ninsertion( c:chaine[20] ; nomfichier : chaine; element : typeEnreg ) \nVar \n Trouv : booleen ; i,j,k : entier \nDebut \n Recherche( c , nomfichier , trouv , i , j) \n Si (trouv == faux ) alors \n ouvrir(f,nomfichier,'A') \n i := entete (f,2) \n j := entete(f,3) \n chaine_longueur := element[1 :3] \n//convertir la longueur en chaine de 3 car \nSI (j +entier(chaine_longueur) <= b ) alors \n Ecrire_chaine(3,chaine_longueur,i,j) \n Ecrire_chaine(1,’F’,i,j) \nchaine_longueur := entier(chaine_longueur) \n Ecrire_chaine(chaine_longueur-4 ,element[4 : ],i,j) \n buf.suivant := -1 \n ecriredir(f,i,buf) \n Sinon \n i := buf.suivant \n j := 1 \n Ecrire_chaine(3,chaine_longueur,i,j) \n Ecrire_chaine(1,’F’,i,j) \nchaine_longueur := entier(chaine_longueur) \n Ecrire_chaine(chaine_longueur-4 ,element[4 : ],i,j) \n buf.suivant := -1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 33,
    "text": "32 \n ecriredir(f,i,buf) \n finSI \n \n si ( i != entete(f,2)) alors \n affecte_entete(f,2,i) \n finSI \n affecte_entete(f,3,j) \n sinon \n ecrire (\"L'élément existe déjà ! \" ) \n \n finSi \n fermer(f) \nFin \n \n \n \nProcédure Ecrire_chaine (n :entier , ch : chaine , Var i,j : entier ) \nVar \nK : entier ; i1 : entier \nDebut \n Pour ( k := 1 , n ) faire \n Si ( j<=b ) alors \n Buf.tab[j] := ch[k] \n j := j + 1 \n finSI \n finPour \n \nFin"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 34,
    "text": "33 \n \nProcédure Suppression_logique(c : chaine[20] , nomfichier :chaine) \nVar \nTrouv : booleen ; i,j : entier \nDebut \n Ouvrir(f,nomfichier,’A’) \n Recherche(c,nomfichier,trouv,i,j) \n Si (trouv ) alors \n j := j + 3 \n buf.tab[j] := ‘ V ’ \n ecriredir(f,i,j) \n \n Sinon \n Ecrire ( ‘’L’élément n’existe pas ! ‘’) \n finSI \nFin \narticles : structure \n tab : tableau[tailleMax]de caractères \n nb : entier //nombre des enreg \nfin structure \n \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \n i,j,k : entier \nDebut \n ouvrir(f,nomfichier,'r') \n i :=1 \n TQ ( i < entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 35,
    "text": "34 \n liredir(f,i,buf) \n j := 1 ; k := 1 \nRecuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n cle_rech := entier (cle_rech) //convertir \n longueur := entier (longueur) //convertir \n j := j – 24 \n Si (cle_rech >= a et cle_rech <= b) et (efface == ‘F’) alors \n Pour ( n := 1 , longueur ) faire \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n j := j + 1 \n finPour \n articles.nb := articles.nb + 1 \n \n Sinon \n j := j + nombre( longeur)-24 \n si ( j > b ) alors \n j := 1 \n i := buf.suivant \n finSI \n finSi \n finTQ \n \nfermer(f) \nFin \n \nType LoVc \ntype tbloc : structure"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 36,
    "text": "35 \n tab : tableau [1..b] de caractères \n NB : entier \n suivant : entier \n prec : entier \nfin structure \nf = fichier de tbloc buffer buf ENTETE(entier , entier ,entier ,entier ,entier) \n// 1 car = num du premier bloc \n 2 car = num de dernier bloc \n3 car = la 1ere position libre dans le dernier bloc \n4 car = le nombre de caractères perdus suite aux suppressions logiques \n5 car = position de dernier element dans le bloc \nl’enregistrement peut avoir le forme suivante : \nbbb | b | bbbbbbbbbbbbbbbbbbbb |bbbb…….b \n3 car pour la taille de l’enregistrement \n1 car pour indiquer l’effacement logique \n20 car pour la clé de l’enreg \nN car pour les autres informations \n \n \nProcédure Recherche( c:entier ; nomfichier : chaine ; var trouv :booleen , i , j) \nVar \nbi , bs , inf , sup : entier ; \ntrouv , stop:= booléen \nDebut \n ouvrir(f,nomfichier,'r') \n bs := entete(f,2) \n bi := 1 \n trouv := faux ; stop :"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 36,
    "text": " \nVar \nbi , bs , inf , sup : entier ; \ntrouv , stop:= booléen \nDebut \n ouvrir(f,nomfichier,'r') \n bs := entete(f,2) \n bi := 1 \n trouv := faux ; stop := faux ; j := 1 \n TQ ( bi <= bs et Non trouv et Non stop )"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 37,
    "text": "36 \n i := (bi + bs ) div 2 \n liredir(f , i , buf) \n j := j + 4 \n Recuperer_chaine(20,i,j,cle1) \n j := entete(f, 5) \n j := j + 4 \n si ( j > b ) alors \n j := j – b \n i := buf.suivant \n finSI \n Recuperer_chaine(20,i,j,cle2) \n cle1 := entier(cle1) ; cle2 := entier(cle2) \n Si ( c >= cle1 et c <= cle2 ) alors \ninf := 1 ; sup := nombre_element(i) \n // nombre_element == fonction qui calcule nombre des éléments \ndans le bloc \nTQ (inf <= sup et non trouv ) \n Milieu(i,inf,sup, k) \n Recuperer_chaine(3,i,k,longueur) \n Recuperer_chaine(1,i,k,efface) \n Recuperer_chaine(20,i,k,cle) \n longueur := entier(longueur) \n cle := entier(cle) \n longueur := entier(longueur) \n Si ( c == cle ) alors \n Trouv := vrai \n Sinon \n Si (c < cle ) alors \n Sup := k -24 \n sinon"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 38,
    "text": "37 \n inf := k + longueur – 24 \n finSI \n finSI \nfinTQ \nSi( inf > sup) alors \n j := inf \nfinSI \nstop := vrai \n Sinon \n Si (c < cle1 ) \n bs := buf.prec \n sinon \n bi := buf.suivant \n finSI \n finSI \n finTQ \n SI (bi > bs ) alors \n i := bi \n j := 1 \n finSi \nfermer(f) \nFin \n \nProcédure recuperer_chaine(n :entier : Var i,j :entier ; Var ch : chaine ) \nVar k :entier \nDebut \nPour (k := 1 ,n ) faire \n Si (j <= b ) alors \n Ch[k] := buf.tab[j]"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 39,
    "text": "38 \n j := j + 1 \n sinon //chevauchement \n i := buf.suivant \n liredir (f,i,buf) \n ch[k] := buf.tab[1] \n j := 2 \n finsi \nfinPour \nFin \nProcédure milieu ( i : entier , j : entier , sup : entier ; var k : entier ) \nVar \nDebut \n nenreg := nombre_element(i,j,sup) \n nenreg := (nenreg) div 2 \n cpt := 0 \n TQ (cpt < nenreg) faire \nRecuperer_chaine(3,bloc,j,longueur) \nlongueur := entier(longueur) \n j := j + longueur – 3 \n cpt := cpt + 1 \n finTQ \n k := j \nFin \n \nProcédure nombre_element ( i : entier , j : entier, sup : entier) \nVar \nJ : entier ; cpt : entier \nDebut"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 40,
    "text": "39 \n cpt := 0 \n TQ (j < sup) faire \nRecuperer_chaine(3,bloc,j,longueur) \nlongueur := entier(longueur) \n j := j + longueur – 3 \n cpt := cpt + 1 \n finTQ \nretourner cpt \nFin \n \ninsertion(nomfichier : chaine; element : typeEnreg ) \nVar \n Trouv,continu : booleen ; i,j,k : entier \nDebut \n c := element [5 .. 24] \n Recherche( c , nomfichier , trouv , i , j) \n Si (trouv == faux ) alors \n ouvrir(f,nomfichier,'A') \n l liredir(f,i,buf) \n L := element [1..3] // L : taille de l’enreg \nt := taille(buf) //nombre des caractères dans le bloc \nSi ( L + t < b ) alors //buffer n’est pas plein \n K :=0 \n N := j + 1 \n // sauvegarder les elemnts apres la postion j \nTantque ( N < b ) faire \nArticles [K ] := buf.tab[N] \nK := K + 1 \nN := N + 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 41,
    "text": "40 \nfinTQ \ncpt := 1 \ntantque(cpt <= L ) faire \nbuf.tab[j ] := element[cpt] \nj := j+ 1 \ncpt := cpt + 1 \nfinTQ \ncpt := 1 \ntantque(cpt <= k ) faire \nbuf.tab[j ] := articles[cpt] \ncpt := cpt + 1 \nj := j + 1 \nfinTQ \n Sinon \n K :=0 \n N := j + 1 \n // sauvegarder les elemnts apres la postion j \nTantque ( N < b ) faire \nArticles [K ] := buf.tab[N] \nK := K + 1 \nN := N + 1 \nfinTQ \ncpt := 1 \ntantque(cpt <= L ) faire \nbuf.tab[j ] := element[cpt] \nj := j+ 1 \ncpt := cpt + 1 \nfinTQ \ncpt := 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 42,
    "text": "41 \ntantque(j <=b ) faire \nbuf.tab[j ] := articles[cpt] \ncpt := cpt + 1 \nj := j+ 1 \nfinTQ \n i := buf .suiv \n \n finSi \n \n sinon \n ecrire (\"L'élément existe déjà ! \" ) \n \n finSi \n fermer(f) \nFin \n \n \n \nProcédure Ecrire_chaine (n :entier , ch : chaine , Var i,j : entier ) \nVar \nK : entier ; i1 : entier \nDebut \n Pour ( k := 1 , n ) faire \n Si ( j<=b ) alors \n Buf.tab[j] := ch[k] \n j := j + 1 \n sinon \n i1 : allocbloc(f)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 43,
    "text": "42 \n buf.suivant := i1 \n ecriredir(f,i,buf) \n i := i1 \n buf.tab [1] := ch[k] \n j := 2 \n finSI \n finPour \n \nFin \n \nProcédure Suppression_logique(c : chaine[20] , nomfichier :chaine) \nVar \nTrouv : booleen ; i,j : entier \nDebut \n Ouvrir(f,nomfichier,’A’) \n Recherche(c,nomfichier,trouv,i,j) \n Si (trouv ) alors \n j := j + 3 \n si ( j > b ) alors \n j := j – b \n i := buf.suivant \n finSI \n buf.tab[j] := ‘ V ’ \n ecriredir(f,i,j) \n \n Sinon \n Ecrire ( ‘’L’élément n’existe pas ! ‘’) \n finSI"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 44,
    "text": "43 \nFin \narticles : structure \n tab : tableau[tailleMax]de caractères \n nb : entier //nombre des enreg \nfin structure \n \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \n i,j,k : entier \nDebut \n ouvrir(f,nomfichier,'r') \n Rech(a,nomfichier,trouv,i,j) \n TQ ( i < entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n liredir(f,i,buf) \n k := 1 \nRecuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n cle_rech := entier (cle_rech) //convertir \n longueur := entier (longueur) //convertir \n j := j – 24 \n Si (cle_rech >= a et cle_rech <= b) et (efface == ‘F’) alors \n Pour ( n := 1 , longueur ) faire \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n j := j + 1 \n finPour \n articles.nb := articles.nb + 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 45,
    "text": "44 \n Sinon \n j := j + nombre( longeur) \n si ( j > b ) alors \n j := j – b \n i := buf.suivant \n finSI \n finSi \n finTQ \n \nfermer(f) \nFin \n \nType LoVnc \ntype tbloc : structure \n tab : tableau [1..b] de caractères \n NB : entier \n suivant : entier \n prec : entier \nfin structure \nf = fichier de tbloc buffer buf ENTETE(entier , entier ,entier ,entier ,entier) \n// 1 car = num du premier bloc \n 2 car = num de dernier bloc \n3 car = la 1ere position libre dans le dernier bloc \n4 car = le nombre de caractères perdus suite aux suppressions logiques \n5 car = position de dernier element dans le bloc \nl’enregistrement peut avoir le forme suivante : \nbbb | b | bbbbbbbbbbbbbbbbbbbb |bbbb…….b \n3 car pour la taille de l’enregistrement \n1 car pour indiquer l’effacement logique"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 46,
    "text": "45 \n20 car pour la clé de l’enreg \nN car pour les autres informations \n \n \nProcédure Recherche( c:entier ; nomfichier : chaine ; var trouv :booleen , i , j) \nVar \nbi , bs , inf , sup : entier ; \ntrouv , stop:= booléen \nDebut \n ouvrir(f,nomfichier,'r') \n bs := entete(f,2) \n bi := 1 \n trouv := faux ; stop := faux ; j := 1 \n TQ ( bi <= bs et Non trouv et Non stop ) \n i := (bi + bs ) div 2 \n liredir(f , i , buf) \n j := j + 4 \n Recuperer_chaine(20,i,j,cle1) \n j := entete(f, 5) \n Recuperer_chaine(20,i,j,cle2) \n cle1 := entier(cle1) ; cle2 := entier(cle2) \n Si ( c >= cle1 et c <= cle2 ) alors \ninf := 1 ; sup := nombre_element(i) \n // nombre_element == fonction qui calcule nombre des éléments \ndans le bloc \nTQ (inf <= sup et non trouv ) \n Milieu(i,inf,sup, k) \n Recuperer_chaine(3,i,k,longueur) \n Recuperer_chaine(1,i,k,efface)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 47,
    "text": "46 \n Recuperer_chaine(20,i,k,cle) \n longueur := entier(longueur) \n cle := entier(cle) \n longueur := entier(longueur) \n Si ( c == cle ) alors \n Trouv := vrai \n Sinon \n Si (c < cle ) alors \n Sup := k -24 \n sinon \n inf := k + longueur – 24 \n finSI \n finSI \nfinTQ \nSi( inf > sup) alors \n j := inf \nfinSI \nstop := vrai \n Sinon \n Si (c < cle1 ) \n bs := buf.prec \n sinon \n bi := buf.suivant \n finSI \n finSI \n finTQ \n SI (bi > bs ) alors \n i := bi \n j := 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 48,
    "text": "47 \n finSi \nfermer(f) \nFin \n \nProcédure recuperer_chaine(n :entier : Var i,j :entier ; Var ch : chaine ) \nVar k :entier \nDebut \nPour (k := 1 ,n ) faire \n Si (j <= b ) alors \n Ch[k] := buf.tab[j] \n j := j + 1 \n finsi \nfinPour \nFin \nProcédure milieu ( i : entier , j : entier , sup : entier ; var k : entier ) \nVar \nDebut \n nenreg := nombre_element(i,j,sup) \n nenreg := (nenreg) div 2 \n cpt := 0 \n TQ (cpt < nenreg) faire \nRecuperer_chaine(3,bloc,j,longueur) \nlongueur := entier(longueur) \n j := j + longueur – 3 \n cpt := cpt + 1 \n finTQ \n k := j \nFin"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 49,
    "text": "48 \n \nProcédure nombre_element ( i : entier , j : entier, sup : entier) \nVar \nJ : entier ; cpt : entier \nDebut \n cpt := 0 \n TQ (j < sup) faire \nRecuperer_chaine(3,bloc,j,longueur) \nlongueur := entier(longueur) \n j := j + longueur – 3 \n cpt := cpt + 1 \n finTQ \nretourner cpt \nFin \n \ninsertion(nomfichier : chaine; element : typeEnreg ) \nVar \n Trouv,continu : booleen ; i,j,k : entier \nDebut \n c := element [5 .. 24] \n Recherche( c , nomfichier , trouv , i , j) \n Si (trouv == faux ) alors \n ouvrir(f,nomfichier,'A') \n l liredir(f,i,buf) \n L := element [1..3] // L : taille de l’enreg \nt := taille(buf) //nombre des caractères dans le bloc \nSi ( L + t < b ) alors //buffer n’est pas plein \n K :=0"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 50,
    "text": "49 \n N := j + 1 \n // sauvegarder les elemnts apres la postion j \nTantque ( N < b ) faire \nArticles [K ] := buf.tab[N] \nK := K + 1 \nN := N + 1 \nfinTQ \ncpt := 1 \ntantque(cpt <= L ) faire \nbuf.tab[j ] := element[cpt] \nj := j+ 1 \ncpt := cpt + 1 \nfinTQ \ncpt := 1 \ntantque(cpt <= k ) faire \nbuf.tab[j ] := articles[cpt] \ncpt := cpt + 1 \nj := j + 1 \nfinTQ \n Sinon \n K :=0 \n N := j + 1 \n // sauvegarder les elemnts apres la postion j \nTantque ( N < b ) faire \nArticles [K ] := buf.tab[N] \nK := K + 1 \nN := N + 1 \nfinTQ \ncpt := 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 51,
    "text": "50 \ntantque(cpt <= L ) faire \nbuf.tab[j ] := element[cpt] \nj := j+ 1 \ncpt := cpt + 1 \nfinTQ \ncpt := 1 \ntantque(j <=b ) faire \nbuf.tab[j ] := articles[cpt] \ncpt := cpt + 1 \nj := j+ 1 \nfinTQ \n i := buf .suiv \n \n finSi \n \n sinon \n ecrire (\"L'élément existe déjà ! \" ) \n \n finSi \n fermer(f) \nFin \n \n \n \nProcédure Ecrire_chaine (n :entier , ch : chaine , Var i,j : entier ) \nVar \nK : entier ; i1 : entier \nDebut"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 52,
    "text": "51 \n Pour ( k := 1 , n ) faire \n Si ( j<=b ) alors \n Buf.tab[j] := ch[k] \n j := j + 1 \n finSI \n finPour \n \nFin \n \nProcédure Suppression_logique(c : chaine[20] , nomfichier :chaine) \nVar \nTrouv : booleen ; i,j : entier \nDebut \n Ouvrir(f,nomfichier,’A’) \n Recherche(c,nomfichier,trouv,i,j) \n Si (trouv ) alors \n j := j + 3 \n si ( j < b ) alors \n buf.tab[j] := ‘ V ’ \n ecriredir(f,i,j) \n finSI \n \n Sinon \n Ecrire ( ‘’L’élément n’existe pas ! ‘’) \n finSI \nFin \narticles : structure \n tab : tableau[tailleMax]de caractères"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 53,
    "text": "52 \n nb : entier //nombre des enreg \nfin structure \n \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \n i,j,k : entier \nDebut \n ouvrir(f,nomfichier,'r') \n Rech(a,nomfichier,trouv,i,j) \n TQ ( i < entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n liredir(f,i,buf) \n k := 1 \nRecuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n cle_rech := entier (cle_rech) //convertir \n longueur := entier (longueur) //convertir \n j := j – 24 \n Si (cle_rech >= a et cle_rech <= b) et (efface == ‘F’) alors \n Pour ( n := 1 , longueur ) faire \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n j := j + 1 \n finPour \n articles.nb := articles.nb + 1 \n \n Sinon \n j := j + nombre( longeur) \n si ( j > b ) alors"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 54,
    "text": "53 \n j := 1 \n i := buf.suivant \n finSI \n finSi \n finTQ \n \nfermer(f) \nFin \nType TnoVc \ntype tbloc : structure \n tab : tableau [1..b] de caractères \n NB : entier \nfin structure \nf = fichier de tbloc buffer buf ENTETE(entier , entier ,entier ,entier) \n// 1 car = num du premier bloc \n 2 car = num de dernier bloc \n3 car =la 1ere position libre dans le dernier bloc \n4 car le nombre de caractères perdus suite aux suppressions logiques \nl’enregistrement peut avoir le forme suivante : \nbbb | b | bbbbbbbbbbbbbbbbbbbb |bbbb…….b \n3 car pour la taille de l’enregistrement \n1 car pour indiquer l’effacement logique \n20 car pour la clé de l’enreg \nN car pour les autres informations \n \n \nProcédure Recherche( c:entier ; nomfichier : chaine ; var trouv :booleen , i , j) \nVar"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 55,
    "text": "54 \ni , j : entier ; trouv := booléen \nDebut \n ouvrir(f,nomfichier,'r') \n i := 1 \n j := 1 \n trouv := faux \n liredir(f,i,buf) \n TQ (non trouv) et (i <= entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n Recuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n Si (cle_rech == c) et (efface == ‘F’) alors \n Trouv = vrai \n Sinon \n j := j + nombre( longeur)-24 \n si ( j > b ) alors \n j := j – b \n i := i + 1 \n liredir(f,i,buf) \n finSI \n finSi \n finTQ \n fermer(f) \nfin \nProcédure recuperer_chaine(n :entier : Var i,j :entier ; Var ch : chaine ) \nVar k :entier \nDebut \nPour (k := 1 ,n ) faire \n Si (j <= b ) alors \n Ch[k] := buf.tab[j]"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 56,
    "text": "55 \n j := j + 1 \n sinon //chevauchement \n i := i + 1 \n liredir (f,i,buf) \n ch[k] := buf.tab[1] \n j := 2 \n finsi \nfinPour \nFin \ninsertion( c:chaine[20] ; nomfichier : chaine; element : typeEnreg ) \nVar \n Trouv : booleen ; i,j,k : entier \nDebut \n Recherche( c , nomfichier , trouv , i , j) \n Si (trouv == faux ) alors \n ouvrir(f,nomfichier,'A') \n i := entete (f,2) \n j := entete(f,3) \n chaine_longueur := element[1 :3] \n//convertir la longueur en chaine de 3 car \n Ecrire_chaine(3,chaine_longueur,i,j) \n Ecrire_chaine(1,’F’,i,j) \n chaine_longueur := entier(chaine_longueur ) \n Ecrire_chaine(chaine_longueur- 4 ,element[4 : ],i,j) \n ecriredir(f,i,buf) \n si ( i != entete(f,2)) alors \n affecte_entete(f,2,i) \n finSI \n affecte_entete(f,3,j)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 57,
    "text": "56 \n sinon \n ecrire (\"L'élément existe déjà ! \" ) \n \n finSi \n fermer(f) \nFin \n \n \n \nProcédure Ecrire_chaine (n :entier , ch : chaine , Var i,j : entier ) \nVar \nK : entier ; i1 : entier \nDebut \n Pour ( k := 1 , n ) faire \n Si ( j<=b ) alors \n Buf.tab[j] := ch[k] \n j := j + 1 \n sinon \n ecriredir(f,i,buf) \n i := i + 1 \nbuf.tab [1] := ch[k] \n j := 2 \n finSI \n finPour \n \nFin \n \nProcédure Suppression_logique(c : chaine[20] , nomfichier :chaine)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 58,
    "text": "57 \nVar \nTrouv : booleen ; i,j : entier \nDebut \n Ouvrir(f,nomfichier,’A’) \n Recherche(c,nomfichier,trouv,i,j) \n Si (trouv ) alors \n j := j + 3 \n buf.tab[j] := ‘ V ’ \n ecriredir(f,i,j) \n \n Sinon \n Ecrire ( ‘’L’élément n’existe pas ! ‘’) \n finSI \nFin \narticles : structure \n tab : tableau[tailleMax]de caractères \n nb : entier //nombre des enreg \nfin structure \n \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \n i,j,k : entier \nDebut \n ouvrir(f,nomfichier,'r') \n i :=1 \n TQ ( i < entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n liredir(f,i,buf) \n j := 1 ; k := 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 59,
    "text": "58 \nRecuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n cle_rech := entier (cle_rech) //convertir \n longueur := entier (longueur) //convertir \n j := j – 24 \n Si (cle_rech >= a et cle_rech <= b) et (efface == ‘F’) alors \n Pour ( n := 1 , longueur ) faire \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n j := j + 1 \n finPour \n articles.nb := articles.nb + 1 \n \n Sinon \n j := j + nombre( longeur) \n si ( j > b ) alors \n j := j – b \n i := i + 1 \n finSI \n finSi \n finTQ \n \nfermer(f) \nFin \n \nType TnoVnc \ntype tbloc : structure \n tab : tableau [1..b] de caractères \n NB : entier"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 60,
    "text": "59 \n suivant : entier \nfin structure \nf = fichier de tbloc buffer buf ENTETE(entier , entier ,entier ,entier) \n// 1 car = num du premier bloc \n 2 car = num de dernier bloc \n3 car =la 1ere position libre dans le dernier bloc \n4 car le nombre de caractères perdus suite aux suppressions logiques \nl’enregistrement peut avoir le forme suivante : \nbbb | b | bbbbbbbbbbbbbbbbbbbb |bbbb…….b \n3 car pour la taille de l’enregistrement \n1 car pour indiquer l’effacement logique \n20 car pour la clé de l’enreg \nN car pour les autres informations \n \n \nProcédure Recherche( c:entier ; nomfichier : chaine ; var trouv :booleen , i , j) \nVar \ni , j : entier ; trouv := booléen \nDebut \n ouvrir(f,nomfichier,'r') \n i := 1 \n j := 1 \n trouv := faux \n liredir(f,i,buf) \n TQ (non trouv) et (i <= entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n Recuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 60,
    "text": "\n TQ (non trouv) et (i <= entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n Recuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n Si (cle_rech == c) et (efface == ‘F’) alors \n Trouv = vrai"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 61,
    "text": "60 \n Sinon \n j := j + nombre( longeur)-24 \n si ( j > b ) alors \n j := 1 \n i := i + 1 \n liredir(f,i,buf) \n finSI \n finSi \n finTQ \n fermer(f) \nfin \nProcédure recuperer_chaine(n :entier : Var i,j :entier ; Var ch : chaine ) \nVar k :entier \nDebut \nPour (k := 1 ,n ) faire \n Si (j <= b ) alors \n Ch[k] := buf.tab[j] \n j := j + 1 \n finsi \nfinPour \nFin \ninsertion( c:chaine[20] ; nomfichier : chaine; element : typeEnreg ) \nVar \n Trouv : booleen ; i,j,k : entier \nDebut \n Recherche( c , nomfichier , trouv , i , j) \n Si (trouv == faux ) alors \n ouvrir(f,nomfichier,'A') \n i := entete (f,2)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 62,
    "text": "61 \n j := entete(f,3) \n chaine_longueur := element[1 :3] \n//convertir la longueur en chaine de 3 car \nSI (j +entier(chaine_longueur) <= b ) alors \n Ecrire_chaine(3,chaine_longueur,i,j) \n Ecrire_chaine(1,’F’,i,j) \nchaine_longueur := entier(chaine_longueur) \n Ecrire_chaine(chaine_longueur-4 ,element[4 : ],i,j) \n ecriredir(f,i,buf) \n Sinon \n i := i + 1 \n j := 1 \n Ecrire_chaine(3,chaine_longueur,i,j) \n Ecrire_chaine(1,’F’,i,j) \nchaine_longueur := entier(chaine_longueur) \n Ecrire_chaine(chaine_longueur-4 ,element[4 : ],i,j) \n ecriredir(f,i,buf) \n finSI \n \n si ( i != entete(f,2)) alors \n affecte_entete(f,2,i) \n finSI \n affecte_entete(f,3,j) \n sinon \n ecrire (\"L'élément existe déjà ! \" ) \n \n finSi \n fermer(f) \nFin"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 63,
    "text": "62 \n \n \n \nProcédure Ecrire_chaine (n :entier , ch : chaine , Var i,j : entier ) \nVar \nK : entier ; i1 : entier \nDebut \n Pour ( k := 1 , n ) faire \n Si ( j<=b ) alors \n Buf.tab[j] := ch[k] \n j := j + 1 \n finSI \n finPour \n \nFin \n \nProcédure Suppression_logique(c : chaine[20] , nomfichier :chaine) \nVar \nTrouv : booleen ; i,j : entier \nDebut \n Ouvrir(f,nomfichier,’A’) \n Recherche(c,nomfichier,trouv,i,j) \n Si (trouv ) alors \n j := j + 3 \n buf.tab[j] := ‘ V ’ \n ecriredir(f,i,j) \n \n Sinon"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 64,
    "text": "63 \n Ecrire ( ‘’L’élément n’existe pas ! ‘’) \n finSI \nFin \narticles : structure \n tab : tableau[tailleMax]de caractères \n nb : entier //nombre des enreg \nfin structure \n \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \n i,j,k : entier \nDebut \n ouvrir(f,nomfichier,'r') \n i :=1 \n TQ ( i < entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n liredir(f,i,buf) \n j := 1 ; k := 1 \nRecuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n cle_rech := entier (cle_rech) //convertir \n longueur := entier (longueur) //convertir \n j := j – 24 \n Si (cle_rech >= a et cle_rech <= b) et (efface == ‘F’) alors \n Pour ( n := 1 , longueur ) faire \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n j := j + 1 \n finPour"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 65,
    "text": "64 \n articles.nb := articles.nb + 1 \n \n Sinon \n j := j + nombre( longeur)-24 \n si ( j > b ) alors \n j := 1 \n i := i + 1 \n finSI \n finSi \n finTQ \n \nfermer(f) \nFin \nType ToVc \ntype tbloc : structure \n tab : tableau [1..b] de caractères \n NB : entier \n suivant : entier \n prec : entier \nfin structure \nf = fichier de tbloc buffer buf ENTETE(entier , entier ,entier ,entier ,entier) \n// 1 car = num du premier bloc \n 2 car = num de dernier bloc \n3 car = la 1ere position libre dans le dernier bloc \n4 car = le nombre de caractères perdus suite aux suppressions logiques \n5 car = position de dernier element dans le bloc \nl’enregistrement peut avoir le forme suivante : \nbbb | b | bbbbbbbbbbbbbbbbbbbb |bbbb…….b \n3 car pour la taille de l’enregistrement"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 66,
    "text": "65 \n1 car pour indiquer l’effacement logique \n20 car pour la clé de l’enreg \nN car pour les autres informations \n \n \nProcédure Recherche( c:entier ; nomfichier : chaine ; var trouv :booleen , i , j) \nVar \nbi , bs , inf , sup : entier ; \ntrouv , stop:= booléen \nDebut \n ouvrir(f,nomfichier,'r') \n bs := entete(f,2) \n bi := 1 \n trouv := faux ; stop := faux ; j := 1 \n TQ ( bi <= bs et Non trouv et Non stop ) \n i := (bi + bs ) div 2 \n liredir(f , i , buf) \n j := j + 4 \n Recuperer_chaine(20,i,j,cle1) \n j := entete(f, 5) \n j := j + 4 \n si ( j > b ) alors \n j := j – b \n i := i + 1 \n finSI \n Recuperer_chaine(20,i,j,cle2) \n cle1 := entier(cle1) ; cle2 := entier(cle2) \n Si ( c >= cle1 et c <= cle2 ) alors"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 67,
    "text": "66 \ninf := 1 ; sup := nombre_element(i) \n // nombre_element == fonction qui calcule nombre des éléments \ndans le bloc \nTQ (inf <= sup et non trouv ) \n Milieu(i,inf,sup, k) \n Recuperer_chaine(3,i,k,longueur) \n Recuperer_chaine(1,i,k,efface) \n Recuperer_chaine(20,i,k,cle) \n longueur := entier(longueur) \n cle := entier(cle) \n longueur := entier(longueur) \n Si ( c == cle ) alors \n Trouv := vrai \n Sinon \n Si (c < cle ) alors \n Sup := k -24 \n sinon \n inf := k + longueur – 24 \n finSI \n finSI \nfinTQ \nSi( inf > sup) alors \n j := inf \nfinSI \nstop := vrai \n Sinon \n Si (c < cle1 ) \n bs := i – 1 \n sinon \n bi := i + 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 68,
    "text": "67 \n finSI \n finSI \n finTQ \n SI (bi > bs ) alors \n i := bi \n j := 1 \n finSi \nfermer(f) \nFin \n \nProcédure recuperer_chaine(n :entier : Var i,j :entier ; Var ch : chaine ) \nVar k :entier \nDebut \nPour (k := 1 ,n ) faire \n Si (j <= b ) alors \n Ch[k] := buf.tab[j] \n j := j + 1 \n sinon //chevauchement \n i := i + 1 \n liredir (f,i,buf) \n ch[k] := buf.tab[1] \n j := 2 \n finsi \nfinPour \nFin \nProcédure milieu ( i : entier , j : entier , sup : entier ; var k : entier ) \nVar \nDebut"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 69,
    "text": "68 \n nenreg := nombre_element(i,j,sup) \n nenreg := (nenreg) div 2 \n cpt := 0 \n TQ (cpt < nenreg) faire \nRecuperer_chaine(3,bloc,j,longueur) \nlongueur := entier(longueur) \n j := j + longueur – 3 \n cpt := cpt + 1 \n finTQ \n k := j \nFin \n \nProcédure nombre_element ( i : entier , j : entier, sup : entier) \nVar \nJ : entier ; cpt : entier \nDebut \n cpt := 0 \n TQ (j < sup) faire \nRecuperer_chaine(3,bloc,j,longueur) \nlongueur := entier(longueur) \n j := j + longueur – 3 \n cpt := cpt + 1 \n finTQ \nretourner cpt \nFin \n \ninsertion(nomfichier : chaine; element : typeEnreg ) \nVar"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 70,
    "text": "69 \n Trouv,continu : booleen ; i,j,k : entier \nDebut \n c := element [5 .. 24] \n Recherche( c , nomfichier , trouv , i , j) \n Si (trouv == faux ) alors \n ouvrir(f,nomfichier,'A') \n liredir(f,i,buf) \n L := element [1..3] // L : taille de l’enreg \nt := taille(buf) //nombre des caractères dans le bloc \nSi ( L + t < b ) alors //buffer n’est pas plein \n K :=0 \n N := j + 1 \n // sauvegarder les elemnts apres la postion j \nTantque ( N < b ) faire \nArticles [K ] := buf.tab[N] \nK := K + 1 \nN := N + 1 \nfinTQ \ncpt := 1 \ntantque(cpt <= L ) faire \nbuf.tab[j ] := element[cpt] \nj := j+ 1 \ncpt := cpt + 1 \nfinTQ \ncpt := 1 \ntantque(cpt <= k ) faire \nbuf.tab[j ] := articles[cpt] \ncpt := cpt + 1 \nj := j + 1"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 71,
    "text": "70 \nfinTQ \n Sinon \n K :=0 \n N := j + 1 \n // sauvegarder les elemnts apres la postion j \nTantque ( N < b ) faire \nArticles [K ] := buf.tab[N] \nK := K + 1 \nN := N + 1 \nfinTQ \ncpt := 1 \ntantque(cpt <= L ) faire \nbuf.tab[j ] := element[cpt] \nj := j+ 1 \ncpt := cpt + 1 \nfinTQ \ncpt := 1 \ntantque(j <=b ) faire \nbuf.tab[j ] := articles[cpt] \ncpt := cpt + 1 \nj := j+ 1 \nfinTQ \n i := i+1 \n \n finSi \n \n sinon \n ecrire (\"L'élément existe déjà ! \" )"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 72,
    "text": "71 \n finSi \n fermer(f) \nFin \n \n \n \nProcédure Ecrire_chaine (n :entier , ch : chaine , Var i,j : entier ) \nVar \nK : entier ; i1 : entier \nDebut \n Pour ( k := 1 , n ) faire \n Si ( j<=b ) alors \n Buf.tab[j] := ch[k] \n j := j + 1 \n sinon \n ecriredir(f,i,buf) \n i := i + 1 \nbuf.tab [1] := ch[k] \n j := 2 \n finSI \n finPour \n \nFin \n \nProcédure Suppression_logique(c : chaine[20] , nomfichier :chaine) \nVar \nTrouv : booleen ; i,j : entier \nDebut"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 73,
    "text": "72 \n Ouvrir(f,nomfichier,’A’) \n Recherche(c,nomfichier,trouv,i,j) \n Si (trouv ) alors \n j := j + 3 \n si ( j > b ) alors \n j := j – b \n i := i + 1 \n finSI \n buf.tab[j] := ‘ V ’ \n ecriredir(f,i,j) \n \n Sinon \n Ecrire ( ‘’L’élément n’existe pas ! ‘’) \n finSI \nFin \narticles : structure \n tab : tableau[tailleMax]de caractères \n nb : entier //nombre des enreg \nfin structure \n \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \n i,j,k : entier \nDebut \n ouvrir(f,nomfichier,'r') \n Rech(a,nomfichier,trouv,i,j) \n TQ ( i < entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n liredir(f,i,buf)"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 74,
    "text": "73 \n k := 1 \nRecuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n cle_rech := entier (cle_rech) //convertir \n longueur := entier (longueur) //convertir \n j := j – 24 \n Si (cle_rech >= a et cle_rech <= b) et (efface == ‘F’) alors \n Pour ( n := 1 , longueur ) faire \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n j := j + 1 \n finPour \n articles.nb := articles.nb + 1 \n \n Sinon \n j := j + nombre( longeur) \n si ( j > b ) alors \n j := j – b \n i := i + 1 \n finSI \n finSi \n finTQ \n \nfermer(f) \nFin \n \nType ToVnc \ntype tbloc : structure \n tab : tableau [1..b] de caractères"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 75,
    "text": "74 \n NB : entier \n suivant : entier \n prec : entier \nfin structure \nf = fichier de tbloc buffer buf ENTETE(entier , entier ,entier ,entier ,entier) \n// 1 car = num du premier bloc \n 2 car = num de dernier bloc \n3 car = la 1ere position libre dans le dernier bloc \n4 car = le nombre de caractères perdus suite aux suppressions logiques \n5 car = position de dernier element dans le bloc \nl’enregistrement peut avoir le forme suivante : \nbbb | b | bbbbbbbbbbbbbbbbbbbb |bbbb…….b \n3 car pour la taille de l’enregistrement \n1 car pour indiquer l’effacement logique \n20 car pour la clé de l’enreg \nN car pour les autres informations \n \n \nProcédure Recherche( c:entier ; nomfichier : chaine ; var trouv :booleen , i , j) \nVar \nbi , bs , inf , sup : entier ; \ntrouv , stop:= booléen \nDebut \n ouvrir(f,nomfichier,'r') \n bs := entete(f,2) \n bi := 1 \n trouv := faux ; stop := faux ; j := 1 \n TQ ( bi <= bs et No"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 75,
    "text": " \ntrouv , stop:= booléen \nDebut \n ouvrir(f,nomfichier,'r') \n bs := entete(f,2) \n bi := 1 \n trouv := faux ; stop := faux ; j := 1 \n TQ ( bi <= bs et Non trouv et Non stop ) \n i := (bi + bs ) div 2"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 76,
    "text": "75 \n liredir(f , i , buf) \n j := j + 4 \n Recuperer_chaine(20,i,j,cle1) \n j := entete(f, 5) \n j := j + 4 \n Recuperer_chaine(20,i,j,cle2) \n cle1 := entier(cle1) ; cle2 := entier(cle2) \n Si ( c >= cle1 et c <= cle2 ) alors \ninf := 1 ; sup := nombre_element(i) \n // nombre_element == fonction qui calcule nombre des éléments \ndans le bloc \nTQ (inf <= sup et non trouv ) \n Milieu(i,inf,sup, k) \n Recuperer_chaine(3,i,k,longueur) \n Recuperer_chaine(1,i,k,efface) \n Recuperer_chaine(20,i,k,cle) \n longueur := entier(longueur) \n cle := entier(cle) \n longueur := entier(longueur) \n Si ( c == cle ) alors \n Trouv := vrai \n Sinon \n Si (c < cle ) alors \n Sup := k -24 \n sinon \n inf := k + longueur – 24 \n finSI \n finSI \nfinTQ \nSi( inf > sup) alors"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 77,
    "text": "76 \n j := inf \nfinSI \nstop := vrai \n Sinon \n Si (c < cle1 ) \n bs := i - 1 \n sinon \n bi := i + 1 \n finSI \n finSI \n finTQ \n SI (bi > bs ) alors \n i := bi \n j := 1 \n finSi \nfermer(f) \nFin \n \nProcédure recuperer_chaine(n :entier : Var i,j :entier ; Var ch : chaine ) \nVar k :entier \nDebut \nPour (k := 1 ,n ) faire \n Si (j <= b ) alors \n Ch[k] := buf.tab[j] \n j := j + 1 \n finsi \nfinPour \nFin \nProcédure milieu ( i : entier , j : entier , sup : entier ; var k : entier )"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 78,
    "text": "77 \nVar \nDebut \n nenreg := nombre_element(i,j,sup) \n nenreg := (nenreg) div 2 \n cpt := 0 \n TQ (cpt < nenreg) faire \nRecuperer_chaine(3,bloc,j,longueur) \nlongueur := entier(longueur) \n j := j + longueur – 3 \n cpt := cpt + 1 \n finTQ \n k := j \nFin \n \nProcédure nombre_element ( i : entier , j : entier, sup : entier) \nVar \nJ : entier ; cpt : entier \nDebut \n cpt := 0 \n TQ (j < sup) faire \nRecuperer_chaine(3,bloc,j,longueur) \nlongueur := entier(longueur) \n j := j + longueur – 3 \n cpt := cpt + 1 \n finTQ \nretourner cpt \nFin"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 79,
    "text": "78 \ninsertion(nomfichier : chaine; element : typeEnreg ) \nVar \n Trouv,continu : booleen ; i,j,k : entier \nDebut \n c := element [5 .. 24] \n Recherche( c , nomfichier , trouv , i , j) \n Si (trouv == faux ) alors \n ouvrir(f,nomfichier,'A') \n l liredir(f,i,buf) \n L := element [1..3] // L : taille de l’enreg \nt := taille(buf) //nombre des caractères dans le bloc \nSi ( L + t < b ) alors //buffer n’est pas plein \n K :=0 \n N := j + 1 \n // sauvegarder les elemnts apres la postion j \nTantque ( N < b ) faire \nArticles [K ] := buf.tab[N] \nK := K + 1 \nN := N + 1 \nfinTQ \ncpt := 1 \ntantque(cpt <= L ) faire \nbuf.tab[j ] := element[cpt] \nj := j+ 1 \ncpt := cpt + 1 \nfinTQ \ncpt := 1 \ntantque(cpt <= k ) faire \nbuf.tab[j ] := articles[cpt]"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 80,
    "text": "79 \ncpt := cpt + 1 \nj := j + 1 \nfinTQ \n Sinon \n K :=0 \n N := j + 1 \n // sauvegarder les elemnts apres la postion j \nTantque ( N < b ) faire \nArticles [K ] := buf.tab[N] \nK := K + 1 \nN := N + 1 \nfinTQ \ncpt := 1 \ntantque(cpt <= L ) faire \nbuf.tab[j ] := element[cpt] \nj := j+ 1 \ncpt := cpt + 1 \nfinTQ \ncpt := 1 \ntantque(j <=b ) faire \nbuf.tab[j ] := articles[cpt] \ncpt := cpt + 1 \nj := j+ 1 \nfinTQ \n i := buf .suiv \n \n finSi \n \n sinon"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 81,
    "text": "80 \n ecrire (\"L'élément existe déjà ! \" ) \n \n finSi \n fermer(f) \nFin \n \nProcédure Suppression_logique(c : chaine[20] , nomfichier :chaine) \nVar \nTrouv : booleen ; i,j : entier \nDebut \n Ouvrir(f,nomfichier,’A’) \n Recherche(c,nomfichier,trouv,i,j) \n Si (trouv ) alors \n j := j + 3 \n si ( j < b ) alors \n buf.tab[j] := ‘ V ’ \n ecriredir(f,i,j) \n finSI \n \n Sinon \n Ecrire ( ‘’L’élément n’existe pas ! ‘’) \n finSI \nFin \narticles : structure \n tab : tableau[tailleMax]de caractères \n nb : entier //nombre des enreg \nfin structure"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 82,
    "text": "81 \nProcédure Requete( a:entier, b:entier , nomfichier : chaine ; var articles : \narticles) \nVar \n i,j,k : entier \nDebut \n ouvrir(f,nomfichier,'r') \n Rech(a,nomfichier,trouv,i,j) \n TQ ( i < entete(f,2) ou i == entete(f,2) et j != entete(f,3)) faire \n liredir(f,i,buf) \n k := 1 \nRecuperer_chaine(3,i,j,longeur) ; Recuperer_chaine(1,i,j,efface) \n Recuperer_chaine(20,i,j,cle_rech) \n cle_rech := entier (cle_rech) //convertir \n longueur := entier (longueur) //convertir \n j := j – 24 \n Si (cle_rech >= a et cle_rech <= b) et (efface == ‘F’) alors \n Pour ( n := 1 , longueur ) faire \n articles.tab[k] := buf.tab[j] \n k := k + 1 \n j := j + 1 \n finPour \n articles.nb := articles.nb + 1 \n \n Sinon \n j := j + nombre( longeur) \n si ( j > b ) alors \n j := 1 \n i := i + 1 \n finSI"
  },
  {
    "file": "ProjetSFSD (1).pdf",
    "page": 83,
    "text": "82 \n finSi \n finTQ \n \nfermer(f) \nFin"
  }
]